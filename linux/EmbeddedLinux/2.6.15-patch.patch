diff -urN linux-2.6.15.orig/arch/arm/Kconfig linux-2.6.15/arch/arm/Kconfig
--- linux-2.6.15.orig/arch/arm/Kconfig	Wed Jan 11 09:18:35 2006
+++ linux-2.6.15/arch/arm/Kconfig	Wed Jan 11 09:23:12 2006
@@ -215,6 +215,12 @@
 	help
 	  This enables support for systems based on the Agilent AAEC-2000
 
+config ARCH_AT91RM9200
+	bool "AT91RM9200"
+	help
+	  Say Y here if you intend to run this kernel on an AT91RM9200-based
+	  board.
+
 endchoice
 
 source "arch/arm/mach-clps711x/Kconfig"
@@ -255,6 +261,8 @@
 
 source "arch/arm/mach-realview/Kconfig"
 
+source "arch/arm/mach-at91rm9200/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -418,7 +426,8 @@
 		   ARCH_EBSA285 || ARCH_IMX || ARCH_INTEGRATOR || \
 		   ARCH_LUBBOCK || MACH_MAINSTONE || ARCH_NETWINDER || \
 		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
-		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE
+		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
+		   ARCH_AT91RM9200
 	help
 	  If you say Y here, the LEDs on your machine will be used
 	  to provide useful information about your current system status.
diff -urN linux-2.6.15.orig/arch/arm/Makefile linux-2.6.15/arch/arm/Makefile
--- linux-2.6.15.orig/arch/arm/Makefile	Wed Jan 11 09:18:35 2006
+++ linux-2.6.15/arch/arm/Makefile	Wed Jan 11 09:23:12 2006
@@ -102,6 +102,7 @@
  machine-$(CONFIG_ARCH_H720X)	   := h720x
  machine-$(CONFIG_ARCH_AAEC2000)   := aaec2000
  machine-$(CONFIG_ARCH_REALVIEW)   := realview
+ machine-$(CONFIG_ARCH_AT91RM9200) := at91rm9200
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
diff -urN linux-2.6.15.orig/arch/arm/boot/compressed/Makefile linux-2.6.15/arch/arm/boot/compressed/Makefile
--- linux-2.6.15.orig/arch/arm/boot/compressed/Makefile	Mon Oct 31 09:47:10 2005
+++ linux-2.6.15/arch/arm/boot/compressed/Makefile	Wed Jan 11 09:23:12 2006
@@ -50,6 +50,10 @@
 OBJS		+= head-sharpsl.o
 endif
 
+ifeq ($(CONFIG_ARCH_AT91RM9200),y)
+OBJS		+= head-at91rm9200.o
+endif
+
 ifeq ($(CONFIG_DEBUG_ICEDCC),y)
 OBJS            += ice-dcc.o
 endif
diff -urN linux-2.6.15.orig/arch/arm/boot/compressed/head-at91rm9200.S linux-2.6.15/arch/arm/boot/compressed/head-at91rm9200.S
--- linux-2.6.15.orig/arch/arm/boot/compressed/head-at91rm9200.S	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/boot/compressed/head-at91rm9200.S	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,63 @@
+/*
+ * linux/arch/arm/boot/compressed/head-at91rm9200.S
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <asm/mach-types.h>
+
+		.section	".start", "ax"
+
+		@ Atmel AT91RM9200-DK : 262
+		mov	r3,	#(MACH_TYPE_AT91RM9200DK & 0xff)
+		orr	r3, r3, #(MACH_TYPE_AT91RM9200DK & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
+		@ Cogent CSB337 : 399
+		mov	r3,	#(MACH_TYPE_CSB337 & 0xff)
+		orr	r3, r3, #(MACH_TYPE_CSB337 & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
+		@ Cogent CSB637 : 648
+		mov	r3,	#(MACH_TYPE_CSB637 & 0xff)
+		orr	r3, r3, #(MACH_TYPE_CSB637 & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
+		@ Atmel AT91RM9200-EK : 705
+		mov	r3,	#(MACH_TYPE_AT91RM9200EK & 0xff)
+		orr	r3, r3, #(MACH_TYPE_AT91RM9200EK & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
+		@ Conitec Carmeva : 769
+		mov	r3,	#(MACH_TYPE_CARMEVA & 0xff)
+		orr	r3, r3, #(MACH_TYPE_CARMEVA & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
+		@ KwikByte KB920x : 612
+		mov	r3,	#(MACH_TYPE_KB9200 & 0xff)
+		orr	r3, r3, #(MACH_TYPE_KB9200 & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
+		@ Embest ATEB9200 : 923
+		mov	r3,	#(MACH_TYPE_ATEB9200 & 0xff)
+		orr	r3, r3, #(MACH_TYPE_ATEB9200 & 0xff00)
+		cmp	r7, r3
+		beq 	99f
+
+		@ Unknown board, use the AT91RM9200DK board
+		@ mov	r7, #MACH_TYPE_AT91RM9200
+		mov	r7,	#(MACH_TYPE_AT91RM9200DK & 0xff)
+		orr	r7, r7, #(MACH_TYPE_AT91RM9200DK & 0xff00)
+
+99:
diff -urN linux-2.6.15.orig/arch/arm/configs/at91rm9200dk_defconfig linux-2.6.15/arch/arm/configs/at91rm9200dk_defconfig
--- linux-2.6.15.orig/arch/arm/configs/at91rm9200dk_defconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/configs/at91rm9200dk_defconfig	Wed Jan 11 12:01:48 2006
@@ -0,0 +1,1009 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Mon Jan  9 20:54:30 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+CONFIG_ARCH_AT91RM9200=y
+
+#
+# AT91RM9200 Implementations
+#
+
+#
+# AT91RM9200 Board Type
+#
+CONFIG_ARCH_AT91RM9200DK=y
+# CONFIG_MACH_AT91RM9200EK is not set
+# CONFIG_MACH_CSB337 is not set
+# CONFIG_MACH_CSB637 is not set
+# CONFIG_MACH_CARMEVA is not set
+# CONFIG_MACH_KB9200 is not set
+# CONFIG_MACH_ATEB9200 is not set
+
+#
+# AT91RM9200 Feature Selections
+#
+CONFIG_AT91_PROGRAMMABLE_CLOCKS=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+
+#
+# PC-card bridges
+#
+CONFIG_AT91_CF=y
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+# CONFIG_LEDS_CPU is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=32M console=ttyS0,115200 initrd=0x20410000,3145728 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x10000000
+CONFIG_MTD_PHYSMAP_LEN=0x200000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_AT91_DATAFLASH=y
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_ARM_AT91_ETHER=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+# CONFIG_SERIAL_AT91_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_AT91_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_AT91_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_AT91_SPI=y
+CONFIG_AT91_SPIDEV=y
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_AT91=y
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_RTC_X1205_I2C is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+CONFIG_USB_GADGET_AT91=y
+CONFIG_USB_AT91=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_WBSD is not set
+CONFIG_MMC_AT91RM9200=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -urN linux-2.6.15.orig/arch/arm/configs/at91rm9200ek_defconfig linux-2.6.15/arch/arm/configs/at91rm9200ek_defconfig
--- linux-2.6.15.orig/arch/arm/configs/at91rm9200ek_defconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/configs/at91rm9200ek_defconfig	Wed Jan 11 12:01:59 2006
@@ -0,0 +1,998 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Mon Jan  9 20:57:31 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+CONFIG_ARCH_AT91RM9200=y
+
+#
+# AT91RM9200 Implementations
+#
+
+#
+# AT91RM9200 Board Type
+#
+# CONFIG_ARCH_AT91RM9200DK is not set
+CONFIG_MACH_AT91RM9200EK=y
+# CONFIG_MACH_CSB337 is not set
+# CONFIG_MACH_CSB637 is not set
+# CONFIG_MACH_CARMEVA is not set
+# CONFIG_MACH_KB9200 is not set
+# CONFIG_MACH_ATEB9200 is not set
+
+#
+# AT91RM9200 Feature Selections
+#
+CONFIG_AT91_PROGRAMMABLE_CLOCKS=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=32M console=ttyS0,115200 initrd=0x20410000,3145728 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x10000000
+CONFIG_MTD_PHYSMAP_LEN=0x800000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_AT91_DATAFLASH=y
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_ARM_AT91_ETHER=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+# CONFIG_SERIAL_AT91_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_AT91_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_AT91_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_AT91_SPI=y
+CONFIG_AT91_SPIDEV=y
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_AT91=y
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_RTC_X1205_I2C is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_S1D13XXX=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+CONFIG_USB_GADGET_AT91=y
+CONFIG_USB_AT91=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_WBSD is not set
+CONFIG_MMC_AT91RM9200=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -urN linux-2.6.15.orig/arch/arm/configs/ateb9200_defconfig linux-2.6.15/arch/arm/configs/ateb9200_defconfig
--- linux-2.6.15.orig/arch/arm/configs/ateb9200_defconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/configs/ateb9200_defconfig	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,1217 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14.4
+# Wed Dec 28 21:10:50 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+CONFIG_ARCH_AT91RM9200=y
+
+#
+# AT91RM9200 Implementations
+#
+
+#
+# AT91RM9200 Board Type
+#
+# CONFIG_ARCH_AT91RM9200DK is not set
+# CONFIG_MACH_AT91RM9200EK is not set
+# CONFIG_MACH_CSB337 is not set
+# CONFIG_MACH_CSB637 is not set
+# CONFIG_MACH_CARMEVA is not set
+# CONFIG_MACH_KB9200 is not set
+CONFIG_MACH_ATEB9200=y
+
+#
+# AT91RM9200 Feature Selections
+#
+# CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+
+#
+# PC-card bridges
+#
+CONFIG_AT91_CF=m
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+CONFIG_NO_IDLE_HZ=y
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_APM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=m
+CONFIG_VLAN_8021Q=m
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+# CONFIG_MTD_BLOCK is not set
+CONFIG_MTD_BLOCK_RO=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_AT91_DATAFLASH=y
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+CONFIG_DAVICOM_PHY=y
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_ARM_AT91_ETHER=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_PCMCIA_WAVELAN is not set
+# CONFIG_PCMCIA_NETWAVE is not set
+
+#
+# Wireless 802.11 Frequency Hopping cards support
+#
+# CONFIG_PCMCIA_RAYCS is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wireless 802.11b Pcmcia/Cardbus cards support
+#
+# CONFIG_AIRO_CS is not set
+# CONFIG_PCMCIA_WL3501 is not set
+# CONFIG_HOSTAP is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+# CONFIG_SERIAL_AT91_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_AT91_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+CONFIG_AT91_SPI=y
+CONFIG_AT91_SPIDEV=y
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_AT91=m
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_OBSOLETE_OSS_USB_DRIVER is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+CONFIG_HID_FF=y
+CONFIG_HID_PID=y
+CONFIG_LOGITECH_FF=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_CDCETHER=y
+CONFIG_USB_NET_GL620A=y
+CONFIG_USB_NET_NET1080=y
+CONFIG_USB_NET_PLUSB=y
+CONFIG_USB_NET_RNDIS_HOST=y
+CONFIG_USB_NET_CDC_SUBSET=y
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_NET_ZAURUS=y
+# CONFIG_USB_ZD1201 is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+CONFIG_USB_SERIAL_CP2101=m
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+CONFIG_USB_GADGET_AT91=y
+CONFIG_USB_AT91=m
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=m
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_BLOCK=m
+# CONFIG_MMC_WBSD is not set
+CONFIG_MMC_AT91RM9200=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=m
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=m
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_TCP=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_RPCSEC_GSS_KRB5=m
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_CODEPAGE_932=m
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=m
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
diff -urN linux-2.6.15.orig/arch/arm/configs/carmeva_defconfig linux-2.6.15/arch/arm/configs/carmeva_defconfig
--- linux-2.6.15.orig/arch/arm/configs/carmeva_defconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/configs/carmeva_defconfig	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,724 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc4
+# Tue Jun 14 12:05:24 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+CONFIG_ARCH_AT91RM9200=y
+
+#
+# AT91RM9200 Implementations
+#
+# CONFIG_ARCH_AT91RM9200DK is not set
+# CONFIG_MACH_AT91RM9200EK is not set
+# CONFIG_MACH_CSB337 is not set
+# CONFIG_MACH_CSB637 is not set
+CONFIG_MACH_CARMEVA=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_DISCONTIGMEM is not set
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_AT91_DATAFLASH=y
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_ARM_AT91_ETHER=y
+CONFIG_ARM_AT91_ETHER_RMII=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=m
+CONFIG_SERIO_SERPORT=m
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_AT91_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+CONFIG_AT91_SPI=y
+CONFIG_AT91_SPIDEV=y
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=m
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_AT91RM9200=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS_XATTR=y
+CONFIG_DEVPTS_FS_SECURITY=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS_PROC_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_NAND=y
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -urN linux-2.6.15.orig/arch/arm/configs/csb337_defconfig linux-2.6.15/arch/arm/configs/csb337_defconfig
--- linux-2.6.15.orig/arch/arm/configs/csb337_defconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/configs/csb337_defconfig	Wed Jan 11 09:25:07 2006
@@ -0,0 +1,1136 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Mon Jan  9 21:51:31 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+CONFIG_ARCH_AT91RM9200=y
+
+#
+# AT91RM9200 Implementations
+#
+
+#
+# AT91RM9200 Board Type
+#
+# CONFIG_ARCH_AT91RM9200DK is not set
+# CONFIG_MACH_AT91RM9200EK is not set
+CONFIG_MACH_CSB337=y
+# CONFIG_MACH_CSB637 is not set
+# CONFIG_MACH_CARMEVA is not set
+# CONFIG_MACH_KB9200 is not set
+# CONFIG_MACH_ATEB9200 is not set
+
+#
+# AT91RM9200 Feature Selections
+#
+CONFIG_AT91_PROGRAMMABLE_CLOCKS=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+
+#
+# PC-card bridges
+#
+CONFIG_AT91_CF=y
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=32M console=ttyS0,38400 initrd=0x20410000,3145728 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_CSB337=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_AT91_DATAFLASH is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+# CONFIG_BLK_DEV_SD is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_ARM_AT91_ETHER=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+# CONFIG_SERIAL_AT91_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_AT91_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_RTC=y
+# CONFIG_AT91_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_AT91_SPI=y
+CONFIG_AT91_SPIDEV=y
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_AT91=y
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_RTC_X1205_I2C is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CONSOLE=y
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ANYDATA is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=y
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+CONFIG_USB_SERIAL_KEYSPAN=y
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+CONFIG_USB_SERIAL_MCT_U232=y
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+CONFIG_USB_EZUSB=y
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+CONFIG_USB_GADGET_AT91=y
+CONFIG_USB_AT91=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_WBSD is not set
+CONFIG_MMC_AT91RM9200=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -urN linux-2.6.15.orig/arch/arm/configs/csb637_defconfig linux-2.6.15/arch/arm/configs/csb637_defconfig
--- linux-2.6.15.orig/arch/arm/configs/csb637_defconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/configs/csb637_defconfig	Wed Jan 11 09:25:07 2006
@@ -0,0 +1,1116 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Mon Jan  9 21:52:00 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+CONFIG_ARCH_AT91RM9200=y
+
+#
+# AT91RM9200 Implementations
+#
+
+#
+# AT91RM9200 Board Type
+#
+# CONFIG_ARCH_AT91RM9200DK is not set
+# CONFIG_MACH_AT91RM9200EK is not set
+# CONFIG_MACH_CSB337 is not set
+CONFIG_MACH_CSB637=y
+# CONFIG_MACH_CARMEVA is not set
+# CONFIG_MACH_KB9200 is not set
+# CONFIG_MACH_ATEB9200 is not set
+
+#
+# AT91RM9200 Feature Selections
+#
+CONFIG_AT91_PROGRAMMABLE_CLOCKS=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+
+#
+# PC-card bridges
+#
+CONFIG_AT91_CF=y
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=32M console=ttyS0,38400 initrd=0x20410000,3145728 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_CSB637=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_AT91_DATAFLASH is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+# CONFIG_BLK_DEV_SD is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_ARM_AT91_ETHER=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+# CONFIG_SERIAL_AT91_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_AT91_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_RTC=y
+# CONFIG_AT91_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_AT91_SPI=y
+CONFIG_AT91_SPIDEV=y
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_AT91=y
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_RTC_X1205_I2C is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CONSOLE=y
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ANYDATA is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=y
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+CONFIG_USB_SERIAL_KEYSPAN=y
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+CONFIG_USB_SERIAL_MCT_U232=y
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+CONFIG_USB_EZUSB=y
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -urN linux-2.6.15.orig/arch/arm/configs/kb9202_defconfig linux-2.6.15/arch/arm/configs/kb9202_defconfig
--- linux-2.6.15.orig/arch/arm/configs/kb9202_defconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/configs/kb9202_defconfig	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,781 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.13-rc2
+# Sun Aug 14 19:26:59 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+# CONFIG_EXPERIMENTAL is not set
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_SWAP is not set
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+# CONFIG_KOBJECT_UEVENT is not set
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+CONFIG_ARCH_AT91RM9200=y
+
+#
+# AT91RM9200 Implementations
+#
+# CONFIG_ARCH_AT91RM9200DK is not set
+# CONFIG_MACH_AT91RM9200EK is not set
+# CONFIG_MACH_CSB337 is not set
+# CONFIG_MACH_CSB637 is not set
+# CONFIG_MACH_CARMEVA is not set
+CONFIG_MACH_KB9200=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x10000000
+CONFIG_ZBOOT_ROM_BSS=0x20040000
+CONFIG_ZBOOT_ROM=y
+CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/ram rw initrd=0x20210000,654933"
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_AOUT=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+CONFIG_DEBUG_DRIVER=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IP_TCPDIAG is not set
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_ARM_AT91_ETHER=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_AT91_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_AT91_SPI is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_DEVPTS_FS_XATTR=y
+# CONFIG_DEVPTS_FS_SECURITY is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/Kconfig linux-2.6.15/arch/arm/mach-at91rm9200/Kconfig
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/Kconfig	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/Kconfig	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,60 @@
+if ARCH_AT91RM9200
+
+menu "AT91RM9200 Implementations"
+
+comment "AT91RM9200 Board Type"
+
+config ARCH_AT91RM9200DK
+	bool "Atmel AT91RM9200-DK Development board"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Atmel's AT91RM9200-DK Development board
+
+config MACH_AT91RM9200EK
+	bool "Atmel AT91RM9200-EK Evaluation Kit"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Atmel's AT91RM9200-EK Evaluation Kit
+
+config MACH_CSB337
+	bool "Cogent CSB337 board"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Cogent's CSB337 board
+
+config MACH_CSB637
+	bool "Cogent CSB637 board"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Cogent's CSB637 board
+
+config MACH_CARMEVA
+	bool "Conitec's ARM&EVA"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Conitec's AT91RM9200-MCU-Module
+
+config MACH_KB9200
+	bool "KwikByte's KB920x"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using KwikByte's KB920x board
+
+config MACH_ATEB9200
+	bool "Embest's ATEB9200"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Embest's ATEB9200 board
+
+
+comment "AT91RM9200 Feature Selections"
+
+config AT91_PROGRAMMABLE_CLOCKS
+	bool "Programmable Clocks"
+	help
+	  Select this if you need to program one or more of the PCK0..PCK3
+	  programmable clock outputs.
+
+endmenu
+
+endif
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/Makefile linux-2.6.15/arch/arm/mach-at91rm9200/Makefile
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/Makefile	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/Makefile	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,28 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y		:= clock.o irq.o time.o gpio.o common.o devices.o
+obj-m		:=
+obj-n		:=
+obj-		:=
+
+# Board-specific support
+obj-$(CONFIG_ARCH_AT91RM9200DK)	+= board-dk.o
+obj-$(CONFIG_MACH_AT91RM9200EK)	+= board-ek.o
+obj-$(CONFIG_MACH_CSB337)	+= board-csb337.o
+obj-$(CONFIG_MACH_CSB637)	+= board-csb637.o
+obj-$(CONFIG_MACH_CARMEVA)	+= board-carmeva.o
+obj-$(CONFIG_MACH_KB9200)	+= board-kb9202.o
+obj-$(CONFIG_MACH_ATEB9200)	+= board-eb9200.o
+
+# LEDs support
+led-$(CONFIG_ARCH_AT91RM9200DK)	+= leds.o
+led-$(CONFIG_MACH_AT91RM9200EK)	+= leds.o
+led-$(CONFIG_MACH_CSB337)	+= leds.o
+led-$(CONFIG_MACH_CSB637)	+= leds.o
+led-$(CONFIG_MACH_KB9200)	+= leds.o
+obj-$(CONFIG_LEDS) += $(led-y)
+
+# VGA support
+obj-$(CONFIG_FB_S1D13XXX)	+= ics1523.o
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/Makefile.boot linux-2.6.15/arch/arm/mach-at91rm9200/Makefile.boot
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/Makefile.boot	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/Makefile.boot	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,9 @@
+# Note: the following conditions must always be true:
+#   ZRELADDR == virt_to_phys(TEXTADDR)
+#   PARAMS_PHYS must be within 4MB of ZRELADDR
+#   INITRD_PHYS must be in RAM
+
+   zreladdr-y	:= 0x20008000
+params_phys-y	:= 0x20000100
+initrd_phys-y	:= 0x20410000
+
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-carmeva.c linux-2.6.15/arch/arm/mach-at91rm9200/board-carmeva.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-carmeva.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/board-carmeva.c	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,134 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-carmeva.c
+ *
+ *  Copyright (c) 2005 Peer Georgi
+ *  		       Conitec Datasystems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+
+#include "generic.h"
+
+static void __init carmeva_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91rm9200_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(BGA_GPIO_BANKS);
+}
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+#define CARMEVA_UART_MAP		{ 4, 1, -1, -1, -1 }	/* ttyS0, ..., ttyS4 */
+#define CARMEVA_SERIAL_CONSOLE		0			/* ttyS0 */
+
+static void __init carmeva_map_io(void)
+{
+	int serial[AT91_NR_UART] = CARMEVA_UART_MAP;
+	int i;
+
+	at91rm9200_map_io();
+
+	/* Initialize clocks: 20.000 MHz crystal */
+	at91_clock_init(20000000);
+
+#ifdef CONFIG_SERIAL_AT91
+	at91_console_port = CARMEVA_SERIAL_CONSOLE;
+	memcpy(at91_serial_map, serial, sizeof(serial));
+	
+	/* Register UARTs */
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (at91_serial_map[i] >= 0)
+			at91_register_uart(i, at91_serial_map[i]);
+	}
+#endif
+}
+
+static struct at91_eth_data __initdata carmeva_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PC4,
+	.is_rmii	= 1,
+};
+
+static struct at91_usbh_data __initdata carmeva_usbh_data = {
+	.ports		= 2,
+};
+
+static struct at91_udc_data __initdata carmeva_udc_data = {
+	.vbus_pin	= AT91_PIN_PD12,
+	.pullup_pin	= AT91_PIN_PD9,
+};
+
+/* FIXME: user dependend */
+// static struct at91_cf_data __initdata carmeva_cf_data = {
+//	.det_pin	= AT91_PIN_PB0,
+//	.rst_pin	= AT91_PIN_PC5,
+	// .irq_pin	= ... not connected
+	// .vcc_pin	= ... always powered
+// };
+
+static struct at91_mmc_data __initdata carmeva_mmc_data = {
+	.is_b		= 0,
+	.wire4		= 1,
+};
+
+static void __init carmeva_board_init(void)
+{
+	/* Ethernet */
+	at91_add_device_eth(&carmeva_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&carmeva_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&carmeva_udc_data);
+	/* Compact Flash */
+//	at91_add_device_cf(&carmeva_cf_data);
+	/* MMC */
+	at91_add_device_mmc(&carmeva_mmc_data);
+}
+
+MACHINE_START(CARMEVA, "Carmeva")
+	/* Maintainer: Conitec Datasystems */
+	.phys_ram	= AT91_SDRAM_BASE,
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= carmeva_map_io,
+	.init_irq	= carmeva_init_irq,
+	.init_machine	= carmeva_board_init,
+MACHINE_END
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-csb337.c linux-2.6.15/arch/arm/mach-at91rm9200/board-csb337.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-csb337.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/board-csb337.c	Wed Jan 11 09:25:07 2006
@@ -0,0 +1,143 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-csb337.c
+ *
+ *  Copyright (C) 2005 SAN People
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+
+#include "generic.h"
+
+static void __init csb337_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91rm9200_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(BGA_GPIO_BANKS);
+}
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+#define CSB337_UART_MAP		{ 4, 1, -1, -1, -1 }	/* ttyS0, ..., ttyS4 */
+#define CSB337_SERIAL_CONSOLE	0			/* ttyS0 */
+
+static void __init csb337_map_io(void)
+{
+	int serial[AT91_NR_UART] = CSB337_UART_MAP;
+	int i;
+
+	at91rm9200_map_io();
+
+	/* Initialize clocks: 3.6864 MHz crystal */
+	at91_clock_init(3686400);
+
+#ifdef CONFIG_SERIAL_AT91
+	at91_console_port = CSB337_SERIAL_CONSOLE;
+	memcpy(at91_serial_map, serial, sizeof(serial));
+
+	/* Register UARTs */
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (serial[i] >= 0)
+			at91_register_uart(i, serial[i]);
+	}
+#endif
+}
+
+static struct at91_eth_data __initdata csb337_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PC2,
+	.is_rmii	= 0,
+};
+
+static struct at91_usbh_data __initdata csb337_usbh_data = {
+	.ports		= 2,
+};
+
+static struct at91_udc_data __initdata csb337_udc_data = {
+	// this has no VBUS sensing pin
+	.pullup_pin	= AT91_PIN_PA24,
+};
+
+static struct at91_cf_data __initdata csb337_cf_data = {
+	/*
+	 * connector P4 on the CSB 337 mates to
+	 * connector P8 on the CSB 300CF
+	 */
+
+	/* CSB337 specific */
+	.det_pin	= AT91_PIN_PC3,
+
+	/* CSB300CF specific */
+	.irq_pin	= AT91_PIN_PA19,
+	.vcc_pin	= AT91_PIN_PD0,
+	.rst_pin	= AT91_PIN_PD2,
+};
+
+static struct at91_mmc_data __initdata csb337_mmc_data = {
+	.det_pin	= AT91_PIN_PD5,
+	.is_b		= 0,
+	.wire4		= 1,
+	.wp_pin		= AT91_PIN_PD6,
+};
+
+static void __init csb337_board_init(void)
+{
+	/* Ethernet */
+	at91_add_device_eth(&csb337_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&csb337_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&csb337_udc_data);
+	/* Compact Flash */
+	at91_set_gpio_input(AT91_PIN_PB22, 1);		/* IOIS16 */
+	at91_add_device_cf(&csb337_cf_data);
+	/* MMC */
+	at91_add_device_mmc(&csb337_mmc_data);
+}
+
+MACHINE_START(CSB337, "Cogent CSB337")
+	/* Maintainer: Bill Gatliff */
+	.phys_ram	= AT91_SDRAM_BASE,
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= csb337_map_io,
+	.init_irq	= csb337_init_irq,
+	.init_machine	= csb337_board_init,
+MACHINE_END
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-csb637.c linux-2.6.15/arch/arm/mach-at91rm9200/board-csb637.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-csb637.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/board-csb637.c	Wed Jan 11 09:25:07 2006
@@ -0,0 +1,116 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-csb637.c
+ *
+ *  Copyright (C) 2005 SAN People
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+
+#include "generic.h"
+
+static void __init csb637_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91rm9200_init_irq(NULL);
+	
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(BGA_GPIO_BANKS);
+}
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+#define CSB637_UART_MAP		{ 4, 1, -1, -1, -1 }	/* ttyS0, ..., ttyS4 */
+#define CSB637_SERIAL_CONSOLE	0			/* ttyS0 */
+
+static void __init csb637_map_io(void)
+{
+	int serial[AT91_NR_UART] = CSB637_UART_MAP;
+	int i;
+
+	at91rm9200_map_io();
+
+	/* Initialize clocks: 3.6864 MHz crystal */
+	at91_clock_init(3686400);
+
+#ifdef CONFIG_SERIAL_AT91
+	at91_console_port = CSB637_SERIAL_CONSOLE;
+	memcpy(at91_serial_map, serial, sizeof(serial));
+
+	/* Register UARTs */
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (serial[i] >= 0)
+			at91_register_uart(i, serial[i]);
+	}
+#endif
+}
+
+static struct at91_eth_data __initdata csb637_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PC0,
+	.is_rmii	= 0,
+};
+
+static struct at91_usbh_data __initdata csb637_usbh_data = {
+	.ports		= 2,
+};
+
+static struct at91_udc_data __initdata csb637_udc_data = {
+	.vbus_pin     = AT91_PIN_PB28,
+	.pullup_pin   = AT91_PIN_PB1,
+};
+
+static void __init csb637_board_init(void)
+{
+	/* Ethernet */
+	at91_add_device_eth(&csb637_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&csb637_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&csb637_udc_data);
+}
+
+MACHINE_START(CSB637, "Cogent CSB637")
+	/* Maintainer: Bill Gatliff */
+	.phys_ram	= AT91_SDRAM_BASE,
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= csb637_map_io,
+	.init_irq	= csb637_init_irq,
+	.init_machine	= csb637_board_init,
+MACHINE_END
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-dk.c linux-2.6.15/arch/arm/mach-at91rm9200/board-dk.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-dk.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/board-dk.c	Wed Jan 11 12:27:58 2006
@@ -0,0 +1,324 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-dk.c
+ *
+ *  Copyright (C) 2005 SAN People
+ *
+ *  Epson S1D framebuffer glue code is:
+ *     Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+
+#include "generic.h"
+
+static void __init dk_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91rm9200_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(BGA_GPIO_BANKS);
+}
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+#define DK_UART_MAP		{ 4, 1, -1, -1, -1 }	/* ttyS0, ..., ttyS4 */
+#define DK_SERIAL_CONSOLE	0			/* ttyS0 */
+
+static void __init dk_map_io(void)
+{
+	int serial[AT91_NR_UART] = DK_UART_MAP;
+	int i;
+
+	at91rm9200_map_io();
+
+	/* Initialize clocks: 18.432 MHz crystal */
+	at91_clock_init(18432000);
+
+#ifdef CONFIG_SERIAL_AT91
+	at91_console_port = DK_SERIAL_CONSOLE;
+	memcpy(at91_serial_map, serial, sizeof(serial));
+	
+	/* Register UARTs */
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (at91_serial_map[i] >= 0)
+			at91_register_uart(i, at91_serial_map[i]);
+	}
+#endif
+}
+
+#if defined(CONFIG_FB_S1D13XXX) || defined(CONFIG_FB_S1D13XXX_MODULE)
+#include <video/s1d13xxxfb.h>
+#include <asm/arch/ics1523.h>
+
+/* EPSON S1D13806 FB */
+#define AT91_FB_REG_BASE	0x30000000L
+#define AT91_FB_REG_SIZE	0x200
+#define AT91_FB_VMEM_BASE	0x30200000L
+#define AT91_FB_VMEM_SIZE	0x140000L
+
+static void __init dk_init_video(void)
+{
+	/* NWAIT Signal */
+	at91_sys_write(AT91_PIOC + PIO_ASR, AT91_PC6_NWAIT);
+	at91_sys_write(AT91_PIOC + PIO_BSR, 0);
+	at91_sys_write(AT91_PIOC + PIO_PDR, AT91_PC6_NWAIT);
+
+	/* Initialization of the Static Memory Controller for Chip Select 2 */
+	at91_sys_write(AT91_SMC_CSR(2), AT91_SMC_DBW_16			/* 16 bit */
+				| AT91_SMC_WSEN | AT91_SMC_NWS_(4)	/* wait states */
+				| AT91_SMC_TDF_(1)			/* float time */
+	);
+
+	AT91F_ICS1523_clockinit();
+}
+
+/* CRT:    (active)   640x480 60Hz (PCLK=CLKI=25.175MHz)
+   Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=60.000MHz) */
+static const struct s1d13xxxfb_regval dk_s1dfb_initregs[] = {
+	{S1DREG_MISC,			0x00},	/* Enable Memory/Register select bit */
+	{S1DREG_COM_DISP_MODE,		0x00},	/* disable display output */
+	{S1DREG_GPIO_CNF0,		0x00},	
+	{S1DREG_GPIO_CNF1,		0x00},	
+	{S1DREG_GPIO_CTL0,		0x08},
+	{S1DREG_GPIO_CTL1,		0x00},
+	{S1DREG_CLK_CNF,		0x01},	/* no divide, MCLK source is CLKI3 0x02*/
+	{S1DREG_LCD_CLK_CNF,		0x00},
+	{S1DREG_CRT_CLK_CNF,		0x00},
+	{S1DREG_MPLUG_CLK_CNF,		0x00},
+	{S1DREG_CPU2MEM_WST_SEL,	0x01},	/* 2*period(MCLK) - 4ns > period(BCLK) */
+	{S1DREG_SDRAM_REF_RATE,		0x03},	/* 32768 <= MCLK <= 50000 (MHz) */
+	{S1DREG_SDRAM_TC0,		0x00},	/* MCLK source freq (MHz): */
+	{S1DREG_SDRAM_TC1,		0x01},	/* 42 <= MCLK <= 50 */
+	{S1DREG_MEM_CNF,		0x80},	/* SDRAM Initialization - needed before mem access */
+	{S1DREG_PANEL_TYPE,		0x25},	/* std TFT 16bit, 8bit SCP format 2, single passive LCD */
+	{S1DREG_MOD_RATE,		0x00},	/* toggle every FPFRAME */
+	{S1DREG_LCD_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_LCD_NDISP_HPER,		0x12},	/* 152 pix */
+	{S1DREG_TFT_FPLINE_START,	0x01},	/* 13 pix */
+	{S1DREG_TFT_FPLINE_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_LCD_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_LCD_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_LCD_NDISP_VPER,		0x2C},	/* 44 lines */
+	{S1DREG_TFT_FPFRAME_START,	0x0A},	/* 10 lines */
+	{S1DREG_TFT_FPFRAME_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_LCD_DISP_MODE,		0x05},  /* 16 bpp */
+	{S1DREG_LCD_MISC,		0x00},	/* dithering enabled, dual panel buffer enabled */
+	{S1DREG_LCD_DISP_START0,	0x00},
+	{S1DREG_LCD_DISP_START1,	0xC8},
+	{S1DREG_LCD_DISP_START2,	0x00},
+	{S1DREG_LCD_MEM_OFF0,		0x80},
+	{S1DREG_LCD_MEM_OFF1,		0x02},
+	{S1DREG_LCD_PIX_PAN,		0x00},
+	{S1DREG_LCD_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_LCD_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_CRT_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_CRT_NDISP_HPER,		0x13},	/* 160 pix */
+	{S1DREG_CRT_HRTC_START,		0x01},	/* 13 pix */
+	{S1DREG_CRT_HRTC_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_CRT_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_CRT_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_CRT_NDISP_VPER,		0x2B},	/* 44 lines */
+	{S1DREG_CRT_VRTC_START,		0x09},	/* 10 lines */
+	{S1DREG_CRT_VRTC_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_TV_OUT_CTL,		0x10},
+	{S1DREG_CRT_DISP_MODE,		0x05},	/* 16 bpp */
+	{S1DREG_CRT_DISP_START0,	0x00},
+	{S1DREG_CRT_DISP_START1,	0x00},
+	{S1DREG_CRT_DISP_START2,	0x00},
+	{S1DREG_CRT_MEM_OFF0,		0x80},
+	{S1DREG_CRT_MEM_OFF1,		0x02},
+	{S1DREG_CRT_PIX_PAN,		0x00},
+	{S1DREG_CRT_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_CRT_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_LCD_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_LCD_CUR_START,		0x01},
+	{S1DREG_LCD_CUR_XPOS0,		0x00},
+	{S1DREG_LCD_CUR_XPOS1,		0x00},
+	{S1DREG_LCD_CUR_YPOS0,		0x00},
+	{S1DREG_LCD_CUR_YPOS1,		0x00},
+	{S1DREG_LCD_CUR_BCTL0,		0x00},
+	{S1DREG_LCD_CUR_GCTL0,		0x00},
+	{S1DREG_LCD_CUR_RCTL0,		0x00},
+	{S1DREG_LCD_CUR_BCTL1,		0x1F},
+	{S1DREG_LCD_CUR_GCTL1,		0x3F},
+	{S1DREG_LCD_CUR_RCTL1,		0x1F},
+	{S1DREG_LCD_CUR_FIFO_HTC,	0x00},
+	{S1DREG_CRT_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_CRT_CUR_START,		0x01},
+	{S1DREG_CRT_CUR_XPOS0,		0x00},
+	{S1DREG_CRT_CUR_XPOS1,		0x00},
+	{S1DREG_CRT_CUR_YPOS0,		0x00},
+	{S1DREG_CRT_CUR_YPOS1,		0x00},
+	{S1DREG_CRT_CUR_BCTL0,		0x00},
+	{S1DREG_CRT_CUR_GCTL0,		0x00},
+	{S1DREG_CRT_CUR_RCTL0,		0x00},
+	{S1DREG_CRT_CUR_BCTL1,		0x1F},
+	{S1DREG_CRT_CUR_GCTL1,		0x3F},
+	{S1DREG_CRT_CUR_RCTL1,		0x1F},
+	{S1DREG_CRT_CUR_FIFO_HTC,	0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CC_EXP,		0x00},
+	{S1DREG_BBLT_OP,		0x00},
+	{S1DREG_BBLT_SRC_START0,	0x00},
+	{S1DREG_BBLT_SRC_START1,	0x00},
+	{S1DREG_BBLT_SRC_START2,	0x00},
+	{S1DREG_BBLT_DST_START0,	0x00},
+	{S1DREG_BBLT_DST_START1,	0x00},
+	{S1DREG_BBLT_DST_START2,	0x00},
+	{S1DREG_BBLT_MEM_OFF0,		0x00},
+	{S1DREG_BBLT_MEM_OFF1,		0x00},
+	{S1DREG_BBLT_WIDTH0,		0x00},
+	{S1DREG_BBLT_WIDTH1,		0x00},
+	{S1DREG_BBLT_HEIGHT0,		0x00},
+	{S1DREG_BBLT_HEIGHT1,		0x00},
+	{S1DREG_BBLT_BGC0,		0x00},
+	{S1DREG_BBLT_BGC1,		0x00},
+	{S1DREG_BBLT_FGC0,		0x00},
+	{S1DREG_BBLT_FGC1,		0x00},
+	{S1DREG_LKUP_MODE,		0x00},	/* LCD LUT r | LCD and CRT/TV LUT w */
+	{S1DREG_LKUP_ADDR,		0x00},
+	{S1DREG_PS_CNF,			0x00},	/* Power Save disable */
+	{S1DREG_PS_STATUS,		0x02},	/* LCD Panel down, mem up */
+	{S1DREG_CPU2MEM_WDOGT,		0x00},
+	{S1DREG_COM_DISP_MODE,		0x02},	/* enable CRT display output */
+};
+
+static struct s1d13xxxfb_pdata dk_s1dfb_pdata = {
+	.initregs		= dk_s1dfb_initregs,
+	.initregssize		= ARRAY_SIZE(dk_s1dfb_initregs),
+	.platform_init_video	= dk_init_video,
+};
+
+static u64 s1dfb_dmamask = 0xffffffffUL;
+
+static struct resource dk_s1dfb_resource[] = {
+	[0] = {	/* video mem */
+		.name   = "s1d13806 memory",
+		.start  = AT91_FB_VMEM_BASE,
+		.end    = AT91_FB_VMEM_BASE + AT91_FB_VMEM_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {	/* video registers */
+		.name   = "s1d13806 registers",
+		.start  = AT91_FB_REG_BASE,
+		.end    = AT91_FB_REG_BASE + AT91_FB_REG_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dk_s1dfb_device = {
+	.name		= "s1d13806fb",
+	.id		= -1,
+	.dev		= {
+			.dma_mask		= &s1dfb_dmamask,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &dk_s1dfb_pdata,
+	},
+	.resource	= dk_s1dfb_resource,
+	.num_resources	= ARRAY_SIZE(dk_s1dfb_resource),
+};
+
+static void __init dk_add_device_video(void)
+{
+	platform_device_register(&dk_s1dfb_device);
+}
+#else
+static void __init dk_add_device_video(void) {}
+#endif
+
+static struct at91_eth_data __initdata dk_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PC4,
+	.is_rmii	= 1,
+};
+
+static struct at91_usbh_data __initdata dk_usbh_data = {
+	.ports		= 2,
+};
+
+static struct at91_udc_data __initdata dk_udc_data = {
+	.vbus_pin	= AT91_PIN_PD4,
+	.pullup_pin	= AT91_PIN_PD5,
+};
+
+static struct at91_cf_data __initdata dk_cf_data = {
+	.det_pin	= AT91_PIN_PB0,
+	.rst_pin	= AT91_PIN_PC5,
+	// .irq_pin	= ... not connected
+	// .vcc_pin	= ... always powered
+};
+
+static struct at91_mmc_data __initdata dk_mmc_data = {
+	.is_b		= 0,
+	.wire4		= 1,
+};
+
+static void __init dk_board_init(void)
+{
+	/* Ethernet */
+	at91_add_device_eth(&dk_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&dk_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&dk_udc_data);
+	/* Compact Flash */
+	at91_add_device_cf(&dk_cf_data);
+#ifdef CONFIG_MTD_AT91_DATAFLASH_CARD
+	/* DataFlash card */
+	at91_set_gpio_output(AT91_PIN_PB7, 0);
+#else
+	/* MMC */
+	at91_set_gpio_output(AT91_PIN_PB7, 1);	/* this MMC card slot can optionally use SPI signaling (CS3). */
+	at91_add_device_mmc(&dk_mmc_data);
+#endif
+	/* VGA */
+	dk_add_device_video();
+}
+
+MACHINE_START(AT91RM9200DK, "Atmel AT91RM9200-DK")
+	/* Maintainer: SAN People/Atmel */
+	.phys_ram	= AT91_SDRAM_BASE,
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= dk_map_io,
+	.init_irq	= dk_init_irq,
+	.init_machine	= dk_board_init,
+MACHINE_END
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-eb9200.c linux-2.6.15/arch/arm/mach-at91rm9200/board-eb9200.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-eb9200.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/board-eb9200.c	Wed Jan 11 11:22:15 2006
@@ -0,0 +1,133 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-eb9200.c
+ *
+ *  Copyright (C) 2005 SAN People, adapted for ATEB9200 from Embest
+ *  by Andrew Patrikalakis
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+
+#include "generic.h"
+
+static void __init eb9200_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91rm9200_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(BGA_GPIO_BANKS);
+}
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+#define EB9200_UART_MAP		{ 4, 1, -1, -1, -1 }	/* ttyS0, ..., ttyS4 */
+#define EB9200_SERIAL_CONSOLE	0			/* ttyS0 */
+
+static void __init eb9200_map_io(void)
+{
+	int serial[AT91_NR_UART] = EB9200_UART_MAP;
+	int i;
+
+	at91rm9200_map_io();
+
+	/* Initialize clocks: 18.432 MHz crystal */
+	at91_clock_init(18432000);
+
+#ifdef CONFIG_SERIAL_AT91
+	at91_console_port = EB9200_SERIAL_CONSOLE;
+	memcpy(at91_serial_map, serial, sizeof(serial));
+	
+	/* Register UARTs */
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (at91_serial_map[i] >= 0)
+			at91_register_uart(i, at91_serial_map[i]);
+	}
+#endif
+}
+
+static struct at91_eth_data __initdata eb9200_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PC4,
+	.is_rmii	= 1,
+};
+
+static struct at91_usbh_data __initdata eb9200_usbh_data = {
+	.ports		= 2,
+};
+
+static struct at91_udc_data __initdata eb9200_udc_data = {
+	.vbus_pin	= AT91_PIN_PD4,
+	.pullup_pin	= AT91_PIN_PD5,
+};
+
+static struct at91_cf_data __initdata eb9200_cf_data = {
+	.det_pin	= AT91_PIN_PB0,
+	.rst_pin	= AT91_PIN_PC5,
+	// .irq_pin	= ... not connected
+	// .vcc_pin	= ... always powered
+};
+
+static struct at91_mmc_data __initdata eb9200_mmc_data = {
+	.is_b		= 0,
+	.wire4		= 1,
+};
+
+static void __init eb9200_board_init(void)
+{
+	/* Ethernet */
+	at91_add_device_eth(&eb9200_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&eb9200_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&eb9200_udc_data);
+	/* Compact Flash */
+	at91_add_device_cf(&eb9200_cf_data);
+	/* MMC */
+	/* only supports 1 or 4 bit interface, not wired through to SPI */
+	at91_add_device_mmc(&eb9200_mmc_data);
+}
+
+MACHINE_START(ATEB9200, "Embest ATEB9200")
+	.phys_ram	= AT91_SDRAM_BASE,
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= eb9200_map_io,
+	.init_irq	= eb9200_init_irq,
+	.init_machine	= eb9200_board_init,
+MACHINE_END
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-ek.c linux-2.6.15/arch/arm/mach-at91rm9200/board-ek.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-ek.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/board-ek.c	Wed Jan 11 12:27:58 2006
@@ -0,0 +1,319 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-ek.c
+ *
+ *  Copyright (C) 2005 SAN People
+ *
+ *  Epson S1D framebuffer glue code is:
+ *     Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+
+#include "generic.h"
+
+static void __init ek_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91rm9200_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(BGA_GPIO_BANKS);
+}
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+#define EK_UART_MAP		{ 4, 1, -1, -1, -1 }	/* ttyS0, ..., ttyS4 */
+#define EK_SERIAL_CONSOLE	0			/* ttyS0 */
+
+static void __init ek_map_io(void)
+{
+	int serial[AT91_NR_UART] = EK_UART_MAP;
+	int i;
+
+	at91rm9200_map_io();
+
+	/* Initialize clocks: 18.432 MHz crystal */
+	at91_clock_init(18432000);
+
+#ifdef CONFIG_SERIAL_AT91
+	at91_console_port = EK_SERIAL_CONSOLE;
+	memcpy(at91_serial_map, serial, sizeof(serial));
+
+	/* Register UARTs */
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (serial[i] >= 0)
+			at91_register_uart(i, serial[i]);
+	}
+#endif
+}
+
+#if defined(CONFIG_FB_S1D13XXX) || defined(CONFIG_FB_S1D13XXX_MODULE)
+#include <video/s1d13xxxfb.h>
+#include <asm/arch/ics1523.h>
+
+/* EPSON S1D13806 FB */
+#define AT91_FB_REG_BASE	0x40000000L
+#define	AT91_FB_REG_SIZE	0x200
+#define AT91_FB_VMEM_BASE	0x40200000L
+#define AT91_FB_VMEM_SIZE	0x140000L
+
+static void __init ek_init_video(void)
+{
+	/* NWAIT Signal */
+	at91_sys_write(AT91_PIOC + PIO_ASR, AT91_PC6_NWAIT);
+	at91_sys_write(AT91_PIOC + PIO_BSR, 0);
+	at91_sys_write(AT91_PIOC + PIO_PDR, AT91_PC6_NWAIT);
+
+	/* Initialization of the Static Memory Controller for Chip Select 3 */
+	at91_sys_write(AT91_SMC_CSR(3), AT91_SMC_DBW_16			/* 16 bit */
+				| AT91_SMC_WSEN | AT91_SMC_NWS_(5)	/* wait states */
+				| AT91_SMC_TDF_(1)			/* float time */
+	);
+				
+	AT91F_ICS1523_clockinit();
+}
+
+/* CRT:    (active)   640x480 60Hz (PCLK=CLKI=25.175MHz)
+   Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=60.000MHz) */
+static const struct s1d13xxxfb_regval ek_s1dfb_initregs[] = {
+	{S1DREG_MISC,			0x00},	/* Enable Memory/Register select bit */
+	{S1DREG_COM_DISP_MODE,		0x00},	/* disable display output */
+	{S1DREG_GPIO_CNF0,		0xFF},	// 0x00
+	{S1DREG_GPIO_CNF1,		0x1F},	// 0x08
+	{S1DREG_GPIO_CTL0,		0x00},
+	{S1DREG_GPIO_CTL1,		0x00},
+	{S1DREG_CLK_CNF,		0x01},	/* no divide, MCLK source is CLKI3 0x02*/
+	{S1DREG_LCD_CLK_CNF,		0x00},
+	{S1DREG_CRT_CLK_CNF,		0x00},
+	{S1DREG_MPLUG_CLK_CNF,		0x00},
+	{S1DREG_CPU2MEM_WST_SEL,	0x01},	/* 2*period(MCLK) - 4ns > period(BCLK) */
+	{S1DREG_SDRAM_REF_RATE,		0x03},	/* 32768 <= MCLK <= 50000 (MHz) */
+	{S1DREG_SDRAM_TC0,		0x00},	/* MCLK source freq (MHz): */
+	{S1DREG_SDRAM_TC1,		0x01},	/* 42 <= MCLK <= 50 */
+	{S1DREG_MEM_CNF,		0x80},	/* SDRAM Initialization - needed before mem access */
+	{S1DREG_PANEL_TYPE,		0x25},	/* std TFT 16bit, 8bit SCP format 2, single passive LCD */
+	{S1DREG_MOD_RATE,		0x00},	/* toggle every FPFRAME */
+	{S1DREG_LCD_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_LCD_NDISP_HPER,		0x12},	/* 152 pix */
+	{S1DREG_TFT_FPLINE_START,	0x01},	/* 13 pix */
+	{S1DREG_TFT_FPLINE_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_LCD_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_LCD_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_LCD_NDISP_VPER,		0x2C},	/* 44 lines */
+	{S1DREG_TFT_FPFRAME_START,	0x0A},	/* 10 lines */
+	{S1DREG_TFT_FPFRAME_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_LCD_DISP_MODE,		0x05},  /* 16 bpp */
+	{S1DREG_LCD_MISC,		0x00},	/* dithering enabled, dual panel buffer enabled */
+	{S1DREG_LCD_DISP_START0,	0x00},
+	{S1DREG_LCD_DISP_START1,	0xC8},
+	{S1DREG_LCD_DISP_START2,	0x00},
+	{S1DREG_LCD_MEM_OFF0,		0x80},
+	{S1DREG_LCD_MEM_OFF1,		0x02},
+	{S1DREG_LCD_PIX_PAN,		0x00},
+	{S1DREG_LCD_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_LCD_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_CRT_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_CRT_NDISP_HPER,		0x13},	/* 160 pix */
+	{S1DREG_CRT_HRTC_START,		0x01},	/* 13 pix */
+	{S1DREG_CRT_HRTC_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_CRT_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_CRT_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_CRT_NDISP_VPER,		0x2B},	/* 44 lines */
+	{S1DREG_CRT_VRTC_START,		0x09},	/* 10 lines */
+	{S1DREG_CRT_VRTC_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_TV_OUT_CTL,		0x10},
+	{0x005E,			0x9F},
+	{0x005F,			0x00},
+	{S1DREG_CRT_DISP_MODE,		0x05},	/* 16 bpp */
+	{S1DREG_CRT_DISP_START0,	0x00},
+	{S1DREG_CRT_DISP_START1,	0x00},
+	{S1DREG_CRT_DISP_START2,	0x00},
+	{S1DREG_CRT_MEM_OFF0,		0x80},
+	{S1DREG_CRT_MEM_OFF1,		0x02},
+	{S1DREG_CRT_PIX_PAN,		0x00},
+	{S1DREG_CRT_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_CRT_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_LCD_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_LCD_CUR_START,		0x01},
+	{S1DREG_LCD_CUR_XPOS0,		0x00},
+	{S1DREG_LCD_CUR_XPOS1,		0x00},
+	{S1DREG_LCD_CUR_YPOS0,		0x00},
+	{S1DREG_LCD_CUR_YPOS1,		0x00},
+	{S1DREG_LCD_CUR_BCTL0,		0x00},
+	{S1DREG_LCD_CUR_GCTL0,		0x00},
+	{S1DREG_LCD_CUR_RCTL0,		0x00},
+	{S1DREG_LCD_CUR_BCTL1,		0x1F},
+	{S1DREG_LCD_CUR_GCTL1,		0x3F},
+	{S1DREG_LCD_CUR_RCTL1,		0x1F},
+	{S1DREG_LCD_CUR_FIFO_HTC,	0x00},
+	{S1DREG_CRT_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_CRT_CUR_START,		0x01},
+	{S1DREG_CRT_CUR_XPOS0,		0x00},
+	{S1DREG_CRT_CUR_XPOS1,		0x00},
+	{S1DREG_CRT_CUR_YPOS0,		0x00},
+	{S1DREG_CRT_CUR_YPOS1,		0x00},
+	{S1DREG_CRT_CUR_BCTL0,		0x00},
+	{S1DREG_CRT_CUR_GCTL0,		0x00},
+	{S1DREG_CRT_CUR_RCTL0,		0x00},
+	{S1DREG_CRT_CUR_BCTL1,		0x1F},
+	{S1DREG_CRT_CUR_GCTL1,		0x3F},
+	{S1DREG_CRT_CUR_RCTL1,		0x1F},
+	{S1DREG_CRT_CUR_FIFO_HTC,	0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CC_EXP,		0x00},
+	{S1DREG_BBLT_OP,		0x00},
+	{S1DREG_BBLT_SRC_START0,	0x00},
+	{S1DREG_BBLT_SRC_START1,	0x00},
+	{S1DREG_BBLT_SRC_START2,	0x00},
+	{S1DREG_BBLT_DST_START0,	0x00},
+	{S1DREG_BBLT_DST_START1,	0x00},
+	{S1DREG_BBLT_DST_START2,	0x00},
+	{S1DREG_BBLT_MEM_OFF0,		0x00},
+	{S1DREG_BBLT_MEM_OFF1,		0x00},
+	{S1DREG_BBLT_WIDTH0,		0x00},
+	{S1DREG_BBLT_WIDTH1,		0x00},
+	{S1DREG_BBLT_HEIGHT0,		0x00},
+	{S1DREG_BBLT_HEIGHT1,		0x00},
+	{S1DREG_BBLT_BGC0,		0x00},
+	{S1DREG_BBLT_BGC1,		0x00},
+	{S1DREG_BBLT_FGC0,		0x00},
+	{S1DREG_BBLT_FGC1,		0x00},
+	{S1DREG_LKUP_MODE,		0x00},	/* LCD LUT r | LCD and CRT/TV LUT w */
+	{S1DREG_LKUP_ADDR,		0x00},
+	{S1DREG_PS_CNF,			0x10},	/* Power Save disable */
+	{S1DREG_PS_STATUS,		0x02},	/* LCD Panel down, mem up */
+	{S1DREG_CPU2MEM_WDOGT,		0x00},
+	{S1DREG_COM_DISP_MODE,		0x02},	/* enable CRT display output */
+};
+
+static struct s1d13xxxfb_pdata ek_s1dfb_pdata = {
+	.initregs		= ek_s1dfb_initregs,
+	.initregssize		= ARRAY_SIZE(ek_s1dfb_initregs),
+	.platform_init_video	= ek_init_video,
+};
+
+static u64 s1dfb_dmamask = 0xffffffffUL;
+
+static struct resource ek_s1dfb_resource[] = {
+	[0] = {	/* video mem */
+		.name   = "s1d13806 memory",
+		.start  = AT91_FB_VMEM_BASE,
+		.end    = AT91_FB_VMEM_BASE + AT91_FB_VMEM_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {	/* video registers */
+		.name   = "s1d13806 registers",
+		.start  = AT91_FB_REG_BASE,
+		.end    = AT91_FB_REG_BASE + AT91_FB_REG_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ek_s1dfb_device = {
+	.name		= "s1d13806fb",
+	.id		= -1,
+	.dev		= {
+			.dma_mask		= &s1dfb_dmamask,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &ek_s1dfb_pdata,
+	},
+	.resource	= ek_s1dfb_resource,
+	.num_resources	= ARRAY_SIZE(ek_s1dfb_resource),
+};
+
+static void __init ek_add_device_video(void)
+{
+	platform_device_register(&ek_s1dfb_device);
+}
+#else
+static void __init ek_add_device_video(void) {}
+#endif
+
+static struct at91_eth_data __initdata ek_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PC4,
+	.is_rmii	= 1,
+};
+
+static struct at91_usbh_data __initdata ek_usbh_data = {
+	.ports		= 2,
+};
+
+static struct at91_udc_data __initdata ek_udc_data = {
+	.vbus_pin	= AT91_PIN_PD4,
+	.pullup_pin	= AT91_PIN_PD5,
+};
+
+static struct at91_mmc_data __initdata ek_mmc_data = {
+	.det_pin	= AT91_PIN_PB27,
+	.is_b		= 0,
+	.wire4		= 1,
+	.wp_pin		= AT91_PIN_PA17,
+};
+
+static void __init ek_board_init(void)
+{
+	/* Ethernet */
+	at91_add_device_eth(&ek_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&ek_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&ek_udc_data);
+#ifdef CONFIG_MTD_AT91_DATAFLASH_CARD
+	/* DataFlash card */
+	at91_set_gpio_output(AT91_PIN_PB22, 0);
+#else
+	/* MMC */
+	at91_set_gpio_output(AT91_PIN_PB22, 1);	/* this MMC card slot can optionally use SPI signaling (CS3). */
+	at91_add_device_mmc(&ek_mmc_data);
+#endif
+	/* VGA */
+	ek_add_device_video();
+}
+
+MACHINE_START(AT91RM9200EK, "Atmel AT91RM9200-EK")
+	/* Maintainer: SAN People/Atmel */
+	.phys_ram	= AT91_SDRAM_BASE,
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= ek_map_io,
+	.init_irq	= ek_init_irq,
+	.init_machine	= ek_board_init,
+MACHINE_END
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-kb9202.c linux-2.6.15/arch/arm/mach-at91rm9200/board-kb9202.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/board-kb9202.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/board-kb9202.c	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,125 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-kb9202.c
+ *
+ *  Copyright (c) 2005 kb_admin
+ *  		       KwikByte, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+
+#include "generic.h"
+
+static void __init kb9202_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91rm9200_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(PQFP_GPIO_BANKS);
+}
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+#define KB9202_UART_MAP			{ 4, 0, 1, -1, -1 }	/* ttyS0, ..., ttyS4 */
+#define KB9202_SERIAL_CONSOLE		0			/* ttyS0 */
+
+static void __init kb9202_map_io(void)
+{
+	int serial[AT91_NR_UART] = KB9202_UART_MAP;
+	int i;
+
+	at91rm9200_map_io();
+
+	/* Initialize clocks: 10 MHz crystal */
+	at91_clock_init(10000000);
+
+#ifdef CONFIG_SERIAL_AT91
+	at91_console_port = KB9202_SERIAL_CONSOLE;
+	memcpy(at91_serial_map, serial, sizeof(serial));
+
+	/* Register UARTs */
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (at91_serial_map[i] >= 0)
+			at91_register_uart(i, at91_serial_map[i]);
+	}
+#endif
+}
+
+static struct at91_eth_data __initdata kb9202_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PB29,
+	.is_rmii	= 0,
+};
+
+static struct at91_usbh_data __initdata kb9202_usbh_data = {
+	.ports		= 1,
+};
+
+static struct at91_udc_data __initdata kb9202_udc_data = {
+	.vbus_pin	= AT91_PIN_PB24,
+	.pullup_pin	= AT91_PIN_PB22,
+};
+
+static struct at91_mmc_data __initdata kb9202_mmc_data = {
+	.det_pin	= AT91_PIN_PB2,
+	.is_b		= 0,
+	.wire4		= 1,
+};
+
+static void __init kb9202_board_init(void)
+{
+	/* Ethernet */
+	at91_add_device_eth(&kb9202_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&kb9202_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&kb9202_udc_data);
+	/* MMC */
+	at91_add_device_mmc(&kb9202_mmc_data);
+}
+
+MACHINE_START(KB9200, "KB920x")
+	/* Maintainer: KwikByte, Inc. */
+	.phys_ram	= AT91_SDRAM_BASE,
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= kb9202_map_io,
+	.init_irq	= kb9202_init_irq,
+	.init_machine	= kb9202_board_init,
+MACHINE_END
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/clock.c linux-2.6.15/arch/arm/mach-at91rm9200/clock.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/clock.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/clock.c	Wed Jan 11 11:21:42 2006
@@ -0,0 +1,620 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/clock.c
+ *
+ * Copyright (C) 2005 David Brownell
+ * Copyright (C) 2005 Ivan Kokshaysky
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <asm/hardware/clock.h>
+
+#include <asm/semaphore.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/board.h>		/* for master clock global */
+
+#include "generic.h"
+
+#undef	DEBUG
+
+/*
+ * There's a lot more which can be done with clocks, including cpufreq
+ * integration, slow clock mode support (for system suspend), letting
+ * PLLB be used at other rates (on boards that don't need USB), etc.
+ */
+
+struct clk {
+	const char	*name;
+	unsigned long	rate_hz;
+	struct clk	*parent;
+	u32		pmc_mask;
+	void		(*mode)(struct clk *, int);
+	unsigned	id:2;		/* PCK0..3, or 32k/main/a/b */
+	unsigned	primary:1;
+	unsigned	pll:1;
+	unsigned	programmable:1;
+	u16		users;
+};
+
+static spinlock_t	clk_lock;
+static u32		at91_pllb_usb_init;
+
+/*
+ * Four primary clock sources:  two crystal oscillators (32K, main), and
+ * two PLLs.  PLLA usually runs the master clock; and PLLB must run at
+ * 48 MHz (unless no USB function clocks are needed).  The main clock and
+ * both PLLs are turned off to run in "slow clock mode" (system suspend).
+ */
+static struct clk clk32k = {
+	.name		= "clk32k",
+	.rate_hz	= AT91_SLOW_CLOCK,
+	.users		= 1,		/* always on */
+	.id		= 0,
+	.primary	= 1,
+};
+static struct clk main_clk = {
+	.name		= "main",
+	.pmc_mask	= 1 << 0,	/* in PMC_SR */
+	.users		= 1,
+	.id		= 1,
+	.primary	= 1,
+};
+static struct clk plla = {
+	.name		= "plla",
+	.parent		= &main_clk,
+	.pmc_mask	= 1 << 1,	/* in PMC_SR */
+	.id		= 2,
+	.primary	= 1,
+	.pll		= 1,
+};
+
+static void pllb_mode(struct clk *clk, int is_on)
+{
+	u32	value;
+
+	if (is_on) {
+		is_on = AT91_PMC_LOCKB;
+		value = at91_pllb_usb_init;
+	} else
+		value = 0;
+
+	at91_sys_write(AT91_CKGR_PLLBR, value);
+
+	do {
+		cpu_relax();
+	} while ((at91_sys_read(AT91_PMC_SR) & AT91_PMC_LOCKB) != is_on);
+}
+
+static struct clk pllb = {
+	.name		= "pllb",
+	.parent		= &main_clk,
+	.pmc_mask	= 1 << 2,	/* in PMC_SR */
+	.mode		= pllb_mode,
+	.id		= 3,
+	.primary	= 1,
+	.pll		= 1,
+};
+
+static void pmc_sys_mode(struct clk *clk, int is_on)
+{
+	if (is_on)
+		at91_sys_write(AT91_PMC_SCER, clk->pmc_mask);
+	else
+		at91_sys_write(AT91_PMC_SCDR, clk->pmc_mask);
+}
+
+/* USB function clocks (PLLB must be 48 MHz) */
+static struct clk udpck = {
+	.name		= "udpck",
+	.parent		= &pllb,
+	.pmc_mask	= AT91_PMC_UDP,
+	.mode		= pmc_sys_mode,
+};
+static struct clk uhpck = {
+	.name		= "uhpck",
+	.parent		= &pllb,
+	.pmc_mask	= AT91_PMC_UHP,
+	.mode		= pmc_sys_mode,
+};
+
+#ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+/*
+ * The four programmable clocks can be parented by any primary clock.
+ * You must configure pin multiplexing to bring these signals out.
+ */
+static struct clk pck0 = {
+	.name		= "pck0",
+	.pmc_mask	= AT91_PMC_PCK0,
+	.mode		= pmc_sys_mode,
+	.programmable	= 1,
+	.id		= 0,
+};
+static struct clk pck1 = {
+	.name		= "pck1",
+	.pmc_mask	= AT91_PMC_PCK1,
+	.mode		= pmc_sys_mode,
+	.programmable	= 1,
+	.id		= 1,
+};
+static struct clk pck2 = {
+	.name		= "pck2",
+	.pmc_mask	= AT91_PMC_PCK2,
+	.mode		= pmc_sys_mode,
+	.programmable	= 1,
+	.id		= 2,
+};
+static struct clk pck3 = {
+	.name		= "pck3",
+	.pmc_mask	= AT91_PMC_PCK3,
+	.mode		= pmc_sys_mode,
+	.programmable	= 1,
+	.id		= 3,
+};
+#endif	/* CONFIG_AT91_PROGRAMMABLE_CLOCKS */
+
+
+/*
+ * The master clock is divided from the CPU clock (by 1-4).  It's used for
+ * memory, interfaces to on-chip peripherals, the AIC, and sometimes more
+ * (e.g baud rate generation).  It's sourced from one of the primary clocks.
+ */
+static struct clk mck = {
+	.name		= "mck",
+	.pmc_mask	= 1 << 3,	/* in PMC_SR */
+	.users		= 1,		/* (must be) always on */
+};
+
+static void pmc_periph_mode(struct clk *clk, int is_on)
+{
+	if (is_on)
+		at91_sys_write(AT91_PMC_PCER, clk->pmc_mask);
+	else
+		at91_sys_write(AT91_PMC_PCDR, clk->pmc_mask);
+}
+
+static struct clk udc_clk = {
+	.name		= "udc_clk",
+	.parent		= &mck,
+	.pmc_mask	= 1 << AT91_ID_UDP,
+	.mode		= pmc_periph_mode,
+};
+static struct clk ohci_clk = {
+	.name		= "ohci_clk",
+	.parent		= &mck,
+	.pmc_mask	= 1 << AT91_ID_UHP,
+	.mode		= pmc_periph_mode,
+};
+
+static struct clk *const clock_list[] = {
+	/* four primary clocks -- MUST BE FIRST! */
+	&clk32k,
+	&main_clk,
+	&plla,
+	&pllb,
+
+	/* PLLB children (USB) */
+	&udpck,
+	&uhpck,
+
+#ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+	/* programmable clocks */
+	&pck0,
+	&pck1,
+	&pck2,
+	&pck3,
+#endif	/* CONFIG_AT91_PROGRAMMABLE_CLOCKS */
+
+	/* MCK and peripherals */
+	&mck,
+	// usart0..usart3
+	// mmc
+	&udc_clk,
+	// i2c
+	// spi
+	// ssc0..ssc2
+	// tc0..tc5
+	&ohci_clk,
+	// ether
+};
+
+
+/* clocks are all static for now; no refcounting necessary */
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(clock_list); i++) {
+		if (strcmp(id, clock_list[i]->name) == 0)
+			return clock_list[i];
+	}
+
+	return ERR_PTR(-ENOENT);
+}
+EXPORT_SYMBOL(clk_get);
+
+void clk_put(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_put);
+
+static void __clk_enable(struct clk *clk)
+{
+	if (clk->parent)
+		__clk_enable(clk->parent);
+	if (clk->users++ == 0 && clk->mode)
+		clk->mode(clk, 1);
+}
+
+int clk_enable(struct clk *clk)
+{
+	unsigned long	flags;
+
+	spin_lock_irqsave(&clk_lock, flags);
+	__clk_enable(clk);
+	spin_unlock_irqrestore(&clk_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+static void __clk_disable(struct clk *clk)
+{
+	BUG_ON(clk->users == 0);
+	if (--clk->users == 0 && clk->mode)
+		clk->mode(clk, 0);
+	if (clk->parent)
+		__clk_disable(clk->parent);
+}
+
+void clk_disable(struct clk *clk)
+{
+	unsigned long	flags;
+
+	spin_lock_irqsave(&clk_lock, flags);
+	__clk_disable(clk);
+	spin_unlock_irqrestore(&clk_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long	flags;
+	unsigned long	rate;
+
+	spin_lock_irqsave(&clk_lock, flags);
+	for (;;) {
+		rate = clk->rate_hz;
+		if (rate || !clk->parent)
+			break;
+		clk = clk->parent;
+	}
+	spin_unlock_irqrestore(&clk_lock, flags);
+	return rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+/*------------------------------------------------------------------------*/
+
+#ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+
+/*
+ * For now, only the programmable clocks support reparenting (MCK could
+ * do this too, with care) or rate changing (the PLLs could do this too,
+ * ditto MCK but that's more for cpufreq).  Drivers may reparent to get
+ * a better rate match; we don't.
+ */
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long	flags;
+	unsigned	prescale;
+	unsigned long	actual;
+
+	if (!clk->programmable)
+		return -EINVAL;
+	spin_lock_irqsave(&clk_lock, flags);
+
+	actual = clk->parent->rate_hz;
+	for (prescale = 0; prescale < 7; prescale++) {
+		if (actual && actual <= rate)
+			break;
+		actual >>= 1;
+	}
+
+	spin_unlock_irqrestore(&clk_lock, flags);
+	return (prescale < 7) ? actual : -ENOENT;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long	flags;
+	unsigned	prescale;
+	unsigned long	actual;
+
+	if (!clk->programmable)
+		return -EINVAL;
+	if (clk->users)
+		return -EBUSY;
+	spin_lock_irqsave(&clk_lock, flags);
+
+	actual = clk->parent->rate_hz;
+	for (prescale = 0; prescale < 7; prescale++) {
+		if (actual && actual <= rate) {
+			u32	pckr;
+
+			pckr = at91_sys_read(AT91_PMC_PCKR(clk->id));
+			pckr &= 0x03;
+			pckr |= prescale << 2;
+			at91_sys_write(AT91_PMC_PCKR(clk->id), pckr);
+			clk->rate_hz = actual;
+			break;
+		}
+		actual >>= 1;
+	}
+
+	spin_unlock_irqrestore(&clk_lock, flags);
+	return (prescale < 7) ? actual : -ENOENT;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+	return clk->parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long	flags;
+
+	if (clk->users)
+		return -EBUSY;
+	if (!parent->primary || !clk->programmable)
+		return -EINVAL;
+	spin_lock_irqsave(&clk_lock, flags);
+
+	clk->rate_hz = parent->rate_hz;
+	clk->parent = parent;
+	at91_sys_write(AT91_PMC_PCKR(clk->id), parent->id);
+
+	spin_unlock_irqrestore(&clk_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+#endif	/* CONFIG_AT91_PROGRAMMABLE_CLOCKS */
+
+/*------------------------------------------------------------------------*/
+
+#ifdef CONFIG_DEBUG_FS
+
+static int at91_clk_show(struct seq_file *s, void *unused)
+{
+	u32		scsr, pcsr, sr;
+	unsigned	i;
+
+	seq_printf(s, "SCSR = %8x\n", scsr = at91_sys_read(AT91_PMC_SCSR));
+	seq_printf(s, "PCSR = %8x\n", pcsr = at91_sys_read(AT91_PMC_PCSR));
+
+	seq_printf(s, "MOR  = %8x\n", at91_sys_read(AT91_CKGR_MOR));
+	seq_printf(s, "MCFR = %8x\n", at91_sys_read(AT91_CKGR_MCFR));
+	seq_printf(s, "PLLA = %8x\n", at91_sys_read(AT91_CKGR_PLLAR));
+	seq_printf(s, "PLLB = %8x\n", at91_sys_read(AT91_CKGR_PLLBR));
+
+	seq_printf(s, "MCKR = %8x\n", at91_sys_read(AT91_PMC_MCKR));
+	for (i = 0; i < 4; i++)
+		seq_printf(s, "PCK%d = %8x\n", i, at91_sys_read(AT91_PMC_PCKR(i)));
+	seq_printf(s, "SR   = %8x\n", sr = at91_sys_read(AT91_PMC_SR));
+
+	seq_printf(s, "\n");
+
+	for (i = 0; i < ARRAY_SIZE(clock_list); i++) {
+		char		*state;
+		struct clk	*clk = clock_list[i];
+
+		if (clk->mode == pmc_sys_mode)
+			state = (scsr & clk->pmc_mask) ? "on" : "off";
+		else if (clk->mode == pmc_periph_mode)
+			state = (pcsr & clk->pmc_mask) ? "on" : "off";
+		else if (clk->pmc_mask)
+			state = (sr & clk->pmc_mask) ? "on" : "off";
+		else if (clk == &clk32k || clk == &main_clk)
+			state = "on";
+		else
+			state = "";
+
+		seq_printf(s, "%-10s users=%d %-3s %9ld Hz %s\n",
+			clk->name, clk->users, state, clk_get_rate(clk),
+			clk->parent ? clk->parent->name : "");
+	}
+	return 0;
+}
+
+static int at91_clk_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, at91_clk_show, NULL);
+}
+
+static struct file_operations at91_clk_operations = {
+	.open		= at91_clk_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init at91_clk_debugfs_init(void)
+{
+	/* /sys/kernel/debug/at91_clk */
+	(void) debugfs_create_file("at91_clk", S_IFREG | S_IRUGO, NULL, NULL, &at91_clk_operations);
+
+	return 0;
+}
+postcore_initcall(at91_clk_debugfs_init);
+
+#endif
+
+/*------------------------------------------------------------------------*/
+
+static u32 __init at91_pll_rate(struct clk *pll, u32 freq, u32 reg)
+{
+	unsigned mul, div;
+
+	div = reg & 0xff;
+	mul = (reg >> 16) & 0x7ff;
+	if (div && mul) {
+		freq /= div;
+		freq *= mul + 1;
+	} else
+		freq = 0;
+	if (pll == &pllb && (reg & (1 << 28)))
+		freq /= 2;
+	return freq;
+}
+
+static unsigned __init at91_pll_calc(unsigned main_freq, unsigned out_freq)
+{
+	unsigned i, div = 0, mul = 0, diff = 1 << 30;
+	unsigned ret = (out_freq > 155000000) ? 0xbe00 : 0x3e00;
+
+	/* PLL output max 240 MHz (or 180 MHz per errata) */
+	if (out_freq > 240000000)
+		goto fail;
+
+	for (i = 1; i < 256; i++) {
+		int diff1;
+		unsigned input, mul1;
+
+		/*
+		 * PLL input between 1MHz and 32MHz per spec, but lower
+		 * frequences seem necessary in some cases so allow 100K.
+		 */
+		input = main_freq / i;
+		if (input < 100000)
+			continue;
+		if (input > 32000000)
+			continue;
+
+		mul1 = out_freq / input;
+		if (mul1 > 2048)
+			continue;
+		if (mul1 < 2)
+			goto fail;
+
+		diff1 = out_freq - input * mul1;
+		if (diff1 < 0)
+			diff1 = -diff1;
+		if (diff > diff1) {
+			diff = diff1;
+			div = i;
+			mul = mul1;
+			if (diff == 0)
+				break;
+		}
+	}
+	if (i == 256 && diff > (out_freq >> 5))
+		goto fail;
+	return ret | ((mul - 1) << 16) | div;
+fail:
+	return 0;
+}
+
+int __init at91_clock_init(unsigned long main_clock)
+{
+	unsigned tmp, freq, mckr;
+
+	spin_lock_init(&clk_lock);
+
+	/*
+	 * When the bootloader initialized the main oscillator correctly,
+	 * there's no problem using the cycle counter.  But if it didn't,
+	 * or when using oscillator bypass mode, we must be told the speed
+	 * of the main clock.
+	 */
+	if (!main_clock) {
+		do {
+			tmp = at91_sys_read(AT91_CKGR_MCFR);
+		} while (!(tmp & 0x10000));
+		main_clock = (tmp & 0xffff) * (AT91_SLOW_CLOCK / 16);
+	}
+	main_clk.rate_hz = main_clock;
+
+	/* report if PLLA is more than mildly overclocked */
+	plla.rate_hz = at91_pll_rate(&plla, main_clock, at91_sys_read(AT91_CKGR_PLLAR));
+	if (plla.rate_hz > 209000000)
+		pr_info("Clocks: PLLA overclocked, %ld MHz\n", plla.rate_hz / 1000000);
+
+	/*
+	 * USB clock init:  choose 48 MHz PLLB value, turn all clocks off,
+	 * disable 48MHz clock during usb peripheral suspend.
+	 *
+	 * REVISIT:  assumes MCK doesn't derive from PLLB!
+	 */
+	at91_pllb_usb_init = at91_pll_calc(main_clock, 48000000 * 2) | 0x10000000;
+	pllb.rate_hz = at91_pll_rate(&pllb, main_clock, at91_pllb_usb_init);
+	at91_sys_write(AT91_PMC_PCDR, (1 << AT91_ID_UHP) | (1 << AT91_ID_UDP));
+	at91_sys_write(AT91_PMC_SCDR, AT91_PMC_UHP | AT91_PMC_UDP);
+	at91_sys_write(AT91_CKGR_PLLBR, 0);
+	at91_sys_write(AT91_PMC_SCER, AT91_PMC_MCKUDP);
+
+	/*
+	 * MCK and CPU derive from one of those primary clocks.
+	 * For now, assume this parentage won't change.
+	 */
+	mckr = at91_sys_read(AT91_PMC_MCKR);
+	mck.parent = clock_list[mckr & AT91_PMC_CSS];
+	mck.parent->users++;
+	freq = mck.parent->rate_hz;
+	freq /= (1 << ((mckr >> 2) & 3));		/* prescale */
+	mck.rate_hz = freq / (1 + ((mckr >> 8) & 3));	/* mdiv */
+
+	printk("Clocks: CPU %u MHz, master %u MHz, main %u.%03u MHz\n",
+		freq / 1000000, (unsigned) mck.rate_hz / 1000000,
+		(unsigned) main_clock / 1000000,
+		((unsigned) main_clock % 1000000) / 1000);
+
+	/* FIXME get rid of master_clock global */
+	at91_master_clock = mck.rate_hz;
+
+#ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+	/* establish PCK0..PCK3 parentage */
+	for (tmp = 0; tmp < ARRAY_SIZE(clock_list); tmp++) {
+		struct clk	*clk = clock_list[tmp], *parent;
+		u32		pckr;
+
+		if (!clk->programmable)
+			continue;
+
+		pckr = at91_sys_read(AT91_PMC_PCKR(clk->id));
+		parent = clock_list[pckr & 3];
+		clk->parent = parent;
+		clk->rate_hz = parent->rate_hz / (1 << ((pckr >> 2) & 3));
+	}
+#else
+	/* disable unused clocks */
+	at91_sys_write(AT91_PMC_SCDR, AT91_PMC_PCK0 | AT91_PMC_PCK1 | AT91_PMC_PCK2 | AT91_PMC_PCK3);
+#endif	/* CONFIG_AT91_PROGRAMMABLE_CLOCKS */
+
+	/* FIXME several unused clocks may still be active...  provide
+	 * a CONFIG option to turn off all unused clocks at some point
+	 * before driver init starts.
+	 */
+
+	return 0;
+}
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/common.c linux-2.6.15/arch/arm/mach-at91rm9200/common.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/common.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/common.c	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,115 @@
+/*
+ * arch/arm/mach-at91rm9200/common.c
+ *
+ *  Copyright (C) 2005 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <asm/arch/hardware.h>
+
+static struct map_desc at91rm9200_io_desc[] __initdata = {
+	{
+		.virtual	= AT91_VA_BASE_SYS,
+		.pfn		= __phys_to_pfn(AT91_BASE_SYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_SPI,
+		.pfn		= __phys_to_pfn(AT91_BASE_SPI),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_SSC2,
+		.pfn		= __phys_to_pfn(AT91_BASE_SSC2),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_SSC1,
+		.pfn		= __phys_to_pfn(AT91_BASE_SSC1),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_SSC0,
+		.pfn		= __phys_to_pfn(AT91_BASE_SSC0),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_US3,
+		.pfn		= __phys_to_pfn(AT91_BASE_US3),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_US2,
+		.pfn		= __phys_to_pfn(AT91_BASE_US2),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_US1,
+		.pfn		= __phys_to_pfn(AT91_BASE_US1),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_US0,
+		.pfn		= __phys_to_pfn(AT91_BASE_US0),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_EMAC,
+		.pfn		= __phys_to_pfn(AT91_BASE_EMAC),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_TWI,
+		.pfn		= __phys_to_pfn(AT91_BASE_TWI),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_MCI,
+		.pfn		= __phys_to_pfn(AT91_BASE_MCI),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_UDP,
+		.pfn		= __phys_to_pfn(AT91_BASE_UDP),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_TCB1,
+		.pfn		= __phys_to_pfn(AT91_BASE_TCB1),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_VA_BASE_TCB0,
+		.pfn		= __phys_to_pfn(AT91_BASE_TCB0),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init at91rm9200_map_io(void)
+{
+	iotable_init(at91rm9200_io_desc, ARRAY_SIZE(at91rm9200_io_desc));
+}
+
+
+unsigned long at91_master_clock;
+
+EXPORT_SYMBOL(at91_master_clock);
+
+
+int at91_serial_map[AT91_NR_UART];
+int at91_console_port;
+
+EXPORT_SYMBOL(at91_serial_map);
+EXPORT_SYMBOL(at91_console_port);
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/devices.c linux-2.6.15/arch/arm/mach-at91rm9200/devices.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/devices.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/devices.c	Wed Jan 11 09:35:41 2006
@@ -0,0 +1,291 @@
+/*
+ * arch/arm/mach-at91rm9200/devices.c
+ *
+ *  Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ *  Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <linux/config.h>
+#include <linux/platform_device.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/pio.h>
+
+
+/* --------------------------------------------------------------------
+ *  USB Host
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+static u64 ohci_dmamask = 0xffffffffUL;
+static struct at91_usbh_data usbh_data;
+
+static struct resource at91rm9200_usbh_resource[] = {
+	[0] = {
+		.start	= AT91_UHP_BASE,
+		.end	= AT91_UHP_BASE + SZ_1M -1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91_ID_UHP,
+		.end	= AT91_ID_UHP,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91rm9200_usbh_device = {
+	.name		= "at91rm9200-ohci",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &ohci_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &usbh_data,
+	},
+	.resource	= at91rm9200_usbh_resource,
+	.num_resources	= ARRAY_SIZE(at91rm9200_usbh_resource),
+};
+
+void __init at91_add_device_usbh(struct at91_usbh_data *data)
+{
+	if (!data)
+		return;
+
+	usbh_data = *data;
+	platform_device_register(&at91rm9200_usbh_device);
+}
+#else
+void __init at91_add_device_usbh(struct at91_usbh_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  USB Device (Gadget)
+ * -------------------------------------------------------------------- */
+
+#ifdef CONFIG_USB_GADGET_AT91
+static struct at91_udc_data udc_data;
+
+static struct resource at91_udc_resources[] = {
+	{
+		.start	= AT91_BASE_UDP,
+		.end	= AT91_BASE_UDP + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device at91rm9200_udc_device = {
+	.name		= "at91_udc",
+	.id		= -1,
+	.dev		= {
+				.platform_data		= &udc_data,
+	},
+	.resource	= at91_udc_resources,
+	.num_resources	= ARRAY_SIZE(at91_udc_resources),
+};
+
+void __init at91_add_device_udc(struct at91_udc_data *data)
+{
+	if (!data)
+		return;
+
+	if (data->vbus_pin) {
+		at91_set_gpio_input(data->vbus_pin, 0);
+		at91_set_deglitch(data->vbus_pin, 1);
+	}
+	if (data->pullup_pin)
+		at91_set_gpio_output(data->pullup_pin, 0);
+
+	udc_data = *data;
+	platform_device_register(&at91rm9200_udc_device);
+}
+#else
+void __init at91_add_device_udc(struct at91_udc_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  Ethernet
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_ARM_AT91_ETHER) || defined(CONFIG_ARM_AT91_ETHER_MODULE)
+static u64 eth_dmamask = 0xffffffffUL;
+static struct at91_eth_data eth_data;
+
+static struct platform_device at91rm9200_eth_device = {
+	.name		= "at91_ether",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &eth_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &eth_data,
+	},
+	.num_resources	= 0,
+};
+
+void __init at91_add_device_eth(struct at91_eth_data *data)
+{
+	if (!data)
+		return;
+
+	if (data->phy_irq_pin) {
+		at91_set_gpio_input(data->phy_irq_pin, 0);
+		at91_set_deglitch(data->phy_irq_pin, 1);
+	}
+
+	/* Pins used for MII and RMII */
+	at91_set_A_periph(AT91_PIN_PA16, 0);	/* EMDIO */
+	at91_set_A_periph(AT91_PIN_PA15, 0);	/* EMDC */
+	at91_set_A_periph(AT91_PIN_PA14, 0);	/* ERXER */
+	at91_set_A_periph(AT91_PIN_PA13, 0);	/* ERX1 */
+	at91_set_A_periph(AT91_PIN_PA12, 0);	/* ERX0 */
+	at91_set_A_periph(AT91_PIN_PA11, 0);	/* ECRS_ECRSDV */
+	at91_set_A_periph(AT91_PIN_PA10, 0);	/* ETX1 */
+	at91_set_A_periph(AT91_PIN_PA9, 0);	/* ETX0 */
+	at91_set_A_periph(AT91_PIN_PA8, 0);	/* ETXEN */
+	at91_set_A_periph(AT91_PIN_PA7, 0);	/* ETXCK_EREFCK */
+
+	if (!data->is_rmii) {
+		at91_set_B_periph(AT91_PIN_PB19, 0);	/* ERXCK */
+		at91_set_B_periph(AT91_PIN_PB18, 0);	/* ECOL */
+		at91_set_B_periph(AT91_PIN_PB17, 0);	/* ERXDV */
+		at91_set_B_periph(AT91_PIN_PB16, 0);	/* ERX3 */
+		at91_set_B_periph(AT91_PIN_PB15, 0);	/* ERX2 */
+		at91_set_B_periph(AT91_PIN_PB14, 0);	/* ETXER */
+		at91_set_B_periph(AT91_PIN_PB13, 0);	/* ETX3 */
+		at91_set_B_periph(AT91_PIN_PB12, 0);	/* ETX2 */
+	}
+
+	eth_data = *data;
+	platform_device_register(&at91rm9200_eth_device);
+}
+#else
+void __init at91_add_device_eth(struct at91_eth_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  Compact Flash / PCMCIA
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_AT91_CF) || defined(CONFIG_AT91_CF_MODULE)
+static struct at91_cf_data cf_data;
+
+static struct platform_device at91rm9200_cf_device = {
+	.name		= "at91_cf",
+	.id		= -1,
+	.dev		= {
+				.platform_data		= &cf_data,
+	},
+	.num_resources	= 0,
+};
+
+void __init at91_add_device_cf(struct at91_cf_data *data)
+{
+	if (!data)
+		return;
+
+	/* input/irq */
+	if (data->irq_pin) {
+		at91_set_gpio_input(data->irq_pin, 1);
+		at91_set_deglitch(data->irq_pin, 1);
+	}
+	at91_set_gpio_input(data->det_pin, 1);
+	at91_set_deglitch(data->det_pin, 1);
+
+	/* outputs, initially off */
+	if (data->vcc_pin)
+		at91_set_gpio_output(data->vcc_pin, 0);
+	at91_set_gpio_output(data->rst_pin, 0);
+
+	cf_data = *data;
+	platform_device_register(&at91rm9200_cf_device);
+}
+#else
+void __init at91_add_device_cf(struct at91_cf_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  MMC / SD
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_MMC_AT91RM9200) || defined(CONFIG_MMC_AT91RM9200_MODULE)
+static u64 mmc_dmamask = 0xffffffffUL;
+static struct at91_mmc_data mmc_data;
+
+static struct resource at91_mmc_resources[] = {
+	{
+		.start	= AT91_BASE_MCI,
+		.end	= AT91_BASE_MCI + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device at91rm9200_mmc_device = {
+	.name		= "at91rm9200_mci",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &mmc_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &mmc_data,
+	},
+	.resource	= at91_mmc_resources,
+	.num_resources	= ARRAY_SIZE(at91_mmc_resources),
+};
+
+void __init at91_add_device_mmc(struct at91_mmc_data *data)
+{
+	if (!data)
+		return;
+
+	/* input/irq */
+	if (data->det_pin) {
+		at91_set_gpio_input(data->det_pin, 1);
+		at91_set_deglitch(data->det_pin, 1);
+	}
+	if (data->wp_pin)
+		at91_set_gpio_input(data->wp_pin, 1);
+
+	/* CLK */
+	at91_set_A_periph(AT91_PIN_PA27, 0);
+
+	if (data->is_b) {
+		/* CMD */
+		at91_set_B_periph(AT91_PIN_PA8, 0);
+
+		/* DAT0, maybe DAT1..DAT3 */
+		at91_set_B_periph(AT91_PIN_PA9, 0);
+		if (data->wire4) {
+			at91_set_B_periph(AT91_PIN_PA10, 0);
+			at91_set_B_periph(AT91_PIN_PA11, 0);
+			at91_set_B_periph(AT91_PIN_PA12, 0);
+		}
+	} else {
+		/* CMD */
+		at91_set_A_periph(AT91_PIN_PA28, 0);
+
+		/* DAT0, maybe DAT1..DAT3 */
+		at91_set_A_periph(AT91_PIN_PA29, 0);
+		if (data->wire4) {
+			at91_set_B_periph(AT91_PIN_PB3, 0);
+			at91_set_B_periph(AT91_PIN_PB4, 0);
+			at91_set_B_periph(AT91_PIN_PB5, 0);
+		}
+	}
+
+	mmc_data = *data;
+	platform_device_register(&at91rm9200_mmc_device);
+}
+#else
+void __init at91_add_device_mmc(struct at91_mmc_data *data) {}
+#endif
+
+/* -------------------------------------------------------------------- */
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/generic.h linux-2.6.15/arch/arm/mach-at91rm9200/generic.h
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/generic.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/generic.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,18 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/generic.h
+ *
+ *  Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+void at91_gpio_irq_setup(unsigned banks);
+
+struct sys_timer;
+extern struct sys_timer at91rm9200_timer;
+
+extern void __init at91rm9200_map_io(void);
+
+extern int __init at91_clock_init(unsigned long main_clock);
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/gpio.c linux-2.6.15/arch/arm/mach-at91rm9200/gpio.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/gpio.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/gpio.c	Wed Jan 11 09:36:08 2006
@@ -0,0 +1,302 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/gpio.c
+ *
+ * Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+
+static const u32 pio_controller_offset[4] = {
+	AT91_PIOA,
+	AT91_PIOB,
+	AT91_PIOC,
+	AT91_PIOD,
+};
+
+static inline void __iomem *pin_to_controller(unsigned pin)
+{
+	void __iomem *sys_base = (void __iomem *) AT91_VA_BASE_SYS;
+
+	pin -= PIN_BASE;
+	pin /= 32;
+	if (likely(pin < BGA_GPIO_BANKS))
+		return sys_base + pio_controller_offset[pin];
+
+	return NULL;
+}
+
+static inline unsigned pin_to_mask(unsigned pin)
+{
+	pin -= PIN_BASE;
+	return 1 << (pin % 32);
+}
+
+
+/*--------------------------------------------------------------------------*/
+
+/* Not all hardware capabilities are exposed through these calls; they
+ * only encapsulate the most common features and modes.  (So if you
+ * want to change signals in groups, do it directly.)
+ *
+ * Bootloaders will usually handle some of the pin multiplexing setup.
+ * The intent is certainly that by the time Linux is fully booted, all
+ * pins should have been fully initialized.  These setup calls should
+ * only be used by board setup routines, or possibly in driver probe().
+ *
+ * For bootloaders doing all that setup, these calls could be inlined
+ * as NOPs so Linux won't duplicate any setup code
+ */
+
+
+/*
+ * mux the pin to the "A" internal peripheral role.
+ */
+int __init_or_module at91_set_A_periph(unsigned pin, int use_pullup)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio)
+		return -EINVAL;
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(mask, pio + PIO_ASR);
+	__raw_writel(mask, pio + PIO_PDR);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_A_periph);
+
+
+/*
+ * mux the pin to the "B" internal peripheral role.
+ */
+int __init_or_module at91_set_B_periph(unsigned pin, int use_pullup)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio)
+		return -EINVAL;
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(mask, pio + PIO_BSR);
+	__raw_writel(mask, pio + PIO_PDR);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_B_periph);
+
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral), and
+ * configure it for an input.
+ */
+int __init_or_module at91_set_gpio_input(unsigned pin, int use_pullup)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio)
+		return -EINVAL;
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(mask, pio + PIO_ODR);
+	__raw_writel(mask, pio + PIO_PER);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_input);
+
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral),
+ * and configure it for an output.
+ */
+int __init_or_module at91_set_gpio_output(unsigned pin, int value)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio)
+		return -EINVAL;
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + PIO_PUDR);
+	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+	__raw_writel(mask, pio + PIO_OER);
+	__raw_writel(mask, pio + PIO_PER);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_output);
+
+
+/*
+ * enable/disable the glitch filter; mostly used with IRQ handling.
+ */
+int __init_or_module at91_set_deglitch(unsigned pin, int is_on)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio)
+		return -EINVAL;
+	__raw_writel(mask, pio + (is_on ? PIO_IFER : PIO_IFDR));
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_deglitch);
+
+/*--------------------------------------------------------------------------*/
+
+
+/*
+ * assuming the pin is muxed as a gpio output, set its value.
+ */
+int at91_set_gpio_value(unsigned pin, int value)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio)
+		return -EINVAL;
+	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_value);
+
+
+/*
+ * read the pin's value (works even if it's not muxed as a gpio).
+ */
+int at91_get_gpio_value(unsigned pin)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+	u32		pdsr;
+
+	if (!pio)
+		return -EINVAL;
+	pdsr = __raw_readl(pio + PIO_PDSR);
+	return (pdsr & mask) != 0;
+}
+EXPORT_SYMBOL(at91_get_gpio_value);
+
+/*--------------------------------------------------------------------------*/
+
+
+/* Several AIC controller irqs are dispatched through this GPIO handler.
+ * To use any AT91_PIN_* as an externally triggered IRQ, first call
+ * at91_set_gpio_input() then maybe enable its glitch filter.
+ * Then just request_irq() with the pin ID; it works like any ARM IRQ
+ * handler, though it always triggers on rising and falling edges.
+ *
+ * Alternatively, certain pins may be used directly as IRQ0..IRQ6 after
+ * configuring them with at91_set_a_periph() or at91_set_b_periph().
+ * IRQ0..IRQ6 should be configurable, e.g. level vs edge triggering.
+ */
+
+static void gpio_irq_mask(unsigned pin)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio)
+		__raw_writel(mask, pio + PIO_IDR);
+}
+
+static void gpio_irq_unmask(unsigned pin)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio)
+		__raw_writel(mask, pio + PIO_IER);
+}
+
+static int gpio_irq_type(unsigned pin, unsigned type)
+{
+	return (type == IRQT_BOTHEDGE) ? 0 : -EINVAL;
+}
+
+static struct irqchip gpio_irqchip = {
+	.mask		= gpio_irq_mask,
+	.unmask		= gpio_irq_unmask,
+	.set_type	= gpio_irq_type,
+};
+
+static void gpio_irq_handler(unsigned irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+	unsigned	pin;
+	struct irqdesc	*gpio;
+	void __iomem	*pio;
+	u32		isr;
+
+	pio = (void __force __iomem *) desc->chipdata;
+
+	/* temporarily mask (level sensitive) parent IRQ */
+	desc->chip->ack(irq);
+	for (;;) {
+		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+		if (!isr)
+			break;
+
+		pin = (unsigned) desc->data;
+		gpio = &irq_desc[pin];
+
+		while (isr) {
+			if (isr & 1)
+				gpio->handle(pin, gpio, regs);
+			pin++;
+			gpio++;
+			isr >>= 1;
+		}
+	}
+	desc->chip->unmask(irq);
+	/* now it may re-trigger */
+}
+
+/* call this from board-specific init_irq */
+void __init at91_gpio_irq_setup(unsigned banks)
+{
+	unsigned	pioc, pin, id;
+
+	if (banks > 4)
+		banks = 4;
+	for (pioc = 0, pin = PIN_BASE, id = AT91_ID_PIOA;
+			pioc < banks;
+			pioc++, id++) {
+		void __iomem	*controller;
+		unsigned	i;
+
+		controller = (void __iomem *) AT91_VA_BASE_SYS + pio_controller_offset[pioc];
+		__raw_writel(~0, controller + PIO_IDR);
+
+		set_irq_data(id, (void *) pin);
+		set_irq_chipdata(id, (void __force *) controller);
+
+		for (i = 0; i < 32; i++, pin++) {
+			set_irq_chip(pin, &gpio_irqchip);
+			set_irq_handler(pin, do_simple_IRQ);
+			set_irq_flags(pin, IRQF_VALID);
+		}
+
+		set_irq_chained_handler(id, gpio_irq_handler);
+
+		/* enable the PIO peripheral clock */
+		at91_sys_write(AT91_PMC_PCER, 1 << id);
+	}
+	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, banks);
+}
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/ics1523.c linux-2.6.15/arch/arm/mach-at91rm9200/ics1523.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/ics1523.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/ics1523.c	Wed Jan 11 11:18:37 2006
@@ -0,0 +1,220 @@
+/*
+ * arch/arm/mach-at91rm9200/ics1523.c
+ *
+ *  Copyright (C) 2003 ATMEL Rousset
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+#include <asm/arch/ics1523.h>
+#include <asm/arch/at91rm9200_twi.h>
+#include <asm/arch/pio.h>
+
+/* TWI Errors */
+#define	AT91_TWI_ERROR	(AT91_TWI_NACK | AT91_TWI_UNRE | AT91_TWI_OVRE)
+
+
+//-----------------------------------------------------------------------------
+//
+// TWI Register access
+//
+//-----------------------------------------------------------------------------
+
+static inline unsigned long at91_twi_read(unsigned int reg)
+{
+	void __iomem *twi_base = (void __iomem *)AT91_VA_BASE_TWI;
+
+	return __raw_readl(twi_base + reg);
+}
+
+static inline void at91_twi_write(unsigned int reg, unsigned long value)
+{
+	void __iomem *twi_base = (void __iomem *)AT91_VA_BASE_TWI;
+
+	__raw_writel(value, twi_base + reg);
+}
+
+//-----------------------------------------------------------------------------
+//
+// Initialization of TWI CLOCK
+//
+//-----------------------------------------------------------------------------
+
+static void AT91F_SetTwiClock(unsigned int mck_khz)
+{
+	int sclock;
+
+	/* Here, CKDIV = 1 and CHDIV = CLDIV  ==> CLDIV = CHDIV = 1/4*((Fmclk/FTWI) -6) */
+	sclock = (10*mck_khz /ICS_TRANSFER_RATE);
+	if (sclock % 10 >= 5)
+		sclock = (sclock /10) - 5;
+	else
+		sclock = (sclock /10)- 6;
+	sclock = (sclock + (4 - sclock %4)) >> 2;	// div 4
+
+	at91_twi_write(AT91_TWI_CWGR, 0x00010000 | sclock | (sclock << 8));
+}
+
+//-----------------------------------------------------------------------------
+//
+// Read a byte with TWI Interface from the Clock Generator ICS1523
+//
+//-----------------------------------------------------------------------------
+
+static int AT91F_ICS1523_ReadByte(unsigned char reg_address, unsigned char *data_in)
+{
+	int Status, nb_trial;
+
+	at91_twi_write(AT91_TWI_MMR, AT91_TWI_MREAD | AT91_TWI_IADRSZ_1 | ((ICS_ADD << 16) & AT91_TWI_DADR));
+	at91_twi_write(AT91_TWI_IADR, reg_address);
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+	// Program temporizing period (300us)
+	udelay(300);
+
+	// Wait TXcomplete ...
+	nb_trial = 0;
+	Status = at91_twi_read(AT91_TWI_SR);
+	while (!(Status & AT91_TWI_TXCOMP) && (nb_trial < 10)) {
+		nb_trial++;
+		Status = at91_twi_read(AT91_TWI_SR);
+	}
+
+	if (Status & AT91_TWI_TXCOMP) {
+		*data_in = (unsigned char) at91_twi_read(AT91_TWI_RHR);
+		return ((int) ICS1523_ACCESS_OK);
+	}
+	return ((int) ICS1523_ACCESS_ERROR);
+}
+
+//-----------------------------------------------------------------------------
+//
+// Write a byte with TWI Interface to the Clock Generator ICS1523
+//
+//-----------------------------------------------------------------------------
+
+static int AT91F_ICS1523_WriteByte(unsigned char reg_address, unsigned char data_out)
+{
+   	int Status, nb_trial;
+
+	at91_twi_write(AT91_TWI_MMR, AT91_TWI_IADRSZ_1 | ((ICS_ADD << 16) & AT91_TWI_DADR));
+	at91_twi_write(AT91_TWI_IADR, reg_address);
+	at91_twi_write(AT91_TWI_THR, data_out);
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+	// Program temporizing period (300us)
+	udelay(300);
+	
+	nb_trial = 0;
+	Status = at91_twi_read(AT91_TWI_SR);
+	while (!(Status & AT91_TWI_TXCOMP) && (nb_trial < 10)) {
+		nb_trial++;
+		if (Status & AT91_TWI_ERROR) {
+			// Si Under run OR NACK Start again
+			at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+			//  Program temporizing period (300us)
+			udelay(300);
+		}
+		Status = at91_twi_read(AT91_TWI_SR);
+	};
+
+	if (Status & AT91_TWI_TXCOMP)
+		return ((int) ICS1523_ACCESS_OK);
+	else
+		return ((int) ICS1523_ACCESS_ERROR);
+}
+
+//-----------------------------------------------------------------------------
+//
+// Initialization of the Clock Generator ICS1523
+//
+//-----------------------------------------------------------------------------
+
+int AT91F_ICS1523_clockinit(void)
+{
+	int		ack,nb_trial,error_status;
+	unsigned int	status = 0xffffffff;
+
+	error_status = (int) ICS1523_ACCESS_OK;
+
+	// Configure TWI PIOs
+	AT91_CfgPIO_TWI();
+
+	// Configure PMC by enabling TWI clock
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_TWI);
+
+	// Disable interrupts
+	at91_twi_write(AT91_TWI_IDR, -1);
+
+	// Reset peripheral
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_SWRST);
+
+	// Set Master mode
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_MSEN);
+
+	// Set TWI Clock Waveform Generator Register
+	AT91F_SetTwiClock(60000);     // MCK in KHz = 60000 KHz
+
+	// ICS1523 Initialisation
+	ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_ICR, (unsigned char) 0);
+	error_status |= ack;
+	ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_OE, (unsigned char) (ICS_OEF | ICS_OET2 | ICS_OETCK));
+	error_status |= ack;
+	ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_OD, (unsigned char) (ICS_INSEL | 0x7F));
+	error_status |= ack;
+	ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_DPAO, (unsigned char) 0);
+	error_status |= ack;
+
+	nb_trial = 0;
+	do {
+		nb_trial++;
+		ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_ICR, (unsigned char) (ICS_ENDLS | ICS_ENPLS | ICS_PDEN /*| ICS_FUNCSEL*/));
+		error_status |= ack;
+		ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_LCR, (unsigned char) (ICS_PSD | ICS_PFD));
+		error_status |= ack;
+		ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_FD0, (unsigned char) 0x39) ; /* 0x7A */
+		error_status |= ack;
+		ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_FD1, (unsigned char) 0x00);
+		error_status |= ack;
+		ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_SWRST, (unsigned char) (ICS_PLLR));
+		error_status |= ack;
+
+		// Program 1ms temporizing period
+		mdelay(1);
+
+		AT91F_ICS1523_ReadByte ((unsigned char) ICS_SR, (char *)&status);
+	} while (!((unsigned int) status & (unsigned int) ICS_PLLLOCK) && (nb_trial < 10));
+
+	ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_DPAC, (unsigned char) 0x03) ; /* 0x01 */
+	error_status |= ack;
+	ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_SWRST, (unsigned char) (ICS_DPAR));
+	error_status |= ack;
+
+	/* Program 1ms temporizing period */
+	mdelay(1);
+
+	ack = AT91F_ICS1523_WriteByte ((unsigned char) ICS_DPAO, (unsigned char) 0x00);
+	error_status |= ack;
+
+	/* Program 1ms temporizing period */
+	mdelay(1);
+
+	return (error_status);
+}
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/irq.c linux-2.6.15/arch/arm/mach-at91rm9200/irq.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/irq.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/irq.c	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,170 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/irq.c
+ *
+ *  Copyright (C) 2004 SAN People
+ *  Copyright (C) 2004 ATMEL
+ *  Copyright (C) Rick Bronson
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/types.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/setup.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+#include "generic.h"
+
+/*
+ * The default interrupt priority levels (0 = lowest, 7 = highest).
+ */
+static unsigned int at91rm9200_default_irq_priority[NR_AIC_IRQS] __initdata = {
+	7,	/* Advanced Interrupt Controller */
+	7,	/* System Peripheral */
+	0,	/* Parallel IO Controller A */
+	0,	/* Parallel IO Controller B */
+	0,	/* Parallel IO Controller C */
+	0,	/* Parallel IO Controller D */
+	6,	/* USART 0 */
+	6,	/* USART 1 */
+	6,	/* USART 2 */
+	6,	/* USART 3 */
+	0,	/* Multimedia Card Interface */
+	4,	/* USB Device Port */
+	0,	/* Two-Wire Interface */
+	6,	/* Serial Peripheral Interface */
+	5,	/* Serial Synchronous Controller */
+	5,	/* Serial Synchronous Controller */
+	5,	/* Serial Synchronous Controller */
+	0,	/* Timer Counter 0 */
+	0,	/* Timer Counter 1 */
+	0,	/* Timer Counter 2 */
+	0,	/* Timer Counter 3 */
+	0,	/* Timer Counter 4 */
+	0,	/* Timer Counter 5 */
+	3,	/* USB Host port */
+	3,	/* Ethernet MAC */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0	/* Advanced Interrupt Controller */
+};
+
+
+static void at91rm9200_mask_irq(unsigned int irq)
+{
+	/* Disable interrupt on AIC */
+	at91_sys_write(AT91_AIC_IDCR, 1 << irq);
+}
+
+static void at91rm9200_unmask_irq(unsigned int irq)
+{
+	/* Enable interrupt on AIC */
+	at91_sys_write(AT91_AIC_IECR, 1 << irq);
+}
+
+static int at91rm9200_irq_type(unsigned irq, unsigned type)
+{
+	unsigned int smr, srctype;
+
+	/* change triggering only for FIQ and external IRQ0..IRQ6 */
+	if ((irq < AT91_ID_IRQ0) && (irq != AT91_ID_FIQ))
+		return -EINVAL;
+
+	switch (type) {
+	case IRQT_HIGH:
+		srctype = AT91_AIC_SRCTYPE_HIGH;
+		break;
+	case IRQT_RISING:
+		srctype = AT91_AIC_SRCTYPE_RISING;
+		break;
+	case IRQT_LOW:
+		srctype = AT91_AIC_SRCTYPE_LOW;
+		break;
+	case IRQT_FALLING:
+		srctype = AT91_AIC_SRCTYPE_FALLING;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	smr = at91_sys_read(AT91_AIC_SMR(irq)) & ~AT91_AIC_SRCTYPE;
+	at91_sys_write(AT91_AIC_SMR(irq), smr | srctype);
+	return 0;
+}
+
+static struct irqchip at91rm9200_irq_chip = {
+	.ack		= at91rm9200_mask_irq,
+	.mask		= at91rm9200_mask_irq,
+	.unmask		= at91rm9200_unmask_irq,
+	.set_type	= at91rm9200_irq_type,
+};
+
+/*
+ * Initialize the AIC interrupt controller.
+ */
+void __init at91rm9200_init_irq(unsigned int priority[NR_AIC_IRQS])
+{
+	unsigned int i;
+
+	/* No priority list specified for this board -> use defaults */
+	if (priority == NULL)
+		priority = at91rm9200_default_irq_priority;
+
+	/*
+	 * The IVR is used by macro get_irqnr_and_base to read and verify.
+	 * The irq number is NR_AIC_IRQS when a spurious interrupt has occurred.
+	 */
+	for (i = 0; i < NR_AIC_IRQS; i++) {
+		/* Put irq number in Source Vector Register: */
+		at91_sys_write(AT91_AIC_SVR(i), i);
+		/* Store the Source Mode Register as defined in table above */
+		at91_sys_write(AT91_AIC_SMR(i), AT91_AIC_SRCTYPE_LOW | priority[i]);
+
+		set_irq_chip(i, &at91rm9200_irq_chip);
+		set_irq_handler(i, do_level_IRQ);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+
+		/* Perform 8 End Of Interrupt Command to make sure AIC will not Lock out nIRQ */
+		if (i < 8)
+			at91_sys_write(AT91_AIC_EOICR, 0);
+	}
+
+	/*
+	 * Spurious Interrupt ID in Spurious Vector Register is NR_AIC_IRQS
+	 * When there is no current interrupt, the IRQ Vector Register reads the value stored in AIC_SPU
+	 */
+	at91_sys_write(AT91_AIC_SPU, NR_AIC_IRQS);
+
+	/* No debugging in AIC: Debug (Protect) Control Register */
+	at91_sys_write(AT91_AIC_DCR, 0);
+
+	/* Disable and clear all interrupts initially */
+	at91_sys_write(AT91_AIC_IDCR, 0xFFFFFFFF);
+	at91_sys_write(AT91_AIC_ICCR, 0xFFFFFFFF);
+}
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/leds.c linux-2.6.15/arch/arm/mach-at91rm9200/leds.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/leds.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/leds.c	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,111 @@
+/*
+ * LED driver for the Atmel AT91RM9200-based boards.
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/mach-types.h>
+#include <asm/leds.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+
+#if defined(CONFIG_MACH_AT91RM9200EK)
+#define AT91_LEDS_CPU		AT91_PIN_PB1
+#define AT91_LEDS_TIMER		AT91_PIN_PB2
+
+#elif defined(CONFIG_MACH_KB9200)
+#define AT91_LEDS_CPU		AT91_PIN_PC19
+#define AT91_LEDS_TIMER		AT91_PIN_PC18
+
+#else
+#define AT91_LEDS_CPU		AT91_PIN_PB2
+#define AT91_LEDS_TIMER		AT91_PIN_PB2
+#endif
+
+#warning "Should not be statically defined"
+
+static inline void at91_led_on(unsigned int led)
+{
+	at91_set_gpio_value(led, 0);
+}
+
+static inline void at91_led_off(unsigned int led)
+{
+	at91_set_gpio_value(led, 1);
+}
+
+static inline void at91_led_toggle(unsigned int led)
+{
+	unsigned long is_off = at91_get_gpio_value(led);
+	if (is_off)
+		at91_led_on(led);
+	else
+		at91_led_off(led);
+}
+
+
+/*
+ * Handle LED events.
+ */
+static void at91rm9200_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch(evt) {
+	case led_start:		/* System startup */
+		at91_led_on(AT91_LEDS_CPU);
+		break;
+
+	case led_stop:		/* System stop / suspend */
+		at91_led_off(AT91_LEDS_CPU);
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:		/* Every 50 timer ticks */
+		at91_led_toggle(AT91_LEDS_TIMER);
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:	/* Entering idle state */
+		at91_led_off(AT91_LEDS_CPU);
+		break;
+
+	case led_idle_end:	/* Exit idle state */
+		at91_led_on(AT91_LEDS_CPU);
+		break;
+#endif
+
+	default:
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
+
+static int __init leds_init(void)
+{
+	/* Enable PIO to access the LEDs */
+	at91_set_gpio_output(AT91_LEDS_CPU, 1);
+	at91_set_gpio_output(AT91_LEDS_TIMER, 1);
+
+	leds_event = at91rm9200_leds_event;
+
+	leds_event(led_start);
+	return 0;
+}
+
+__initcall(leds_init);
diff -urN linux-2.6.15.orig/arch/arm/mach-at91rm9200/time.c linux-2.6.15/arch/arm/mach-at91rm9200/time.c
--- linux-2.6.15.orig/arch/arm/mach-at91rm9200/time.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/arch/arm/mach-at91rm9200/time.c	Wed Jan 11 16:43:15 2006
@@ -0,0 +1,127 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/time.c
+ *
+ *  Copyright (C) 2003 SAN People
+ *  Copyright (C) 2003 ATMEL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+
+/*
+ * The ST_CRTR is updated asynchronously to the master clock.  It is therefore
+ *  necessary to read it twice (with the same value) to ensure accuracy.
+ */
+static inline unsigned long read_CRTR(void) {
+	unsigned long x1, x2;
+
+	do {
+		x1 = at91_sys_read(AT91_ST_CRTR);
+		x2 = at91_sys_read(AT91_ST_CRTR);
+	} while (x1 != x2);
+
+	return x1;
+}
+
+/*
+ * Returns number of microseconds since last timer interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeofday()
+ *  'LATCH' is hwclock ticks (see CLOCK_TICK_RATE in timex.h) per jiffy.
+ *  'tick' is usecs per jiffy (linux/timex.h).
+ */
+static unsigned long at91rm9200_gettimeoffset(void)
+{
+	unsigned long elapsed;
+
+	elapsed = (read_CRTR() - at91_sys_read(AT91_ST_RTAR)) & AT91_ST_ALMV;
+
+	return (unsigned long)(elapsed * (tick_nsec / 1000)) / LATCH;
+}
+
+/*
+ * IRQ handler for the timer.
+ */
+static irqreturn_t at91rm9200_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long rtar;
+
+	if (at91_sys_read(AT91_ST_SR) & AT91_ST_PITS) {	/* This is a shared interrupt */
+		write_seqlock(&xtime_lock);
+
+		while (((read_CRTR() - at91_sys_read(AT91_ST_RTAR)) & AT91_ST_ALMV) >= LATCH) {
+			timer_tick(regs);
+			rtar = (at91_sys_read(AT91_ST_RTAR) + LATCH) & AT91_ST_ALMV;
+			at91_sys_write(AT91_ST_RTAR, rtar);
+		}
+
+		write_sequnlock(&xtime_lock);
+
+		return IRQ_HANDLED;
+	}
+	else
+		return IRQ_NONE;		/* not handled */
+}
+
+static struct irqaction at91rm9200_timer_irq = {
+	.name		= "at91_tick",
+	.flags		= SA_SHIRQ | SA_INTERRUPT,
+	.handler	= at91rm9200_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt.
+ */
+void __init at91rm9200_timer_init(void)
+{
+	/* Disable all timer interrupts */
+	at91_sys_write(AT91_ST_IDR, AT91_ST_PITS | AT91_ST_WDOVF | AT91_ST_RTTINC | AT91_ST_ALMS);
+	(void) at91_sys_read(AT91_ST_SR);	/* Clear any pending interrupts */
+
+	/*
+	 * Make IRQs happen for the system timer.
+	 */
+	setup_irq(AT91_ID_SYS, &at91rm9200_timer_irq);
+
+	/* Set initial alarm to 0 */
+	at91_sys_write(AT91_ST_RTAR, 0);
+
+	/* Real time counter incremented every 30.51758 microseconds */
+	at91_sys_write(AT91_ST_RTMR, 1);
+
+	/* Set Period Interval timer */
+	at91_sys_write(AT91_ST_PIMR, LATCH);
+
+	/* Change the kernel's 'tick' value to 10009 usec. (the default is 10000) */
+	tick_usec = (LATCH * 1000000) / CLOCK_TICK_RATE;
+
+	/* Enable Period Interval Timer interrupt */
+	at91_sys_write(AT91_ST_IER, AT91_ST_PITS);
+}
+
+struct sys_timer at91rm9200_timer = {
+	.init		= at91rm9200_timer_init,
+	.offset		= at91rm9200_gettimeoffset,
+};
diff -urN linux-2.6.15.orig/arch/arm/mm/Kconfig linux-2.6.15/arch/arm/mm/Kconfig
--- linux-2.6.15.orig/arch/arm/mm/Kconfig	Wed Jan 11 09:18:36 2006
+++ linux-2.6.15/arch/arm/mm/Kconfig	Wed Jan 11 09:23:12 2006
@@ -62,8 +62,8 @@
 # ARM920T
 config CPU_ARM920T
 	bool "Support ARM920T processor" if !ARCH_S3C2410
-	depends on ARCH_INTEGRATOR || ARCH_S3C2410 || ARCH_IMX || ARCH_AAEC2000
-	default y if ARCH_S3C2410
+	depends on ARCH_INTEGRATOR || ARCH_S3C2410 || ARCH_IMX || ARCH_AAEC2000 || ARCH_AT91RM9200
+	default y if ARCH_S3C2410 || ARCH_AT91RM9200
 	select CPU_32v4
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_V4WT
diff -urN linux-2.6.15.orig/arch/arm/tools/mach-types linux-2.6.15/arch/arm/tools/mach-types
--- linux-2.6.15.orig/arch/arm/tools/mach-types	Wed Jan 11 09:18:36 2006
+++ linux-2.6.15/arch/arm/tools/mach-types	Wed Jan 11 10:05:35 2006
@@ -910,3 +910,4 @@
 nadia2vb		MACH_NADIA2VB		NADIA2VB		897
 r1000			MACH_R1000		R1000			898
 hw90250			MACH_HW90250		HW90250			899
+ateb9200		MACH_ATEB9200		ATEB9200		923
diff -urN linux-2.6.15.orig/drivers/char/Kconfig linux-2.6.15/drivers/char/Kconfig
--- linux-2.6.15.orig/drivers/char/Kconfig	Wed Jan 11 09:18:53 2006
+++ linux-2.6.15/drivers/char/Kconfig	Wed Jan 11 11:16:50 2006
@@ -783,6 +783,12 @@
 	tristate "NEC VR4100 series Real Time Clock Support"
 	depends on CPU_VR41XX
 
+config AT91_RTC
+	tristate "AT91RM9200 RTC Driver"
+	depends on ARCH_AT91RM9200
+	help
+	  Driver for the Atmel AT91RM9200's internal RTC (Realtime Clock).
+
 config COBALT_LCD
 	bool "Support for Cobalt LCD"
 	depends on MIPS_COBALT
@@ -1013,5 +1019,21 @@
 	  sysfs directory, /sys/devices/platform/telco_clock, with a number of
 	  files for controlling the behavior of this hardware.
 
+config AT91_SPI
+	bool "SPI driver for AT91 processors"
+	depends on ARCH_AT91RM9200
+	default y
+	help
+	  The SPI driver gives access to this serial bus on the AT91x 
+	  processor
+
+config AT91_SPIDEV
+	bool "SPI device interface for AT91 processors"
+	depends on ARCH_AT91RM9200 && AT91_SPI
+	default n
+	help
+	  The SPI driver gives user mode access to this serial 
+	  bus on the AT91x processor
+
 endmenu
 
diff -urN linux-2.6.15.orig/drivers/char/Makefile linux-2.6.15/drivers/char/Makefile
--- linux-2.6.15.orig/drivers/char/Makefile	Wed Jan 11 09:18:53 2006
+++ linux-2.6.15/drivers/char/Makefile	Wed Jan 11 11:16:07 2006
@@ -65,6 +65,7 @@
 obj-$(CONFIG_DS1302) += ds1302.o
 obj-$(CONFIG_S3C2410_RTC) += s3c2410-rtc.o
 obj-$(CONFIG_RTC_VR41XX) += vr41xx_rtc.o
+obj-$(CONFIG_AT91_RTC) += at91_rtc.o
 ifeq ($(CONFIG_GENERIC_NVRAM),y)
   obj-$(CONFIG_NVRAM) += generic_nvram.o
 else
@@ -83,6 +84,8 @@
 obj-$(CONFIG_GPIO_VR41XX) += vr41xx_giu.o
 obj-$(CONFIG_TANBAC_TB0219) += tb0219.o
 obj-$(CONFIG_TELCLOCK) += tlclk.o
+obj-$(CONFIG_AT91_SPI) += at91_spi.o
+obj-$(CONFIG_AT91_SPIDEV) += at91_spidev.o
 
 obj-$(CONFIG_WATCHDOG)	+= watchdog/
 obj-$(CONFIG_MWAVE) += mwave/
diff -urN linux-2.6.15.orig/drivers/char/at91_rtc.c linux-2.6.15/drivers/char/at91_rtc.c
--- linux-2.6.15.orig/drivers/char/at91_rtc.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/char/at91_rtc.c	Wed Jan 11 11:26:00 2006
@@ -0,0 +1,474 @@
+/*
+ *	Real Time Clock interface for Linux on Atmel AT91RM9200
+ *
+ *	Copyright (C) 2002 Rick Bronson
+ *
+ *	Ported to Linux 2.6 by Steven Scholz
+ *	Based on s3c2410-rtc.c Simtec Electronics
+ *
+ *      Based on sa1100-rtc.c by Nils Faerber
+ *	Based on rtc.c by Paul Gortmaker
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/time.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/interrupt.h>
+#include <linux/ioctl.h>
+
+#include <asm/uaccess.h>
+#include <asm/rtc.h>
+
+#include <asm/mach/time.h>
+
+
+#define DRIVER_NAME "at91_rtc"
+
+#define AT91_RTC_FREQ		1
+#define rtc_epoch		1900UL	/* just like arch/arm/common/rtctime.c */
+
+/* Those are the bits from a classic RTC we want to mimic (see linux/mc146818rtc.h) */
+#define AT91_RTC_IRQF		0x80	/* any of the following 3 is active */
+#define AT91_RTC_PF		0x40
+#define AT91_RTC_AF		0x20
+#define AT91_RTC_UF		0x10
+
+static DECLARE_WAIT_QUEUE_HEAD(at91_rtc_update);
+
+static spinlock_t at91_rtc_updlock;	/* some spinlocks for saving/restoring interrupt levels */
+extern spinlock_t at91_rtc_lock;
+
+static unsigned long rtc_status = 0;
+static unsigned long rtc_irq_data;
+
+static unsigned int at91_alarm_year = rtc_epoch;
+
+/*
+ * A few helper functions ...
+ */
+
+static const unsigned char days_in_mo[] =
+    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+#define is_leap(year) \
+	((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+
+static const unsigned short int __mon_yday[2][13] =
+{
+	/* Normal years. */
+	{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+	/* Leap years. */
+	{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
+
+/*
+ * Returns day since start of the year [0-365]
+ *  (from drivers/char/efirtc.c)
+ */
+static inline int compute_yday(int year, int month, int day)
+{
+	return __mon_yday[is_leap(year)][month] + day-1;
+}
+
+/*
+ * Decode time/date into rtc_time structure
+ */
+static void at91_rtc_decodetime(unsigned int timereg, unsigned int calreg, struct rtc_time *tm)
+{
+	unsigned int time, date;
+
+	/* must read twice in case it changes */
+	do {
+		time = at91_sys_read(timereg);
+		date = at91_sys_read(calreg);
+	} while ((time != at91_sys_read(timereg)) || (date != at91_sys_read(calreg)));
+
+	tm->tm_sec  = BCD2BIN((time & AT91_RTC_SEC) >> 0);
+	tm->tm_min  = BCD2BIN((time & AT91_RTC_MIN) >> 8);
+	tm->tm_hour = BCD2BIN((time & AT91_RTC_HOUR) >> 16);
+
+	/* The Calendar Alarm register does not have a field for
+	   the year - so these will return an invalid value.  When an
+	   alarm is set, at91_alarm_year wille store the current year. */
+
+	tm->tm_year  = BCD2BIN(date & AT91_RTC_CENT) * 100;		/* century */
+	tm->tm_year += BCD2BIN((date & AT91_RTC_YEAR) >> 8);		/* year */
+
+	tm->tm_wday = BCD2BIN((date & AT91_RTC_DAY) >> 21) - 1;	/* day of the week [0-6], Sunday=0 */
+	tm->tm_mon  = BCD2BIN((date & AT91_RTC_MONTH) >> 16) - 1;
+	tm->tm_mday = BCD2BIN((date & AT91_RTC_DATE) >> 24);
+}
+
+/*
+ * Read current time and date in RTC
+ */
+static int at91_rtc_readtime(struct rtc_time *tm)
+{
+	at91_rtc_decodetime(AT91_RTC_TIMR, AT91_RTC_CALR, tm);
+	tm->tm_yday = compute_yday(tm->tm_year, tm->tm_mon, tm->tm_mday);
+	tm->tm_year = tm->tm_year - 1900;
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	return 0;
+}
+
+/*
+ * Set current time and date in RTC
+ */
+static int at91_rtc_settime(struct rtc_time *tm)
+{
+	unsigned long cr, flags;
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	/* Stop Time/Calendar from counting */
+	cr = at91_sys_read(AT91_RTC_CR);
+	at91_sys_write(AT91_RTC_CR, cr | AT91_RTC_UPDCAL | AT91_RTC_UPDTIM);
+
+	spin_lock_irqsave(&at91_rtc_updlock, flags);	/* stop int's else we wakeup b4 we sleep */
+
+	at91_sys_write(AT91_RTC_IER, AT91_RTC_ACKUPD);
+	interruptible_sleep_on(&at91_rtc_update);	/* wait for ACKUPD interrupt to hit */
+	spin_unlock_irqrestore(&at91_rtc_updlock, flags);
+	at91_sys_write(AT91_RTC_IDR, AT91_RTC_ACKUPD);
+
+	at91_sys_write(AT91_RTC_TIMR,
+			  BIN2BCD(tm->tm_sec) << 0
+			| BIN2BCD(tm->tm_min) << 8
+			| BIN2BCD(tm->tm_hour) << 16);
+
+	at91_sys_write(AT91_RTC_CALR,
+			  BIN2BCD((tm->tm_year + 1900) / 100)		/* century */
+			| BIN2BCD(tm->tm_year % 100) << 8		/* year */
+			| BIN2BCD(tm->tm_mon + 1) << 16			/* tm_mon starts at zero */
+			| BIN2BCD(tm->tm_wday + 1) << 21		/* day of the week [0-6], Sunday=0 */
+			| BIN2BCD(tm->tm_mday) << 24);
+
+	/* Restart Time/Calendar */
+	cr = at91_sys_read(AT91_RTC_CR);
+	at91_sys_write(AT91_RTC_CR, cr & ~(AT91_RTC_UPDCAL | AT91_RTC_UPDTIM));
+
+	return 0;
+}
+
+/*
+ * Read alarm time and date in RTC
+ */
+static int at91_rtc_readalarm(struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *tm = &alrm->time;
+
+	at91_rtc_decodetime(AT91_RTC_TIMALR, AT91_RTC_CALALR, tm);
+	tm->tm_yday = compute_yday(tm->tm_year, tm->tm_mon, tm->tm_mday);
+	tm->tm_year = at91_alarm_year - 1900;
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
+	
+	return 0;
+}
+
+/*
+ * Set alarm time and date in RTC
+ */
+static int at91_rtc_setalarm(struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *tm2 = &alrm->time;
+	struct rtc_time tm;
+
+	at91_rtc_decodetime(AT91_RTC_TIMR, AT91_RTC_CALR, &tm);
+
+	at91_alarm_year = tm.tm_year;
+
+	if ((unsigned) tm2->tm_hour < 24)	/* do some range checking */
+		tm.tm_hour = tm2->tm_hour;
+	if ((unsigned) tm2->tm_min < 60)
+		tm.tm_min = tm2->tm_min;
+	if ((unsigned) tm2->tm_sec < 60)
+		tm.tm_sec = tm2->tm_sec;
+
+	at91_sys_write(AT91_RTC_TIMALR,
+		  BIN2BCD(tm.tm_sec) << 0
+		| BIN2BCD(tm.tm_min) << 8
+		| BIN2BCD(tm.tm_hour) << 16
+		| AT91_RTC_HOUREN | AT91_RTC_MINEN | AT91_RTC_SECEN);
+	at91_sys_write(AT91_RTC_CALALR,
+		  BIN2BCD(tm.tm_mon + 1) << 16		/* tm_mon starts at zero */
+		| BIN2BCD(tm.tm_mday) << 24
+		| AT91_RTC_DATEEN | AT91_RTC_MTHEN);
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		at91_alarm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+
+	return 0;
+}
+
+/*
+ * Handle commands from user-space
+ */
+static int at91_rtc_ioctl(unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	pr_debug("%s(): cmd=%08x, arg=%08lx.\n", __FUNCTION__, cmd, arg);
+
+	spin_lock_irq(&at91_rtc_lock);
+	switch (cmd) {
+	case RTC_AIE_OFF:	/* alarm off */
+		at91_sys_write(AT91_RTC_IDR, AT91_RTC_ALARM);
+		rtc_irq_data = 0;
+		break;
+	case RTC_AIE_ON:	/* alarm on */
+		at91_sys_write(AT91_RTC_IER, AT91_RTC_ALARM);
+		rtc_irq_data = 0;
+		break;
+	case RTC_UIE_OFF:	/* update off */
+	case RTC_PIE_OFF:	/* periodic off */
+		at91_sys_write(AT91_RTC_IDR, AT91_RTC_SECEV);
+		rtc_irq_data = 0;
+		break;
+	case RTC_UIE_ON:	/* update on */
+	case RTC_PIE_ON:	/* periodic on */
+		at91_sys_write(AT91_RTC_IER, AT91_RTC_SECEV);
+		rtc_irq_data = 0;
+		break;
+	case RTC_IRQP_READ:	/* read periodic alarm frequency */
+		ret = put_user(AT91_RTC_FREQ, (unsigned long *) arg);
+		break;
+	case RTC_IRQP_SET:	/* set periodic alarm frequency */
+		if (arg != AT91_RTC_FREQ) {
+			ret = -EINVAL;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	spin_unlock_irq(&at91_rtc_lock);
+
+	return ret;
+}
+
+/*
+ * Provide additional RTC information in /proc/driver/rtc
+ */
+static int at91_rtc_read_proc(char *buf)
+{
+	unsigned long imr;
+	char *p = buf;
+
+	imr = at91_sys_read(AT91_RTC_IMR);
+	p += sprintf(p, "alarm_IRQ\t: %s\n", (imr & AT91_RTC_ALARM) ? "yes" : "no");
+	p += sprintf(p, "update_IRQ\t: %s\n", (imr & AT91_RTC_ACKUPD) ? "yes" : "no");
+	p += sprintf(p, "periodic_IRQ\t: %s\n", (imr & AT91_RTC_SECEV) ? "yes" : "no");
+	p += sprintf(p, "periodic_freq\t: %ld\n", (unsigned long) AT91_RTC_FREQ);
+
+	return p - buf;
+}
+
+/*
+ * IRQ handler for the RTC
+ */
+static irqreturn_t at91_rtc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int rtsr = at91_sys_read(AT91_RTC_SR) & at91_sys_read(AT91_RTC_IMR);
+
+	/* update irq data & counter */
+	if (rtsr) {		/* this interrupt is shared!  Is it ours? */
+		if (rtsr & AT91_RTC_ALARM)
+			rtc_irq_data |= (AT91_RTC_AF | AT91_RTC_IRQF);
+		if (rtsr & AT91_RTC_SECEV)
+			rtc_irq_data |= (AT91_RTC_UF | AT91_RTC_IRQF);
+		if (rtsr & AT91_RTC_ACKUPD)
+			wake_up_interruptible(&at91_rtc_update);
+
+		at91_sys_write(AT91_RTC_SCCR, rtsr);		/* clear status reg */
+
+#if 0
+		rtc_irq_data += 0x100;			/* counter */
+		rtc_update(rtc_irq_data >> 8, rtc_irq_data & 0x000000FF);
+#else
+		/* I guess this would be better. Steven */
+		rtc_update(1, rtc_irq_data & 0x000000FF);
+#endif
+
+		pr_debug("%s(): num=%ld, events=0x%02lx\n", __FUNCTION__,
+			rtc_irq_data >> 8, rtc_irq_data & 0x000000FF);
+
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;		/* not handled */
+}
+
+static struct rtc_ops rtc_ops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= at91_rtc_ioctl,
+	.read_time	= at91_rtc_readtime,
+	.set_time	= at91_rtc_settime,
+	.read_alarm	= at91_rtc_readalarm,
+	.set_alarm	= at91_rtc_setalarm,
+	.proc		= at91_rtc_read_proc,
+};
+
+/*
+ * Initialize and install RTC driver
+ */
+static int at91_rtc_probe(struct device *dev)
+{
+	int ret;
+
+	pr_debug("%s()\n", __FUNCTION__);
+
+	at91_sys_write(AT91_RTC_CR, 0);
+	at91_sys_write(AT91_RTC_MR, 0);		/* put in 24 hour format */
+
+	/* Disable all interrupts */
+	at91_sys_write(AT91_RTC_IDR, AT91_RTC_ACKUPD | AT91_RTC_ALARM | AT91_RTC_SECEV | AT91_RTC_TIMEV | AT91_RTC_CALEV);
+
+	spin_lock_init(&at91_rtc_updlock);
+	spin_lock_init(&at91_rtc_lock);
+
+	ret = request_irq(AT91_ID_SYS, at91_rtc_interrupt, SA_SHIRQ, "at91_rtc", &rtc_status);
+	if (ret) {
+		printk(KERN_ERR "at91_rtc: IRQ %d already in use.\n", AT91_ID_SYS);
+		return ret;
+	}
+
+	ret = register_rtc(&rtc_ops);
+	if (ret) {
+		printk(KERN_ERR "at91_rtc: could not register RTC.\n");
+		free_irq(AT91_ID_SYS, &rtc_status);
+		return ret;
+	}
+
+	printk(KERN_INFO "AT91 Real Time Clock driver.\n");
+
+	return 0;
+}
+
+/*
+ * Disable and remove the RTC driver
+ */
+static int at91_rtc_remove(struct device *dev)
+{
+	pr_debug("%s()\n", __FUNCTION__);
+
+	/* Disable all interrupts */
+	at91_sys_write(AT91_RTC_IDR, AT91_RTC_ACKUPD | AT91_RTC_ALARM | AT91_RTC_SECEV | AT91_RTC_TIMEV | AT91_RTC_CALEV);
+	free_irq(AT91_ID_SYS, &rtc_status);
+
+	rtc_status = 0;
+
+	unregister_rtc(&rtc_ops);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+/* AT91RM9200 RTC Power management control */
+
+static struct timespec at91_rtc_delta;
+
+static int at91_rtc_suspend(struct device *dev, u32 state, u32 level)
+{
+	struct rtc_time tm;
+	struct timespec time;
+
+	/*pr_debug("%s(): level=%08x\n", __FUNCTION__, level);*/
+
+	time.tv_nsec = 0;
+
+	if (level == SUSPEND_SAVE_STATE) {
+		/* calculate time delta for suspend */
+		at91_rtc_readtime(&tm);
+		rtc_tm_to_time(&tm, &time.tv_sec);
+		save_time_delta(&at91_rtc_delta, &time);
+		pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+			1900 + tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	}
+
+	return 0;
+}
+
+static int at91_rtc_resume(struct device *dev, u32 level)
+{
+	struct rtc_time tm;
+	struct timespec time;
+
+	time.tv_nsec = 0;
+
+	if (level == RESUME_RESTORE_STATE) {
+		at91_rtc_readtime(&tm);
+		rtc_tm_to_time(&tm, &time.tv_sec);
+		restore_time_delta(&at91_rtc_delta, &time);
+		pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+			1900 + tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	}
+	return 0;
+}
+#else
+#define at91_rtc_suspend NULL
+#define at91_rtc_resume  NULL
+#endif
+
+static struct platform_device at91_rtc_device = {
+	.name		= DRIVER_NAME,
+	.id		= -1,
+};
+
+static struct device_driver at91_rtc_driver = {
+	.name		= DRIVER_NAME,
+	.bus		= &platform_bus_type,
+	.probe		= at91_rtc_probe,
+	.remove		= at91_rtc_remove,
+	.suspend	= at91_rtc_suspend,
+	.resume		= at91_rtc_resume,
+};
+
+static int __init at91_rtc_init(void)
+{
+	int result;
+
+	result = driver_register(&at91_rtc_driver);
+	if (result < 0) {
+		printk(KERN_ERR "AT91 RTC: Failed to register driver\n");
+		return result;
+	}
+
+	result = platform_device_register(&at91_rtc_device);
+	if (result < 0) {
+		printk(KERN_ERR "AT91 RTC: Failed to register device\n");
+		return result;
+	}
+
+	return result;
+}
+
+static void __exit at91_rtc_exit(void)
+{
+	platform_device_unregister(&at91_rtc_device);
+	driver_unregister(&at91_rtc_driver);
+
+	printk(KERN_INFO "AT91RM9200 RTC removed\n");
+}
+
+
+module_init(at91_rtc_init);
+module_exit(at91_rtc_exit);
+
+MODULE_AUTHOR("Rick Bronson");
+MODULE_DESCRIPTION("RTC driver for Atmel AT91RM9200");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.15.orig/drivers/char/at91_spi.c linux-2.6.15/drivers/char/at91_spi.c
--- linux-2.6.15.orig/drivers/char/at91_spi.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/char/at91_spi.c	Wed Jan 11 10:21:37 2006
@@ -0,0 +1,306 @@
+/*
+ * Serial Peripheral Interface (SPI) driver for the Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include <asm/arch/at91rm9200_spi.h>
+#include <asm/arch/at91rm9200_pdc.h>
+#include <asm/arch/board.h>
+#include <asm/arch/pio.h>
+#include <asm/arch/at91_spi.h>
+
+#undef DEBUG_SPI
+
+static struct spi_local spi_dev[NR_SPI_DEVICES];	/* state of the SPI devices */
+static int spi_enabled = 0;
+static struct semaphore spi_lock;			/* protect access to SPI bus */
+static int current_device = -1;				/* currently selected SPI device */
+
+DECLARE_COMPLETION(transfer_complete);
+
+
+/* ......................................................................... */
+
+/*
+ * Read from a SPI register.
+ */
+static inline unsigned long at91_spi_read(unsigned int reg)
+{
+	void __iomem *spi_base = (void __iomem *)AT91_VA_BASE_SPI;
+	
+	return __raw_readl(spi_base + reg);
+}
+
+/*
+ * Write to a SPI register.
+ */
+static inline void at91_spi_write(unsigned int reg, unsigned long value)
+{
+	void __iomem *spi_base = (void __iomem *)AT91_VA_BASE_SPI;
+	
+	__raw_writel(value, spi_base + reg);
+}
+
+/* ......................................................................... */
+
+/*
+ * Access and enable the SPI bus.
+ * This MUST be called before any transfers are performed.
+ */
+void spi_access_bus(short device)
+{
+	/* Ensure that requested device is valid */
+	if ((device < 0) || (device >= NR_SPI_DEVICES))
+		panic("at91_spi: spi_access_bus called with invalid device");
+
+	if (spi_enabled == 0) {
+		at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_SPI);/* Enable Peripheral clock */
+		at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIEN);	/* Enable SPI */
+#ifdef DEBUG_SPI
+		printk("SPI on\n");
+#endif
+	}
+	spi_enabled++;
+
+	/* Lock the SPI bus */
+	down(&spi_lock);
+	current_device = device;
+
+	/* Enable PIO */
+	if (!spi_dev[device].pio_enabled) {
+		switch (device) {
+			case 0: AT91_CfgPIO_SPI_CS0();  break;
+			case 1: AT91_CfgPIO_SPI_CS1();  break;
+			case 2: AT91_CfgPIO_SPI_CS2();  break;
+			case 3: AT91_CfgPIO_SPI_CS3();  break;
+		}
+		spi_dev[device].pio_enabled = 1;
+#ifdef DEBUG_SPI
+		printk("SPI CS%i enabled\n", device);
+#endif
+	}
+
+	/* Configure SPI bus for device */
+	at91_spi_write(AT91_SPI_MR, AT91_SPI_MSTR | AT91_SPI_MODFDIS | (spi_dev[device].pcs << 16));
+}
+
+/*
+ * Relinquish control of the SPI bus.
+ */
+void spi_release_bus(short device)
+{
+	if (device != current_device)
+		panic("at91_spi: spi_release called with invalid device");
+
+	/* Release the SPI bus */
+	current_device = -1;
+	up(&spi_lock);
+
+	spi_enabled--;
+	if (spi_enabled == 0) {
+		at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIDIS);	/* Disable SPI */
+		at91_sys_write(AT91_PMC_PCDR, 1 << AT91_ID_SPI);/* Disable Peripheral clock */
+#ifdef DEBUG_SPI
+		printk("SPI off\n");
+#endif
+	}
+}
+
+/*
+ * Perform a data transfer over the SPI bus
+ */
+int spi_transfer(struct spi_transfer_list* list)
+{
+	struct spi_local *device = (struct spi_local *) &spi_dev[current_device];
+	int tx_size;
+
+	if (!list)
+		panic("at91_spi: spi_transfer called with NULL transfer list");
+	if (current_device == -1)
+		panic("at91_spi: spi_transfer called without acquiring bus");
+
+#ifdef DEBUG_SPI
+	printk("SPI transfer start [%i]\n", list->nr_transfers);
+#endif
+
+	/* If we are in 16-bit mode, we need to modify what we pass to the PDC */
+	tx_size = (at91_spi_read(AT91_SPI_CSR(current_device)) & AT91_SPI_BITS_16) ? 2 : 1;
+
+	/* Store transfer list */
+	device->xfers = list;
+	list->curr = 0;
+
+	/* Assume there must be at least one transfer */
+	device->tx = dma_map_single(NULL, list->tx[0], list->txlen[0], DMA_TO_DEVICE);
+	device->rx = dma_map_single(NULL, list->rx[0], list->rxlen[0], DMA_FROM_DEVICE);
+
+	/* Program PDC registers */
+	at91_spi_write(AT91_PDC_TPR, device->tx);
+	at91_spi_write(AT91_PDC_RPR, device->rx);
+	at91_spi_write(AT91_PDC_TCR, list->txlen[0] / tx_size);
+	at91_spi_write(AT91_PDC_RCR, list->rxlen[0] / tx_size);
+
+	/* Is there a second transfer? */
+	if (list->nr_transfers > 1) {
+		device->txnext = dma_map_single(NULL, list->tx[1], list->txlen[1], DMA_TO_DEVICE);
+		device->rxnext = dma_map_single(NULL, list->rx[1], list->rxlen[1], DMA_FROM_DEVICE);
+
+		/* Program Next PDC registers */
+		at91_spi_write(AT91_PDC_TNPR, device->txnext);
+		at91_spi_write(AT91_PDC_RNPR, device->rxnext);
+		at91_spi_write(AT91_PDC_TNCR, list->txlen[1] / tx_size);
+		at91_spi_write(AT91_PDC_RNCR, list->rxlen[1] / tx_size);
+	}
+	else {
+		device->txnext = 0;
+		device->rxnext = 0;
+		at91_spi_write(AT91_PDC_TNCR, 0);
+		at91_spi_write(AT91_PDC_RNCR, 0);
+	}
+
+	// TODO: If we are doing consecutive transfers (at high speed, or
+	//   small buffers), then it might be worth modifying the 'Delay between
+	//   Consecutive Transfers' in the CSR registers.
+	//   This is an issue if we cannot chain the next buffer fast enough
+	//   in the interrupt handler.
+
+	/* Enable transmitter and receiver */
+	at91_spi_write(AT91_PDC_PTCR, AT91_PDC_RXTEN | AT91_PDC_TXTEN);
+
+	at91_spi_write(AT91_SPI_IER, AT91_SPI_ENDRX);		/* enable buffer complete interrupt */
+	wait_for_completion(&transfer_complete);
+
+#ifdef DEBUG_SPI
+	printk("SPI transfer end\n");
+#endif
+
+	return 0;
+}
+
+/* ......................................................................... */
+
+/*
+ * Handle interrupts from the SPI controller.
+ */
+static irqreturn_t spi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+ 	unsigned int status;
+	struct spi_local *device = (struct spi_local *) &spi_dev[current_device];
+	struct spi_transfer_list *list = device->xfers;
+
+#ifdef DEBUG_SPI
+	printk("SPI interrupt %i\n", current_device);
+#endif
+
+	if (!list)
+		panic("at91_spi: spi_interrupt with a NULL transfer list");
+
+       	status = at91_spi_read(AT91_SPI_SR) & at91_spi_read(AT91_SPI_IMR);	/* read status */
+
+	dma_unmap_single(NULL, device->tx, list->txlen[list->curr], DMA_TO_DEVICE);
+	dma_unmap_single(NULL, device->rx, list->rxlen[list->curr], DMA_FROM_DEVICE);
+
+	device->tx = device->txnext;	/* move next transfer to current transfer */
+	device->rx = device->rxnext;
+
+	list->curr = list->curr + 1;
+	if (list->curr == list->nr_transfers) {		/* all transfers complete */
+		at91_spi_write(AT91_SPI_IDR, AT91_SPI_ENDRX);		/* disable interrupt */
+
+		/* Disable transmitter and receiver */
+		at91_spi_write(AT91_PDC_PTCR, AT91_PDC_RXTDIS | AT91_PDC_TXTDIS);
+
+		device->xfers = NULL;
+		complete(&transfer_complete);
+	}
+	else if (list->curr+1 == list->nr_transfers) {	/* no more next transfers */
+		device->txnext = 0;
+		device->rxnext = 0;
+		at91_spi_write(AT91_PDC_TNCR, 0);
+		at91_spi_write(AT91_PDC_RNCR, 0);
+	}
+	else {
+		int i = (list->curr)+1;
+		
+		/* If we are in 16-bit mode, we need to modify what we pass to the PDC */
+		int tx_size = (at91_spi_read(AT91_SPI_CSR(current_device)) & AT91_SPI_BITS_16) ? 2 : 1;
+
+		device->txnext = dma_map_single(NULL, list->tx[i], list->txlen[i], DMA_TO_DEVICE);
+		device->rxnext = dma_map_single(NULL, list->rx[i], list->rxlen[i], DMA_FROM_DEVICE);
+		at91_spi_write(AT91_PDC_TNPR, device->txnext);
+		at91_spi_write(AT91_PDC_RNPR, device->rxnext);
+		at91_spi_write(AT91_PDC_TNCR, list->txlen[i] / tx_size);
+		at91_spi_write(AT91_PDC_RNCR, list->rxlen[i] / tx_size);
+	}
+	return IRQ_HANDLED;
+}
+
+/* ......................................................................... */
+
+/*
+ * Initialize the SPI controller
+ */
+static int __init at91_spi_init(void)
+{
+	int i;
+
+	init_MUTEX(&spi_lock);
+
+	AT91_CfgPIO_SPI();
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SWRST);	/* software reset of SPI controller */
+
+	/* Set Chip Select registers to good defaults */
+	for (i = 0; i < 4; i++) {
+		at91_spi_write(AT91_SPI_CSR(i), AT91_SPI_CPOL | AT91_SPI_BITS_8 | (16 << 16) | (DEFAULT_SPI_BAUD << 8));
+	}
+
+	at91_spi_write(AT91_PDC_PTCR, AT91_PDC_RXTDIS | AT91_PDC_TXTDIS);
+
+	memset(&spi_dev, 0, sizeof(spi_dev));
+	spi_dev[0].pcs = 0xE;
+	spi_dev[1].pcs = 0xD;
+	spi_dev[2].pcs = 0xB;
+	spi_dev[3].pcs = 0x7;
+
+	if (request_irq(AT91_ID_SPI, spi_interrupt, 0, "spi", NULL))
+		return -EBUSY;
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIEN);		/* Enable SPI */
+
+	return 0;
+}
+
+static void at91_spi_exit(void)
+{
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIDIS);		/* Disable SPI */
+
+	free_irq(AT91_ID_SPI, 0);
+}
+
+
+EXPORT_SYMBOL(spi_access_bus);
+EXPORT_SYMBOL(spi_release_bus);
+EXPORT_SYMBOL(spi_transfer);
+
+module_init(at91_spi_init);
+module_exit(at91_spi_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Andrew Victor")
+MODULE_DESCRIPTION("SPI driver for Atmel AT91RM9200")
diff -urN linux-2.6.15.orig/drivers/char/at91_spidev.c linux-2.6.15/drivers/char/at91_spidev.c
--- linux-2.6.15.orig/drivers/char/at91_spidev.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/char/at91_spidev.c	Wed Jan 11 10:21:37 2006
@@ -0,0 +1,235 @@
+/*
+ * User-space interface to the SPI bus on Atmel AT91RM9200
+ *
+ *  Copyright (C) 2003 SAN People (Pty) Ltd
+ *
+ * Based on SPI driver by Rick Bronson
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <asm/arch/at91_spi.h>
+
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif
+
+
+#undef DEBUG_SPIDEV
+
+/* ......................................................................... */
+
+/*
+ * Read or Write to SPI bus.
+ */
+static ssize_t spidev_rd_wr(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	unsigned int spi_device = (unsigned int) file->private_data;
+
+	struct mm_struct * mm;
+	struct page ** maplist;
+	struct spi_transfer_list* list;
+	int    pgcount;
+	
+	unsigned int ofs, pagelen;
+	int res, i, err;
+
+	if (!count) {
+		return 0;
+	}
+	
+	list = kmalloc(sizeof(struct spi_transfer_list), GFP_KERNEL);
+	if (!list) {
+		return -ENOMEM;
+	}
+
+	mm = current->mm;
+	
+	pgcount = ((unsigned long)buf+count+PAGE_SIZE-1)/PAGE_SIZE - (unsigned long)buf/PAGE_SIZE;
+
+	if (pgcount >= MAX_SPI_TRANSFERS) {
+		kfree(list);
+		return -EFBIG;
+	}
+
+	maplist = kmalloc (pgcount * sizeof (struct page *), GFP_KERNEL);	
+
+	if (!maplist) {
+		kfree(list);
+		return -ENOMEM;	
+	}	
+	down_read(&mm->mmap_sem);
+	err= get_user_pages(current, mm, (unsigned long)buf, pgcount, 1, 0, maplist, NULL);	
+	up_read(&mm->mmap_sem);
+
+	if (err < 0) {
+		kfree(list);
+		kfree(maplist);
+		return err;
+	}
+        pgcount = err;
+
+#ifdef DEBUG_SPIDEV
+	printk("spidev_rd_rw: %i %i\n", count, pgcount);
+#endif
+
+	/* Set default return value = transfer length */
+	res = count;
+
+	/*
+	 * At this point, the virtual area buf[0] .. buf[count-1] will have
+	 * corresponding pages mapped in the physical memory and locked until
+	 * we unmap the kiobuf.  The pages cannot be swapped out or moved
+	 * around.
+	 */
+	ofs = (unsigned long) buf & (PAGE_SIZE -1);
+	pagelen = PAGE_SIZE - ofs;
+	if (count < pagelen)
+		pagelen = count;
+
+	for (i = 0; i < pgcount; i++) {
+		flush_dcache_page(maplist[i]);
+		
+		list->tx[i] = list->rx[i] = page_address(maplist[i]) + ofs;
+		list->txlen[i] = list->rxlen[i] = pagelen;
+
+#ifdef DEBUG_SPIDEV
+		printk("  %i: %x  (%i)\n", i, list->tx[i], list->txlen[i]);
+#endif
+
+		ofs = 0;	/* all subsequent transfers start at beginning of a page */
+		count = count - pagelen;
+		pagelen = (count < PAGE_SIZE) ? count : PAGE_SIZE;
+	}
+	list->nr_transfers = pgcount;
+
+	/* Perform transfer on SPI bus */
+	spi_access_bus(spi_device);
+	spi_transfer(list);
+	spi_release_bus(spi_device);
+
+	while (pgcount--) {
+		page_cache_release (maplist[pgcount]);
+	}
+
+	kfree(maplist);
+	kfree(list);
+
+	return res;
+}
+
+static int spidev_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int spi_device = MINOR(inode->i_rdev);
+
+	if (spi_device >= NR_SPI_DEVICES)
+		return -ENODEV;
+
+	// TODO: This interface can be used to configure the SPI bus.
+	// Configurable options could include: Speed, Clock Polarity, Clock Phase
+
+	switch(cmd) {
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+/*
+ * Open the SPI device
+ */
+static int spidev_open(struct inode *inode, struct file *file)
+{
+	unsigned int spi_device = MINOR(inode->i_rdev);
+
+	if (spi_device >= NR_SPI_DEVICES)
+		return -ENODEV;
+
+	/*
+	 * 'private_data' is actually a pointer, but we overload it with the
+	 * value we want to store.
+	 */
+	file->private_data = (void *)spi_device;
+
+	return 0;
+}
+
+/*
+ * Close the SPI device
+ */
+static int spidev_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/* ......................................................................... */
+
+static struct file_operations spidev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= spidev_rd_wr,
+	.write		= (int (*) (struct file *file, const char *buf, size_t count, loff_t *offset))spidev_rd_wr,
+	.ioctl		= spidev_ioctl,
+	.open		= spidev_open,
+	.release	= spidev_close,
+};
+
+/*
+ * Install the SPI /dev interface driver
+ */
+static int __init at91_spidev_init(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	int i;
+#endif	
+	
+	if (register_chrdev(SPI_MAJOR, "spi", &spidev_fops)) {
+		printk(KERN_ERR "at91_spidev: Unable to get major %d for SPI bus\n", SPI_MAJOR);
+		return -EIO;
+	}
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_mk_dir("spi");
+	for (i = 0; i < NR_SPI_DEVICES; i++) {
+		devfs_mk_cdev(MKDEV(SPI_MAJOR, i), S_IFCHR | S_IRUSR | S_IWUSR, "spi/%d",i);
+	}
+#endif	
+	printk(KERN_INFO "AT91 SPI driver loaded\n");
+
+	return 0;
+}
+
+/*
+ * Remove the SPI /dev interface driver
+ */
+static void __exit at91_spidev_exit(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	int i;
+	for (i = 0; i < NR_SPI_DEVICES; i++) {
+		devfs_remove("spi/%d", i);
+	}
+	
+       	devfs_remove("spi");
+#endif	
+	
+	if (unregister_chrdev(SPI_MAJOR, "spi")) {
+		printk(KERN_ERR "at91_spidev: Unable to release major %d for SPI bus\n", SPI_MAJOR);
+		return;
+	}
+}
+
+module_init(at91_spidev_init);
+module_exit(at91_spidev_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Andrew Victor")
+MODULE_DESCRIPTION("SPI /dev interface for Atmel AT91RM9200")
diff -urN linux-2.6.15.orig/drivers/char/watchdog/Kconfig linux-2.6.15/drivers/char/watchdog/Kconfig
--- linux-2.6.15.orig/drivers/char/watchdog/Kconfig	Mon Oct 31 09:51:00 2005
+++ linux-2.6.15/drivers/char/watchdog/Kconfig	Wed Jan 11 10:21:37 2006
@@ -148,6 +148,14 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called mpcore_wdt.
 
+config AT91_WATCHDOG
+	tristate "AT91RM9200 watchdog"
+	depends on WATCHDOG && ARCH_AT91RM9200
+	help
+	  Watchdog timer embedded into AT91RM9200 chips. This will reboot your
+	  system when the timeout is reached.
+
+
 # X86 (i386 + ia64 + x86_64) Architecture
 
 config ACQUIRE_WDT
diff -urN linux-2.6.15.orig/drivers/char/watchdog/Makefile linux-2.6.15/drivers/char/watchdog/Makefile
--- linux-2.6.15.orig/drivers/char/watchdog/Makefile	Mon Oct 31 09:51:00 2005
+++ linux-2.6.15/drivers/char/watchdog/Makefile	Wed Jan 11 10:21:37 2006
@@ -60,6 +60,7 @@
 
 # PPC64 Architecture
 obj-$(CONFIG_WATCHDOG_RTAS) += wdrtas.o
+obj-$(CONFIG_AT91_WATCHDOG) += at91_wdt.o
 
 # MIPS Architecture
 obj-$(CONFIG_INDYDOG) += indydog.o
diff -urN linux-2.6.15.orig/drivers/char/watchdog/at91_wdt.c linux-2.6.15/drivers/char/watchdog/at91_wdt.c
--- linux-2.6.15.orig/drivers/char/watchdog/at91_wdt.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/char/watchdog/at91_wdt.c	Wed Jan 11 10:21:37 2006
@@ -0,0 +1,186 @@
+/*
+ * Watchdog driver for Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) 2003 SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+
+#define WDT_DEFAULT_TIME 5	/* 5 seconds */
+#define WDT_MAX_TIME 256	/* 256 seconds */
+
+static int at91wdt_time = WDT_DEFAULT_TIME;
+static unsigned long at91wdt_busy;
+
+/* ......................................................................... */
+
+/*
+ * Disable the watchdog.
+ */
+static void at91_wdt_stop(void)
+{
+	at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN);
+}
+
+/*
+ * Enable and reset the watchdog.
+ */
+static void at91_wdt_start(void)
+{
+	at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN | AT91_ST_RSTEN | (((65536 * at91wdt_time) >> 8) & AT91_ST_WDV));
+	at91_sys_write(AT91_ST_CR, AT91_ST_WDRST);
+}
+
+/* ......................................................................... */
+
+/*
+ * Watchdog device is opened, and watchdog starts running.
+ */
+static int at91_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(1, &at91wdt_busy))
+		return -EBUSY;
+
+	/*
+	 * All counting occurs at SLOW_CLOCK / 128 = 0.256 Hz
+	 *
+	 * Since WDV is a 16-bit counter, the maximum period is
+	 * 65536 / 0.256 = 256 seconds.
+	 */
+
+	at91_wdt_start();
+	return 0;
+}
+
+/*
+ * Close the watchdog device.
+ * If CONFIG_WATCHDOG_NOWAYOUT is NOT defined then the watchdog is also
+ *  disabled.
+ */
+static int at91_wdt_close(struct inode *inode, struct file *file)
+{
+#ifndef CONFIG_WATCHDOG_NOWAYOUT
+	/* Disable the watchdog when file is closed */
+	at91_wdt_stop();
+#endif
+
+	at91wdt_busy = 0;
+	return 0;
+}
+
+/*
+ * Handle commands from user-space.
+ */
+static int at91_wdt_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	unsigned int new_value;
+	static struct watchdog_info info = {
+		identity: "at91 watchdog",
+		options:  WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,
+	};
+
+	switch(cmd) {
+		case WDIOC_KEEPALIVE:
+			at91_sys_write(AT91_ST_CR, AT91_ST_WDRST);	/* Pat the watchdog */
+			return 0;
+
+		case WDIOC_GETSUPPORT:
+			return copy_to_user((struct watchdog_info *)arg, &info, sizeof(info));
+
+		case WDIOC_SETTIMEOUT:
+			if (get_user(new_value, (int *)arg))
+				return -EFAULT;
+			if ((new_value <= 0) || (new_value > WDT_MAX_TIME))
+				return -EINVAL;
+
+			/* Restart watchdog with new time */
+			at91wdt_time = new_value;
+			at91_wdt_start();
+
+			/* Return current value */
+			return put_user(at91wdt_time, (int *)arg);
+
+		case WDIOC_GETTIMEOUT:
+			return put_user(at91wdt_time, (int *)arg);
+
+		case WDIOC_GETSTATUS:
+		case WDIOC_GETBOOTSTATUS:
+			return put_user(0, (int *)arg);
+
+		case WDIOC_SETOPTIONS:
+			if (get_user(new_value, (int *)arg))
+				return -EFAULT;
+			if (new_value & WDIOS_DISABLECARD)
+				at91_wdt_stop();
+			if (new_value & WDIOS_ENABLECARD)
+				at91_wdt_start();
+			return 0;
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+/*
+ * Pat the watchdog whenever device is written to.
+ */
+static ssize_t at91_wdt_write(struct file *file, const char *data, size_t len, loff_t *ppos)
+{
+	at91_sys_write(AT91_ST_CR, AT91_ST_WDRST);	/* Pat the watchdog */
+	return len;
+}
+
+/* ......................................................................... */
+
+static struct file_operations at91wdt_fops =
+{
+	.owner		= THIS_MODULE,
+	.ioctl		= at91_wdt_ioctl,
+	.open		= at91_wdt_open,
+	.release	= at91_wdt_close,
+	.write		= at91_wdt_write,
+};
+
+static struct miscdevice at91wdt_miscdev =
+{
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &at91wdt_fops,
+};
+
+static int __init at91_wdt_init(void)
+{
+	int res;
+
+	res = misc_register(&at91wdt_miscdev);
+	if (res)
+		return res;
+
+	printk("AT91 Watchdog Timer enabled (%d seconds)\n", WDT_DEFAULT_TIME);
+	return 0;
+}
+
+static void __exit at91_wdt_exit(void)
+{
+	misc_deregister(&at91wdt_miscdev);
+}
+
+module_init(at91_wdt_init);
+module_exit(at91_wdt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andrew Victor");
+MODULE_DESCRIPTION("Watchdog driver for Atmel AT91RM9200");
diff -urN linux-2.6.15.orig/drivers/i2c/busses/Kconfig linux-2.6.15/drivers/i2c/busses/Kconfig
--- linux-2.6.15.orig/drivers/i2c/busses/Kconfig	Wed Jan 11 09:18:57 2006
+++ linux-2.6.15/drivers/i2c/busses/Kconfig	Wed Jan 11 10:21:37 2006
@@ -84,6 +84,13 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-au1550.
 
+config I2C_AT91
+	tristate "Atmel AT91RM9200 I2C Two-Wire interface (TWI)"
+	depends on I2C && ARCH_AT91RM9200
+	help
+	  This supports the use of the I2C interface on the AT91RM9200
+	  processor.
+
 config I2C_ELEKTOR
 	tristate "Elektor ISA card"
 	depends on I2C && ISA && BROKEN_ON_SMP
diff -urN linux-2.6.15.orig/drivers/i2c/busses/Makefile linux-2.6.15/drivers/i2c/busses/Makefile
--- linux-2.6.15.orig/drivers/i2c/busses/Makefile	Mon Oct 31 09:51:01 2005
+++ linux-2.6.15/drivers/i2c/busses/Makefile	Wed Jan 11 10:21:37 2006
@@ -43,6 +43,7 @@
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
+obj-$(CONFIG_I2C_AT91)		+= at91_i2c.o
 
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
diff -urN linux-2.6.15.orig/drivers/i2c/busses/at91_i2c.c linux-2.6.15/drivers/i2c/busses/at91_i2c.c
--- linux-2.6.15.orig/drivers/i2c/busses/at91_i2c.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/i2c/busses/at91_i2c.c	Wed Jan 11 10:21:37 2006
@@ -0,0 +1,246 @@
+/*
+    i2c Support for Atmel's AT91RM9200 Two-Wire Interface
+
+    Copyright (C) Rick Bronson
+
+    Borrowed heavily from original work by:
+    Copyright (C) 2000 Philip Edelbrock <phil@stimpy.netroedge.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <asm/arch/at91rm9200_twi.h>
+#include <asm/arch/board.h>
+#include <asm/arch/pio.h>
+#include "at91_i2c.h"
+
+#define DBG(x...) do {\
+	if (debug > 0) \
+		printk(KERN_DEBUG "i2c:" x); \
+	} while(0)
+
+static int debug = 0;
+
+static struct at91_i2c_local *at91_i2c_device;
+
+/*
+ * Read from a TWI register.
+ */
+static inline unsigned long at91_twi_read(unsigned int reg)
+{
+	void __iomem *twi_base = (void __iomem *)AT91_VA_BASE_TWI;
+
+	return __raw_readl(twi_base + reg);
+}
+
+/*
+ * Write to a TWI register.
+ */
+static inline void at91_twi_write(unsigned int reg, unsigned long value)
+{
+	void __iomem *twi_base = (void __iomem *)AT91_VA_BASE_TWI;
+
+	__raw_writel(value, twi_base + reg);
+}
+
+/*
+ * Poll the i2c status register until the specified bit is set.
+ * Returns 0 if timed out (100 msec)
+ */
+static short at91_poll_status(unsigned long bit)
+{
+	int loop_cntr = 10000;
+
+	do {
+		udelay(10);
+	} while (!(at91_twi_read(AT91_TWI_SR) & bit) && (--loop_cntr > 0));
+
+	return (loop_cntr > 0);
+}
+
+/*
+ * Generic i2c master transfer entrypoint
+ */
+static int at91_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_msg *pmsg;
+	int length;
+	unsigned char *buf;
+	int i;
+
+	DBG("at91_xfer: processing %d messages:\n", num);
+
+	pmsg = msgs;		/* get 1st message */
+
+	for (i = 0; i < num; i++) {
+		DBG(" #%d: %sing %d byte%s %s 0x%02x ...", i,
+			pmsg->flags & I2C_M_RD ? "read" : "write",
+			pmsg->len, pmsg->len > 1 ? "s" : "",
+			pmsg->flags & I2C_M_RD ? "from" : "to",	pmsg->addr);
+
+		/*
+		 * Set the TWI Master Mode Register:
+		 *  We do _not_ use Atmel's feature of storing the "internal device address"
+		 *  in TWI_IADR. Thus the IADRSZ bits in TWI_MMR are set to zero.
+		 *  Instead the "internal device address" has to be written using a seperate
+		 *  i2c message.
+		 *  See http://lists.arm.linux.org.uk/pipermail/linux-arm-kernel/2004-September/024411.html
+		 */
+		at91_twi_write(AT91_TWI_MMR, (pmsg->addr << 16) | (pmsg->flags & I2C_M_RD ? AT91_TWI_MREAD : 0));
+
+		length = pmsg->len;
+		buf = pmsg->buf;
+		if (length && buf) {	/* sanity check */
+			if (pmsg->flags & I2C_M_RD) {
+				at91_twi_write(AT91_TWI_CR, AT91_TWI_START);
+				while (length--) {
+					if (!length)
+						at91_twi_write(AT91_TWI_CR, AT91_TWI_STOP);
+					/* Wait until transfer is finished */
+					if (!at91_poll_status(AT91_TWI_RXRDY)) {
+						printk(KERN_ERR "at91_i2c: timeout 1\n");
+						return 0;
+					}
+					*buf++ = (at91_twi_read(AT91_TWI_RHR) & 0xff);
+				}
+				if (!at91_poll_status(AT91_TWI_TXCOMP)) {
+					printk(KERN_ERR "at91_i2c: timeout 2\n");
+					return 0;
+				}
+			} else {
+				at91_twi_write(AT91_TWI_CR, AT91_TWI_START);
+				while (length--) {
+					at91_twi_write(AT91_TWI_THR, *buf++);
+					if (!length)
+						at91_twi_write(AT91_TWI_CR, AT91_TWI_STOP);
+					if (!at91_poll_status(AT91_TWI_TXRDY)) {
+						printk(KERN_ERR "at91_i2c: timeout 3\n");
+						return 0;
+					}
+				}
+				/* Wait until transfer is finished */
+				if (!at91_poll_status(AT91_TWI_TXCOMP)) {
+					printk(KERN_ERR "at91_i2c: timeout 4\n");
+					return 0;
+				}
+			}
+		}
+		DBG("ok\n");
+		pmsg++;	/* go to next message */
+	}
+	return i;
+}
+
+/*
+ * Return list of supported functionality
+ */
+static u32 at91_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+/* For now, we only handle combined mode (smbus) */
+static struct i2c_algorithm at91_algorithm = {
+	.master_xfer	= at91_xfer,
+	.functionality	= at91_func,
+};
+
+/*
+ * Main initialization routine
+ */
+static int __init i2c_at91_init(void)
+{
+	struct at91_i2c_local *device;
+	unsigned int sclock, cldiv2, cldiv3;
+	int rc;
+
+	AT91_CfgPIO_TWI();
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_TWI);	/* enable peripheral clock */
+
+	at91_twi_write(AT91_TWI_IDR, 0x1ff);		/* Disable all interrupts */
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_SWRST);	/* Reset peripheral */
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_MSEN);	/* Set Master mode */
+
+	sclock = 10 * at91_master_clock / AT91_TWI_CLOCK;
+	cldiv2 = (sclock / 10) - 5;
+	if ((sclock % 10) < 5)
+		cldiv2 -= 1;
+	cldiv3 = (cldiv2 + (4 - cldiv2 % 4)) >> 2;
+
+	/* Here, CKDIV = 1 and CHDIV=CLDIV  ==> CLDIV = CHDIV = 1/4*((Fmclk/FTWI) -6) */
+	at91_twi_write(AT91_TWI_CWGR, AT91_TWI_CKDIV1 | cldiv3 | (cldiv3 << 8));
+
+	device = (struct at91_i2c_local *) kmalloc(sizeof(struct at91_i2c_local), GFP_KERNEL);
+	if (device == NULL) {
+		printk(KERN_ERR "at91_i2c: can't allocate inteface!\n");
+		return -ENOMEM;
+	}
+	memset(device, 0, sizeof(struct at91_i2c_local));
+	at91_i2c_device = device;
+	i2c_set_adapdata(&(device->adapter), device);
+
+	sprintf(device->adapter.name, "AT91RM9200");
+	device->adapter.algo = &at91_algorithm;
+	device->adapter.algo_data = NULL;
+	device->adapter.client_register = NULL;
+	device->adapter.client_unregister = NULL;
+	device->adapter.class = I2C_CLASS_HWMON;
+
+	rc = i2c_add_adapter(&device->adapter);
+	if (rc) {
+		printk(KERN_ERR "at91_i2c: Adapter %s registration failed\n", device->adapter.name);
+		kfree(device);
+	}
+	else
+		printk(KERN_INFO "Found AT91 i2c\n");
+	return rc;
+}
+
+/*
+ * Clean up routine
+ */
+static void __exit i2c_at91_cleanup(void)
+{
+	struct at91_i2c_local *device = at91_i2c_device;
+	int rc;
+
+	rc = i2c_del_adapter(&device->adapter);
+	kfree(device);
+
+	at91_sys_write(AT91_PMC_PCDR, 1 << AT91_ID_TWI);	/* disable peripheral clock */
+
+	/* We aren't that prepared to deal with this... */
+	if (rc)
+		printk(KERN_ERR "at91_i2c: i2c_del_adapter failed (%i), that's bad!\n", rc);
+}
+
+module_init(i2c_at91_init);
+module_exit(i2c_at91_cleanup);
+
+MODULE_AUTHOR("Rick Bronson");
+MODULE_DESCRIPTION("I2C driver for Atmel AT91RM9200");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.15.orig/drivers/i2c/busses/at91_i2c.h linux-2.6.15/drivers/i2c/busses/at91_i2c.h
--- linux-2.6.15.orig/drivers/i2c/busses/at91_i2c.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/i2c/busses/at91_i2c.h	Wed Jan 11 10:21:37 2006
@@ -0,0 +1,32 @@
+/*
+    i2c Support for Atmel's AT91RM9200 Two-Wire Interface
+
+    (c) Rick Bronson
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef AT91_I2C_H
+#define AT91_I2C_H
+
+#define AT91_TWI_CLOCK		100000
+#define AT91_TWI_CKDIV1		(2 << 16)	/* TWI clock divider.  NOTE: see Errata #22 */
+
+/* Physical interface */
+struct at91_i2c_local {
+	struct i2c_adapter adapter;
+};
+
+#endif
diff -urN linux-2.6.15.orig/drivers/mmc/Kconfig linux-2.6.15/drivers/mmc/Kconfig
--- linux-2.6.15.orig/drivers/mmc/Kconfig	Wed Jan 11 09:19:03 2006
+++ linux-2.6.15/drivers/mmc/Kconfig	Wed Jan 11 11:14:23 2006
@@ -69,4 +69,12 @@
 
 	  If unsure, say N.
 
+config MMC_AT91RM9200
+	tristate "AT91RM9200 SD/MMC Card Interface support"
+	depends on ARCH_AT91RM9200 && MMC
+	help
+	  This selects the AT91RM9200 MCI controller.
+
+	  If unsure, say N.
+	
 endmenu
diff -urN linux-2.6.15.orig/drivers/mmc/Makefile linux-2.6.15/drivers/mmc/Makefile
--- linux-2.6.15.orig/drivers/mmc/Makefile	Wed Jan 11 09:19:03 2006
+++ linux-2.6.15/drivers/mmc/Makefile	Wed Jan 11 11:14:23 2006
@@ -19,5 +19,6 @@
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
+obj-$(CONFIG_MMC_AT91RM9200)	+= at91rm9200_mci.o
 
 mmc_core-y := mmc.o mmc_queue.o mmc_sysfs.o
diff -urN linux-2.6.15.orig/drivers/mmc/at91rm9200_mci.c linux-2.6.15/drivers/mmc/at91rm9200_mci.c
--- linux-2.6.15.orig/drivers/mmc/at91rm9200_mci.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/mmc/at91rm9200_mci.c	Wed Jan 11 11:14:23 2006
@@ -0,0 +1,1032 @@
+/*
+ *  linux/drivers/mmc/at91rm9200_mci.c - ATMEL AT91RM9200 MCI Driver
+ *
+ *  Copyright (C) 2005 Cougar Creek Computing Devices Ltd, All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+   This is the AT91RM9200 MCI driver that has been tested with both MMC cards
+   and SD-cards.  Boards that support write protect are now supported.
+   The CCAT91SBC001 board does not support SD cards.
+
+   The three entry points are at91rm9200_mci_request, at91rm9200_mci_set_ios
+   and at91rm9200_mci_get_ro.
+
+   SET IOS
+     This configures the device to put it into the correct mode and clock speed
+     required.
+
+   MCI REQUEST
+     MCI request processes the commands sent in the mmc_request structure. This
+     can consist of a processing command and a stop command in the case of
+     multiple block transfers.
+
+     There are three main types of request, commands, reads and writes.
+
+     Commands are straight forward. The command is submitted to the controller and
+     the request function returns. When the controller generates an interrupt to indicate
+     the command is finished, the response to the command are read and the mmc_request_done
+     function called to end the request.
+
+     Reads and writes work in a similar manner to normal commands but involve the PDC (DMA)
+     controller to manage the transfers.
+
+     A read is done from the controller directly to the scatterlist passed in from the request.
+     Due to a bug in the controller, when a read is completed, all the words are byte
+     swapped in the scatterlist buffers.
+
+     The sequence of read interrupts is: ENDRX, RXBUFF, CMDRDY
+
+     A write is slightly different in that the bytes to write are read from the scatterlist
+     into a dma memory buffer (this is in case the source buffer should be read only). The
+     entire write buffer is then done from this single dma memory buffer.
+
+     The sequence of write interrupts is: ENDTX, TXBUFE, NOTBUSY, CMDRDY
+
+   GET RO
+     Gets the status of the write protect pin, if available.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/mmc.h>
+#include <asm/arch/board.h>
+#include <asm/arch/at91rm9200_mci.h>
+#include <asm/arch/at91rm9200_pdc.h>
+
+#define DRIVER_NAME "at91rm9200_mci"
+
+#ifdef CONFIG_MMC_DEBUG
+#define DBG(fmt...)	\
+	printk(fmt)
+#else
+#define DBG(fmt...)	do { } while (0)
+#endif
+
+/* The command register values for each command */
+static const u32 commands[64] = {
+	/* Class 1  (0) */
+	MMC_GO_IDLE_STATE,
+	MMC_SEND_OP_COND	| AT91_MCI_RSPTYP_48,
+	MMC_ALL_SEND_CID	| AT91_MCI_RSPTYP_136,
+	MMC_SET_RELATIVE_ADDR	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT,
+	MMC_SET_DSR		| AT91_MCI_MAXLAT,
+	0,
+	SD_APP_SET_BUS_WIDTH	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT,
+	MMC_SELECT_CARD		| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT,
+	0,
+	MMC_SEND_CSD		| AT91_MCI_RSPTYP_136	| AT91_MCI_MAXLAT,
+	MMC_SEND_CID		| AT91_MCI_RSPTYP_136	| AT91_MCI_MAXLAT,
+	MMC_READ_DAT_UNTIL_STOP	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT | AT91_MCI_TRDIR | AT91_MCI_TRCMD_START | AT91_MCI_TRTYP_STREAM,
+	MMC_STOP_TRANSMISSION	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT | AT91_MCI_TRCMD_STOP,
+	MMC_SEND_STATUS		| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT,
+	0,
+	MMC_GO_INACTIVE_STATE,
+
+	/* Class 2 (16) */
+	MMC_SET_BLOCKLEN	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT,
+	MMC_READ_SINGLE_BLOCK	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT | AT91_MCI_TRDIR | AT91_MCI_TRCMD_START | AT91_MCI_TRTYP_BLOCK,
+	MMC_READ_MULTIPLE_BLOCK	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT | AT91_MCI_TRDIR | AT91_MCI_TRCMD_START | AT91_MCI_TRTYP_MULTIPLE,
+	0,
+
+	/* Class 3 (20) */
+	MMC_WRITE_DAT_UNTIL_STOP| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT                   | AT91_MCI_TRCMD_START | AT91_MCI_TRTYP_STREAM,
+	0,
+	0,
+
+	/* Class 4 (23) */
+	MMC_SET_BLOCK_COUNT	| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT,
+	MMC_WRITE_BLOCK		| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT                   | AT91_MCI_TRCMD_START | AT91_MCI_TRTYP_BLOCK,
+	MMC_WRITE_MULTIPLE_BLOCK| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT                   | AT91_MCI_TRCMD_START | AT91_MCI_TRTYP_MULTIPLE,
+	MMC_PROGRAM_CID		| AT91_MCI_RSPTYP_48	| AT91_MCI_MAXLAT,
+	MMC_PROGRAM_CSD		| AT91_MCI_RSPTYP_48,
+
+	/* Class 6 (28) */
+	MMC_SET_WRITE_PROT	| AT91_MCI_RSPTYP_48,
+	MMC_CLR_WRITE_PROT	| AT91_MCI_RSPTYP_48,
+	MMC_SEND_WRITE_PROT	| AT91_MCI_RSPTYP_48,
+	0,
+
+	/* Class 5 (32) */
+	0,
+	0,
+	0,
+	MMC_ERASE_GROUP_START	| AT91_MCI_RSPTYP_48,
+	MMC_ERASE_GROUP_END	| AT91_MCI_RSPTYP_48,
+	MMC_ERASE		| AT91_MCI_RSPTYP_48 	| AT91_MCI_MAXLAT,
+	0,
+
+	/* Class 9 (39) */
+	MMC_FAST_IO		| AT91_MCI_RSPTYP_48 	| AT91_MCI_MAXLAT,
+	MMC_GO_IRQ_STATE	| AT91_MCI_RSPTYP_48 	| AT91_MCI_MAXLAT,
+	SD_APP_OP_COND					| AT91_MCI_SPCMD_NONE	| AT91_MCI_RSPTYP_48	| AT91_MCI_TRCMD_NONE,
+
+	/* Class 7 (42) */
+	MMC_LOCK_UNLOCK		| AT91_MCI_RSPTYP_48 	| AT91_MCI_MAXLAT,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	SD_APP_SEND_SCR						| AT91_MCI_SPCMD_NONE	| AT91_MCI_RSPTYP_48	|AT91_MCI_TRDIR | AT91_MCI_TRCMD_START	| AT91_MCI_TRTYP_BLOCK | AT91_MCI_MAXLAT,
+	0,
+	0,
+	0,
+
+	/* Class 8 (55) */
+	MMC_APP_CMD		| AT91_MCI_RSPTYP_48 	| AT91_MCI_MAXLAT,
+	MMC_GEN_CMD		| AT91_MCI_RSPTYP_48 	| AT91_MCI_MAXLAT,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0
+};
+
+#define FL_SENT_COMMAND (1 << 0)
+#define FL_SENT_STOP (1 << 1)
+
+
+
+/*
+ * Read from a MCI register.
+ */
+static inline unsigned long at91_mci_read(unsigned int reg)
+{
+	void __iomem *mci_base = (void __iomem *)AT91_VA_BASE_MCI;
+
+	return __raw_readl(mci_base + reg);
+}
+
+/*
+ * Write to a MCI register.
+ */
+static inline void at91_mci_write(unsigned int reg, unsigned long value)
+{
+        void __iomem *mci_base = (void __iomem *)AT91_VA_BASE_MCI;
+
+        __raw_writel(value, mci_base + reg);
+}
+
+/*
+ * Low level type for this driver
+ */
+struct at91mci_host
+{
+	struct mmc_host *mmc;
+	struct mmc_command *cmd;
+	struct mmc_request *request;
+
+	struct at91_mmc_data *board;
+	int present;
+
+	/*
+	 * Flag indicating when the command has been sent. This is used to
+	 * work out whether or not to send the stop
+	 */
+	unsigned int flags;
+
+	/* DMA buffer used for transmitting */
+	unsigned int* buffer;
+	dma_addr_t physical_address;
+	unsigned int total_length;
+
+	/* Latest in the scatterlist that has been enabled for transfer, but not freed */
+	int in_use_index;
+
+	/* Latest in the scatterlist that has been enabled for transfer */
+	int transfer_index;
+};
+
+/*
+ * Copy from sg to a dma block - used for transfers
+ */
+static inline void at91mci_sg_to_dma(struct at91mci_host *host, struct mmc_data *data)
+{
+	unsigned int len, i, size;
+	unsigned *dmabuf = host->buffer;
+
+	size = host->total_length;
+	len = data->sg_len;
+
+	/*
+	 * Just loop through all entries. Size might not
+	 * be the entire list though so make sure that
+	 * we do not transfer too much.
+	 */
+	for (i = 0;i < len;i++)
+	{
+		struct scatterlist *sg;
+		int amount;
+		int index;
+		unsigned int *sgbuffer;
+
+		sg = &data->sg[i];
+
+		sgbuffer = kmap_atomic(sg->page, KM_BIO_SRC_IRQ) + sg->offset;
+		amount = min(size, sg->length);
+		size -= amount;
+		amount /= 4;
+
+		for (index = 0; index < amount; index++) {
+			*dmabuf++ = swab32(sgbuffer[index]);
+		}
+		kunmap_atomic(sg->page, KM_BIO_SRC_IRQ);
+
+		if (size == 0)
+			break;
+	}
+
+	/*
+	 * Check that we didn't get a request to transfer
+	 * more data than can fit into the SG list.
+	 */
+	BUG_ON(size != 0);
+}
+
+/*
+ * Prepare a dma read
+ */
+static void at91mci_pre_dma_read(struct at91mci_host *host)
+{
+	int i;
+	struct scatterlist *sg;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+
+	DBG("pre dma read\n");
+
+	cmd = host->cmd;
+	if (!cmd) {
+		DBG("no command\n");
+		return;
+	}
+
+	data = cmd->data;
+	if (!data) {
+		DBG("no data\n");
+		return;
+	}
+
+	for (i = 0; i < 2; i++) {
+		/* nothing left to transfer */
+		if (host->transfer_index >= data->sg_len) {
+			DBG("Nothing left to transfer (index = %d)\n", host->transfer_index);
+			break;
+		}
+
+		/* Check to see if this needs filling */
+		if (i == 0) {
+			if (at91_mci_read(AT91_PDC_RCR) != 0) {
+				DBG("Transfer active in current\n");
+				continue;
+			}
+		}
+		else {
+			if (at91_mci_read(AT91_PDC_RNCR) != 0) {
+				DBG("Transfer active in next\n");
+				continue;
+			}
+		}
+
+		/* Setup the next transfer */
+		DBG("Using transfer index %d\n", host->transfer_index);
+
+		sg = &data->sg[host->transfer_index++];
+		DBG("sg = %p\n", sg);
+
+		sg->dma_address =
+			dma_map_page(NULL, sg->page, sg->offset, sg->length, DMA_FROM_DEVICE);
+
+		DBG("dma address = %08X, length = %d\n", sg->dma_address, sg->length);
+
+		if (i == 0) {
+			at91_mci_write(AT91_PDC_RPR, sg->dma_address);
+			at91_mci_write(AT91_PDC_RCR, sg->length / 4);
+		}
+		else {
+			at91_mci_write(AT91_PDC_RNPR, sg->dma_address);
+			at91_mci_write(AT91_PDC_RNCR, sg->length / 4);
+		}
+	}
+
+	DBG("pre dma read done\n");
+}
+
+/*
+ * Handle after a dma read
+ */
+static void at91mci_post_dma_read(struct at91mci_host *host)
+{
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+
+	DBG("post dma read\n");
+
+	cmd = host->cmd;
+	if (!cmd) {
+		DBG("no command\n");
+		return;
+	}
+
+	data = cmd->data;
+	if (!data) {
+		DBG("no data\n");
+		return;
+	}
+
+	while (host->in_use_index < host->transfer_index) {
+		unsigned int *buffer;
+		int index;
+		int len;
+
+		struct scatterlist *sg;
+
+		DBG("finishing index %d\n", host->in_use_index);
+
+		sg = &data->sg[host->in_use_index++];
+
+		DBG("Unmapping page %08X\n", sg->dma_address);
+
+		dma_unmap_page(NULL, sg->dma_address, sg->length, DMA_FROM_DEVICE);
+
+		/* Swap the contents of the buffer */
+		buffer = kmap_atomic(sg->page, KM_BIO_SRC_IRQ) + sg->offset;
+		DBG("buffer = %p, length = %d\n", buffer, sg->length);
+
+		data->bytes_xfered += sg->length;
+
+		len = sg->length / 4;
+
+		for (index = 0; index < len; index++) {
+			buffer[index] = swab32(buffer[index]);
+		}
+		flush_dcache_page(sg->page);
+		kunmap_atomic(sg->page, KM_BIO_SRC_IRQ);
+	}
+
+	/* Is there another transfer to trigger? */
+	if (host->transfer_index < data->sg_len) {
+		at91mci_pre_dma_read(host);
+	}
+	else {
+		at91_mci_write(AT91_MCI_IER, AT91_MCI_RXBUFF);
+		at91_mci_write(AT91_PDC_PTCR, AT91_PDC_RXTDIS | AT91_PDC_TXTDIS);
+	}
+
+	DBG("post dma read done\n");
+}
+
+/*
+ * Handle transmitted data
+ */
+static void at91rm9200_mci_handle_transmitted(struct at91mci_host *host)
+{
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+
+	DBG("Handling the transmit\n");
+
+	/* Disable the transfer */
+	at91_mci_write(AT91_PDC_PTCR, AT91_PDC_RXTDIS | AT91_PDC_TXTDIS);
+
+	/* Now wait for cmd ready */
+	at91_mci_write(AT91_MCI_IDR, AT91_MCI_TXBUFE);
+	at91_mci_write(AT91_MCI_IER, AT91_MCI_NOTBUSY);
+
+	cmd = host->cmd;
+	if (!cmd) return;
+
+	data = cmd->data;
+	if (!data) return;
+
+	data->bytes_xfered = host->total_length;
+}
+
+/*
+ * Enable the controller
+ */
+static void at91rm9200_mci_enable(void)
+{
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_MCI);	/* Enable the peripheral clock */
+	at91_mci_write(AT91_MCI_CR, AT91_MCI_MCIEN);
+	at91_mci_write(AT91_MCI_IDR, 0xFFFFFFFF);
+	at91_mci_write(AT91_MCI_DTOR, AT91_MCI_DTOMUL_1M | AT91_MCI_DTOCYC);
+	at91_mci_write(AT91_MCI_MR, 0x834A);
+	at91_mci_write(AT91_MCI_SDCR, 0x0);
+}
+
+/*
+ * Disable the controller
+ */
+static void at91rm9200_mci_disable(void)
+{
+	at91_mci_write(AT91_MCI_CR, AT91_MCI_MCIDIS | AT91_MCI_SWRST);
+	at91_sys_write(AT91_PMC_PCDR, 1 << AT91_ID_MCI);	/* Disable the peripheral clock */
+}
+
+/*
+ * Send a command
+ * return the interrupts to enable
+ */
+static unsigned int at91rm9200_mci_send_command(struct at91mci_host *host, struct mmc_command *cmd)
+{
+	unsigned int cmdr, mr;
+	unsigned int block_length;
+	struct mmc_data *data = cmd->data;
+	struct mmc_host *mmc = host->mmc;
+
+	unsigned int blocks;
+	unsigned int ier = 0;
+
+	host->cmd = cmd;
+
+	/* Not sure if this is needed */
+#if 0
+	if ((at91_mci_read(AT91_MCI_SR) & AT91_MCI_RTOE) && (cmd->opcode == 1)) {
+		DBG("Clearing timeout\n");
+		at91_mci_write(AT91_MCI_ARGR, 0);
+		at91_mci_write(AT91_MCI_CMDR, AT91_MCI_OPDCMD);
+		while (!(at91_mci_read(AT91_MCI_SR) & AT91_MCI_CMDRDY)) {
+			/* spin */
+			DBG("Clearing: SR = %08X\n", at91_mci_read(AT91_MCI_SR));
+		}
+	}
+#endif
+
+	cmdr = commands[cmd->opcode];
+	if (data) {
+		block_length = 1 << data->blksz_bits;
+		blocks = data->blocks;
+	}
+	else {
+		block_length = 0;
+		blocks = 0;
+	}
+
+	if (mmc->ios.bus_mode == MMC_BUSMODE_OPENDRAIN) {
+		cmdr |= AT91_MCI_OPDCMD;
+	}
+
+	/*
+	 * Set the arguments and send the command
+	 */
+	DBG("Sending command %d as %08X, arg = %08X, blocks = %d, length = %d (MR = %08X)\n",
+		cmd->opcode, cmdr, cmd->arg, blocks, block_length, at91_mci_read(AT91_MCI_MR));
+
+	if (!data) {
+		at91_mci_write(AT91_PDC_PTCR, AT91_PDC_TXTDIS | AT91_PDC_RXTDIS);
+		at91_mci_write(AT91_PDC_RPR, 0);
+		at91_mci_write(AT91_PDC_RCR, 0);
+		at91_mci_write(AT91_PDC_RNPR, 0);
+		at91_mci_write(AT91_PDC_RNCR, 0);
+		at91_mci_write(AT91_PDC_TPR, 0);
+		at91_mci_write(AT91_PDC_TCR, 0);
+		at91_mci_write(AT91_PDC_TNPR, 0);
+		at91_mci_write(AT91_PDC_TNCR, 0);
+
+		at91_mci_write(AT91_MCI_ARGR, cmd->arg);
+		at91_mci_write(AT91_MCI_CMDR, cmdr);
+		return AT91_MCI_CMDRDY;
+	}
+
+	mr = at91_mci_read(AT91_MCI_MR) & 0x7fff;	/* zero block length and PDC mode */
+	at91_mci_write(AT91_MCI_MR, mr | (block_length << 16) | AT91_MCI_PDCMODE);
+
+	/*
+	 * Disable the PDC controller
+	 */
+	at91_mci_write(AT91_PDC_PTCR, AT91_PDC_RXTDIS | AT91_PDC_TXTDIS);
+
+	if (cmdr & AT91_MCI_TRCMD_START) {
+		data->bytes_xfered = 0;
+		host->transfer_index = 0;
+		host->in_use_index = 0;
+		if (cmdr & AT91_MCI_TRDIR) {
+			/*
+			 * Handle a read
+			 */
+			host->buffer = NULL;
+			host->total_length = 0;
+
+			at91mci_pre_dma_read(host);
+			ier = AT91_MCI_ENDRX /* | AT91_MCI_RXBUFF */;
+		} else {
+			/*
+			 * Handle a write
+			 */
+			host->total_length = block_length * blocks;
+			host->buffer = dma_alloc_coherent(NULL,
+							  host->total_length,
+							  &host->physical_address, GFP_KERNEL);
+
+			at91mci_sg_to_dma(host, data);
+
+			DBG("Transmitting %d bytes\n", host->total_length);
+
+			at91_mci_write(AT91_PDC_TPR, host->physical_address);
+			at91_mci_write(AT91_PDC_TCR, host->total_length / 4);
+			ier = AT91_MCI_TXBUFE;
+		}
+	}
+
+	/*
+	 * Send the command and then enable the PDC - not the other way round as
+	 * the data sheet says
+	 */
+
+	at91_mci_write(AT91_MCI_ARGR, cmd->arg);
+	at91_mci_write(AT91_MCI_CMDR, cmdr);
+
+	if (cmdr & AT91_MCI_TRCMD_START) {
+		if (cmdr & AT91_MCI_TRDIR) {
+			at91_mci_write(AT91_PDC_PTCR, AT91_PDC_RXTEN);
+		}
+		else {
+			at91_mci_write(AT91_PDC_PTCR, AT91_PDC_TXTEN);
+		}
+	}
+
+	return ier;
+}
+
+/*
+ * Wait for a command to complete
+ */
+static void at91mci_process_command(struct at91mci_host *host, struct mmc_command *cmd)
+{
+	unsigned int ier;
+
+	ier = at91rm9200_mci_send_command(host, cmd);
+
+	DBG("setting ier to %08X\n", ier);
+
+	/* Stop on errors or the required value */
+	at91_mci_write(AT91_MCI_IER, 0xffff0000 | ier);
+}
+
+/*
+ * Process the next step in the request
+ */
+static void at91mci_process_next(struct at91mci_host *host)
+{
+	if (!(host->flags & FL_SENT_COMMAND)) {
+		host->flags |= FL_SENT_COMMAND;
+		at91mci_process_command(host, host->request->cmd);
+	}
+	else if ((!(host->flags & FL_SENT_STOP)) && host->request->stop) {
+		host->flags |= FL_SENT_STOP;
+		at91mci_process_command(host, host->request->stop);
+	}
+	else {
+		mmc_request_done(host->mmc, host->request);
+	}
+}
+
+/*
+ * Handle a command that has been completed
+ */
+static void at91mci_completed_command(struct at91mci_host *host)
+{
+	struct mmc_command *cmd = host->cmd;
+	unsigned int status;
+
+	at91_mci_write(AT91_MCI_IDR, 0xffffffff);
+
+	cmd->resp[0] = at91_mci_read(AT91_MCI_RSPR(0));
+	cmd->resp[1] = at91_mci_read(AT91_MCI_RSPR(1));
+	cmd->resp[2] = at91_mci_read(AT91_MCI_RSPR(2));
+	cmd->resp[3] = at91_mci_read(AT91_MCI_RSPR(3));
+
+	if (host->buffer) {
+		dma_free_coherent(NULL, host->total_length, host->buffer, host->physical_address);
+		host->buffer = NULL;
+	}
+
+	status = at91_mci_read(AT91_MCI_SR);
+
+	DBG("Status = %08X [%08X %08X %08X %08X]\n",
+		 status, cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+
+	if (status & (AT91_MCI_RINDE | AT91_MCI_RDIRE | AT91_MCI_RCRCE |
+			AT91_MCI_RENDE | AT91_MCI_RTOE | AT91_MCI_DCRCE |
+			AT91_MCI_DTOE | AT91_MCI_OVRE | AT91_MCI_UNRE)) {
+		if ( (status & AT91_MCI_RCRCE) &&
+			((cmd->opcode == MMC_SEND_OP_COND) ||
+				 (cmd->opcode == SD_APP_OP_COND))) {
+			cmd->error = MMC_ERR_NONE;
+		}
+		else {
+			if (status & (AT91_MCI_RTOE | AT91_MCI_DTOE)) {
+				cmd->error = MMC_ERR_TIMEOUT;
+			}
+			else if (status & (AT91_MCI_RCRCE | AT91_MCI_DCRCE)) {
+				cmd->error = MMC_ERR_BADCRC;
+			}
+			else if (status & (AT91_MCI_OVRE | AT91_MCI_UNRE)) {
+				cmd->error = MMC_ERR_FIFO;
+			}
+			else {
+				cmd->error = MMC_ERR_FAILED;
+			}
+
+			DBG("Error detected and set to %d (cmd = %d, retries = %d)\n",
+				 cmd->error, cmd->opcode, cmd->retries);
+		}
+	}
+	else {
+		cmd->error = MMC_ERR_NONE;
+	}
+
+	at91mci_process_next(host);
+}
+
+/*
+ * Handle an MMC request
+ */
+static void at91rm9200_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct at91mci_host *host = mmc_priv(mmc);
+	host->request = mrq;
+	host->flags = 0;
+
+	at91mci_process_next(host);
+}
+
+/*
+ * Set the IOS
+ */
+static void at91rm9200_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	int clkdiv;
+	struct at91mci_host *host = mmc_priv(mmc);
+
+	DBG("Clock %uHz, busmode %u, powermode %u, Vdd %u\n",
+		ios->clock, ios->bus_mode, ios->power_mode, ios->vdd);
+
+	if (ios->clock == 0) {
+		/* Disable the MCI controller */
+		at91_mci_write(AT91_MCI_CR, AT91_MCI_MCIDIS);
+		clkdiv = 0;
+	}
+	else {
+		/* Enable the MCI controller */
+		at91_mci_write(AT91_MCI_CR, AT91_MCI_MCIEN);
+
+		if ( (at91_master_clock % (ios->clock * 2)) == 0 )
+			clkdiv = ((at91_master_clock / ios->clock) / 2) - 1;
+		else
+			clkdiv = (at91_master_clock / ios->clock) / 2;
+
+		DBG("clkdiv = %d. mcck = %ld\n", clkdiv,
+			at91_master_clock / (2 * (clkdiv + 1)));
+	}
+	if (ios->bus_width == MMC_BUS_WIDTH_4 && host->board->wire4) {
+		DBG("Setting controller bus width to 4\n");
+		at91_mci_write(AT91_MCI_SDCR, at91_mci_read(AT91_MCI_SDCR) | AT91_MCI_SDCBUS);
+	}
+	else {
+		DBG("Setting controller bus width to 1\n");
+		at91_mci_write(AT91_MCI_SDCR, at91_mci_read(AT91_MCI_SDCR) & ~AT91_MCI_SDCBUS);
+	}
+
+	/* Set the clock divider */
+	at91_mci_write(AT91_MCI_MR, (at91_mci_read(AT91_MCI_MR) & ~AT91_MCI_CLKDIV) | clkdiv);
+
+	/* maybe switch power to the card */
+	if (host && host->board->vcc_pin) {
+		switch (ios->power_mode) {
+		case MMC_POWER_OFF:
+			at91_set_gpio_output(host->board->vcc_pin, 0);
+			break;
+		case MMC_POWER_UP:
+		case MMC_POWER_ON:
+			at91_set_gpio_output(host->board->vcc_pin, 1);
+			break;
+		}
+	}
+}
+
+/*
+ * Handle an interrupt
+ */
+static irqreturn_t at91rm9200_mci_irq(int irq, void *devid, struct pt_regs *regs)
+{
+	struct at91mci_host *host = devid;
+	int completed = 0;
+
+	unsigned int int_status;
+
+	if (host == NULL) {
+		return IRQ_HANDLED;
+	}
+
+	int_status = at91_mci_read(AT91_MCI_SR);
+	DBG("MCI irq: status = %08X, %08X, %08X\n", int_status, at91_mci_read(AT91_MCI_IMR),
+		int_status & at91_mci_read(AT91_MCI_IMR));
+
+	if ((int_status & at91_mci_read(AT91_MCI_IMR)) & 0xffff0000) {
+		completed = 1;
+	}
+	int_status &= at91_mci_read(AT91_MCI_IMR);
+
+	if (int_status & AT91_MCI_UNRE) {
+		DBG("Underrun error\n");
+	}
+
+	if (int_status & AT91_MCI_OVRE) {
+		DBG("Overrun error\n");
+	}
+
+	if (int_status & AT91_MCI_DTOE) {
+		DBG("Data timeout\n");
+	}
+
+	if (int_status & AT91_MCI_DCRCE) {
+		DBG("CRC error in data\n");
+	}
+
+	if (int_status & AT91_MCI_RTOE) {
+		DBG("Response timeout\n");
+	}
+
+	if (int_status & AT91_MCI_RENDE) {
+		DBG("Response end bit error\n");
+	}
+
+	if (int_status & AT91_MCI_RCRCE) {
+		DBG("Response CRC error\n");
+	}
+
+	if (int_status & AT91_MCI_RDIRE) {
+		DBG("Response direction error\n");
+	}
+
+	if (int_status & AT91_MCI_RINDE) {
+		DBG("Response index error\n");
+	}
+
+	/* Only continue processing if no errors */
+	if (!completed) {
+		if (int_status & AT91_MCI_TXBUFE) {
+			DBG("TX buffer empty\n");
+			at91rm9200_mci_handle_transmitted(host);
+		}
+	
+		if (int_status & AT91_MCI_RXBUFF) {
+			DBG("RX buffer full\n");
+			at91_mci_write(AT91_MCI_IER, AT91_MCI_CMDRDY);
+		}
+
+		if (int_status & AT91_MCI_ENDTX) {
+			DBG("Transmit has ended\n");
+		}
+
+		if (int_status & AT91_MCI_ENDRX) {
+			DBG("Receive has ended\n");
+			at91mci_post_dma_read(host);
+		}
+
+		if (int_status & AT91_MCI_NOTBUSY) {
+			DBG("Card is ready\n");
+			at91_mci_write(AT91_MCI_IER, AT91_MCI_CMDRDY);
+		}
+
+		if (int_status & AT91_MCI_DTIP) {
+			DBG("Data transfer in progress\n");
+		}
+
+		if (int_status & AT91_MCI_BLKE) {
+			DBG("Black transfer has ended\n");
+		}
+
+		if (int_status & AT91_MCI_TXRDY) {
+			DBG("Ready to transmit\n");
+		}
+
+		if (int_status & AT91_MCI_RXRDY) {
+			DBG("Ready to receive\n");
+		}
+
+		if (int_status & AT91_MCI_CMDRDY) {
+			DBG("Command ready\n");
+			completed = 1;
+		}
+	}
+	at91_mci_write(AT91_MCI_IDR, int_status);
+
+	if (completed) {
+		DBG("Completed command\n");
+		at91_mci_write(AT91_MCI_IDR, 0xffffffff);
+		at91mci_completed_command(host);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+at91rm9200_mmc_det_irq(int irq, void *_host, struct pt_regs *regs)
+{
+	struct at91mci_host *host = _host;
+	int present = !at91_get_gpio_value(irq);
+
+	/* we expect this irq on both insert and remove,
+	 * and use a short delay to debounce.
+	 */
+	if (present != host->present) {
+		host->present = present;
+		DBG("%s: card %s\n", mmc_hostname(host->mmc),
+			present ? "insert" : "remove");
+		if (!present) {
+			DBG("****** Resetting SD-card bus width ******\n");
+			at91_mci_write(AT91_MCI_SDCR, 0);
+		}
+		schedule_delayed_work(&host->mmc->detect, msecs_to_jiffies(100));
+	}
+	return IRQ_HANDLED;
+}
+
+int at91rm9200_mci_get_ro(struct mmc_host *mmc)
+{
+	int read_only = 0;
+	struct at91mci_host *host = mmc_priv(mmc);
+	if( host->board->wp_pin ) {
+		read_only = at91_get_gpio_value(host->board->wp_pin);
+		printk(KERN_WARNING "%s: card is %s\n",
+					mmc_hostname(mmc),
+					(read_only ? "read-only" : "read-write") );
+	}
+	else {
+		printk(KERN_WARNING "%s: host does not "
+				"support reading read-only "
+				"switch.  Assuming write-enable.\n",
+				mmc_hostname(mmc));
+	}
+	return read_only;
+}
+
+static struct mmc_host_ops at91rm9200_mci_ops = {
+	.request	= at91rm9200_mci_request,
+	.set_ios	= at91rm9200_mci_set_ios,
+	.get_ro		= at91rm9200_mci_get_ro,
+};
+
+/*
+ * Probe for the device
+ */
+static int at91rm9200_mci_probe(struct device *dev)
+{
+	struct mmc_host *mmc;
+	struct at91mci_host *host;
+	int ret;
+
+	DBG("Probe MCI devices\n");
+
+	mmc = mmc_alloc_host(sizeof(struct at91mci_host), dev);
+	if (!mmc) {
+		DBG("Failed to allocate mmc host\n");
+
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	mmc->ops = &at91rm9200_mci_ops;
+	mmc->f_min = 375000;
+	mmc->f_max = 25000000;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->buffer = NULL;
+	host->board = dev->platform_data;
+	if (host->board->wire4)
+		mmc->caps |= MMC_CAP_4_BIT_DATA;
+
+	/*
+	 * Allocate the MCI interrupt
+	 */
+	ret = request_irq(AT91_ID_MCI, at91rm9200_mci_irq, SA_SHIRQ, DRIVER_NAME, host);
+	if (ret) {
+		DBG("Failed to request MCI interrupt\n");
+		return ret;
+	}
+
+	dev_set_drvdata(dev, mmc);
+
+	/*
+	 * Add host to MMC layer
+	 */
+	if (host->board->det_pin)
+		host->present = !at91_get_gpio_value(host->board->det_pin);
+	else
+		host->present = -1;
+	mmc_add_host(mmc);
+
+	/*
+	 * monitor card insertion/removal if we can
+	 */
+	if (host->board->det_pin) {
+		ret = request_irq(host->board->det_pin, at91rm9200_mmc_det_irq,
+				SA_SAMPLE_RANDOM, DRIVER_NAME, host);
+		if (ret)
+			DBG("couldn't allocate MMC detect irq\n");
+	}
+
+	DBG(KERN_INFO "Added MCI driver\n");
+
+	return 0;
+}
+
+/*
+ * Remove a device
+ */
+static int at91rm9200_mci_remove(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct at91mci_host *host;
+
+	if (!mmc) return -1;
+
+	host = mmc_priv(mmc);
+
+	if (host->present != -1) {
+		free_irq(host->board->det_pin, host);
+		cancel_delayed_work(&host->mmc->detect);
+	}
+
+	free_irq(AT91_ID_MCI, host);
+	mmc_free_host(mmc);
+
+	DBG("Removed\n");
+
+	return 0;
+}
+
+static struct device_driver at91rm9200_mci_driver = {
+	.name		= DRIVER_NAME,
+	.bus		= &platform_bus_type,
+	.probe		= at91rm9200_mci_probe,
+	.remove		= at91rm9200_mci_remove,
+};
+
+/* Initialise the MCI controller
+ */
+static int __init at91rm9200_mci_init(void)
+{
+	int result;
+
+	at91rm9200_mci_disable();
+	at91rm9200_mci_enable();
+
+	result = driver_register(&at91rm9200_mci_driver);
+	if (result < 0) {
+		printk(KERN_ERR "AT91 MCI: Failed to register driver\n");
+		return result;
+	}
+
+	printk(KERN_INFO "AT91RM9200 MCI initialized\n");
+
+	return 0;
+}
+
+/*
+ * Release the controller
+ */
+static void __exit at91rm9200_mci_exit(void)
+{
+	at91rm9200_mci_disable();
+	driver_unregister(&at91rm9200_mci_driver);
+
+	printk(KERN_INFO "AT91RM9200 MCI removed\n");
+}
+
+module_init(at91rm9200_mci_init);
+module_exit(at91rm9200_mci_exit);
+
+MODULE_DESCRIPTION("AT91RM9200 Multimedia Card Interface driver");
+MODULE_AUTHOR("Nick Randell");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.15.orig/drivers/mtd/devices/Kconfig linux-2.6.15/drivers/mtd/devices/Kconfig
--- linux-2.6.15.orig/drivers/mtd/devices/Kconfig	Wed Jan 11 09:19:03 2006
+++ linux-2.6.15/drivers/mtd/devices/Kconfig	Wed Jan 11 10:21:37 2006
@@ -255,5 +255,20 @@
 	  LinuxBIOS or if you need to recover a DiskOnChip Millennium on which
 	  you have managed to wipe the first block.
 
+config MTD_AT91_DATAFLASH
+	tristate "AT91RM9200 DataFlash AT45DBxxx"
+	depends on MTD && ARCH_AT91RM9200 && AT91_SPI
+        help
+          This enables access to the DataFlash chip (AT45DBxxx) on the
+          AT91RM9200-DK board.
+          If you have such a board, say 'Y'.
+
+config MTD_AT91_DATAFLASH_CARD
+	bool "Enable DataFlash Card support"
+        depends on MTD && ARCH_AT91RM9200 && AT91_SPI && MTD_AT91_DATAFLASH
+        help
+          This enables support for DataFlash cards
+
+
 endmenu
 
diff -urN linux-2.6.15.orig/drivers/mtd/devices/Makefile linux-2.6.15/drivers/mtd/devices/Makefile
--- linux-2.6.15.orig/drivers/mtd/devices/Makefile	Mon Oct 31 09:47:29 2005
+++ linux-2.6.15/drivers/mtd/devices/Makefile	Wed Jan 11 10:21:37 2006
@@ -23,3 +23,4 @@
 obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLKMTD)	+= blkmtd.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
+obj-$(CONFIG_MTD_AT91_DATAFLASH)+= at91_dataflash.o
diff -urN linux-2.6.15.orig/drivers/mtd/devices/at91_dataflash.c linux-2.6.15/drivers/mtd/devices/at91_dataflash.c
--- linux-2.6.15.orig/drivers/mtd/devices/at91_dataflash.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/mtd/devices/at91_dataflash.c	Wed Jan 11 11:59:13 2006
@@ -0,0 +1,612 @@
+/*
+ * Atmel DataFlash driver for Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/arch/pio.h>
+#include <asm/arch/at91_spi.h>
+
+#undef DEBUG_DATAFLASH
+
+#define DATAFLASH_MAX_DEVICES	4	/* max number of dataflash devices */
+#undef	DATAFLASH_ALWAYS_ADD_DEVICE	/* always add whole device when using partitions? */
+
+#define OP_READ_CONTINUOUS	0xE8
+#define OP_READ_PAGE		0xD2
+#define OP_READ_BUFFER1		0xD4
+#define OP_READ_BUFFER2		0xD6
+#define OP_READ_STATUS		0xD7
+
+#define OP_ERASE_PAGE		0x81
+#define OP_ERASE_BLOCK		0x50
+
+#define OP_TRANSFER_BUF1	0x53
+#define OP_TRANSFER_BUF2	0x55
+#define OP_COMPARE_BUF1		0x60
+#define OP_COMPARE_BUF2		0x61
+
+#define OP_PROGRAM_VIA_BUF1	0x82
+#define OP_PROGRAM_VIA_BUF2	0x85
+
+struct dataflash_local
+{
+	int spi;			/* SPI chip-select number */
+
+	unsigned int page_size;		/* number of bytes per page */
+	unsigned short page_offset;	/* page offset in flash address */
+};
+
+
+/* Detected DataFlash devices */
+static struct mtd_info* mtd_devices[DATAFLASH_MAX_DEVICES];
+static int nr_devices = 0;
+
+/* ......................................................................... */
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+static struct mtd_partition static_partitions_2M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 32 * 8 * 528,	/* 1st sector = 32 blocks * 8 pages * 528 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 6 * 32 * 8 * 528,	/* 6 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 9 sectors */
+	}
+};
+
+static struct mtd_partition static_partitions_4M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 64 * 8 * 528,	/* 1st sector = 64 blocks * 8 pages * 528 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 4 * 64 * 8 * 528,	/* 4 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 11 sectors */
+	}
+};
+
+static struct mtd_partition static_partitions_8M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 32 * 8 * 1056,	/* 1st sector = 32 blocks * 8 pages * 1056 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 5 * 32 * 8 * 1056,	/* 5 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 26 sectors */
+	}
+};
+
+static const char *part_probes[] = { "cmdlinepart", NULL, };
+
+#endif
+
+/* ......................................................................... */
+
+/* Allocate a single SPI transfer descriptor.  We're assuming that if multiple
+   SPI transfers occur at the same time, spi_access_bus() will serialize them.
+   If this is not valid, then either (i) each dataflash 'priv' structure
+   needs it's own transfer descriptor, (ii) we lock this one, or (iii) use
+   another mechanism.   */
+static struct spi_transfer_list* spi_transfer_desc;
+
+/*
+ * Perform a SPI transfer to access the DataFlash device.
+ */
+static int do_spi_transfer(int nr, char* tx, int tx_len, char* rx, int rx_len,
+		char* txnext, int txnext_len, char* rxnext, int rxnext_len)
+{
+	struct spi_transfer_list* list = spi_transfer_desc;
+
+	list->tx[0] = tx;	list->txlen[0] = tx_len;
+	list->rx[0] = rx;	list->rxlen[0] = rx_len;
+
+	list->tx[1] = txnext; 	list->txlen[1] = txnext_len;
+	list->rx[1] = rxnext;	list->rxlen[1] = rxnext_len;
+
+	list->nr_transfers = nr;
+
+	return spi_transfer(list);
+}
+
+/* ......................................................................... */
+
+/*
+ * Poll the DataFlash device until it is READY.
+ */
+static void at91_dataflash_waitready(void)
+{
+	char* command = kmalloc(2, GFP_KERNEL);
+
+	if (!command)
+		return;
+
+	do {
+		command[0] = OP_READ_STATUS;
+		command[1] = 0;
+
+		do_spi_transfer(1, command, 2, command, 2, NULL, 0, NULL, 0);
+	} while ((command[1] & 0x80) == 0);
+
+	kfree(command);
+}
+
+/*
+ * Return the status of the DataFlash device.
+ */
+static unsigned short at91_dataflash_status(void)
+{
+	unsigned short status;
+	char* command = kmalloc(2, GFP_KERNEL);
+
+	if (!command)
+		return 0;
+
+	command[0] = OP_READ_STATUS;
+	command[1] = 0;
+
+	do_spi_transfer(1, command, 2, command, 2, NULL, 0, NULL, 0);
+	status = command[1];
+
+	kfree(command);
+	return status;
+}
+
+/* ......................................................................... */
+
+/*
+ * Erase blocks of flash.
+ */
+static int at91_dataflash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int pageaddr;
+	char* command;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_erase: addr=%i len=%i\n", instr->addr, instr->len);
+#endif
+
+	/* Sanity checks */
+	if (instr->addr + instr->len > mtd->size)
+		return -EINVAL;
+	if ((instr->len % mtd->erasesize != 0) || (instr->len % priv->page_size != 0))
+		return -EINVAL;
+	if ((instr->addr % priv->page_size) != 0)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	while (instr->len > 0) {
+		/* Calculate flash page address */
+		pageaddr = (instr->addr / priv->page_size) << priv->page_offset;
+
+		command[0] = OP_ERASE_PAGE;
+		command[1] = (pageaddr & 0x00FF0000) >> 16;
+		command[2] = (pageaddr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+		printk("ERASE: (%x) %x %x %x [%i]\n", command[0], command[1], command[2], command[3], pageaddr);
+#endif
+
+		/* Send command to SPI device */
+		spi_access_bus(priv->spi);
+		do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+
+		at91_dataflash_waitready();		/* poll status until ready */
+		spi_release_bus(priv->spi);
+
+		instr->addr += priv->page_size;		/* next page */
+		instr->len -= priv->page_size;
+	}
+
+	kfree(command);
+
+	/* Inform MTD subsystem that erase is complete */
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+/*
+ * Read from the DataFlash device.
+ *   from   : Start offset in flash device
+ *   len    : Amount to read
+ *   retlen : About of data actually read
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int addr;
+	char* command;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_read: %lli .. %lli\n", from, from+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (from + len > mtd->size)
+		return -EINVAL;
+
+	/* Calculate flash page/byte address */
+	addr = (((unsigned)from / priv->page_size) << priv->page_offset) + ((unsigned)from % priv->page_size);
+
+	command = kmalloc(8, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	command[0] = OP_READ_CONTINUOUS;
+	command[1] = (addr & 0x00FF0000) >> 16;
+	command[2] = (addr & 0x0000FF00) >> 8;
+	command[3] = (addr & 0x000000FF);
+#ifdef DEBUG_DATAFLASH
+	printk("READ: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+
+	/* Send command to SPI device */
+	spi_access_bus(priv->spi);
+	do_spi_transfer(2, command, 8, command, 8, buf, len, buf, len);
+	spi_release_bus(priv->spi);
+
+	*retlen = len;
+	kfree(command);
+	return 0;
+}
+
+/*
+ * Write to the DataFlash device.
+ *   to     : Start offset in flash device
+ *   len    : Amount to write
+ *   retlen : Amount of data actually written
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int pageaddr, addr, offset, writelen;
+	size_t remaining;
+	u_char *writebuf;
+	unsigned short status;
+	int res = 0;
+	char* command;
+	char* tmpbuf = NULL;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_write: %lli .. %lli\n", to, to+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (to + len > mtd->size)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	pageaddr = ((unsigned)to / priv->page_size);
+	offset = ((unsigned)to % priv->page_size);
+	if (offset + len > priv->page_size)
+		writelen = priv->page_size - offset;
+	else
+		writelen = len;
+	writebuf = (u_char *)buf;
+	remaining = len;
+
+	/* Allocate temporary buffer */
+	tmpbuf = kmalloc(priv->page_size, GFP_KERNEL);
+	if (!tmpbuf) {
+		kfree(command);
+		return -ENOMEM;
+	}
+
+	/* Gain access to the SPI bus */
+	spi_access_bus(priv->spi);
+
+	while (remaining > 0) {
+#ifdef DEBUG_DATAFLASH
+		printk("write @ %i:%i len=%i\n", pageaddr, offset, writelen);
+#endif
+
+		/* (1) Transfer to Buffer1 */
+		if (writelen != priv->page_size) {
+			addr = pageaddr << priv->page_offset;
+			command[0] = OP_TRANSFER_BUF1;
+			command[1] = (addr & 0x00FF0000) >> 16;
+			command[2] = (addr & 0x0000FF00) >> 8;
+			command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+			printk("TRANSFER: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+			do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+			at91_dataflash_waitready();
+		}
+
+		/* (2) Program via Buffer1 */
+		addr = (pageaddr << priv->page_offset) + offset;
+		command[0] = OP_PROGRAM_VIA_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = (addr & 0x000000FF);
+#ifdef DEBUG_DATAFLASH
+		printk("PROGRAM: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(2, command, 4, command, 4, writebuf, writelen, tmpbuf, writelen);
+		at91_dataflash_waitready();
+
+		/* (3) Compare to Buffer1 */
+		addr = pageaddr << priv->page_offset;
+		command[0] = OP_COMPARE_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+		printk("COMPARE: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+		at91_dataflash_waitready();
+
+		/* Get result of the compare operation */
+		status = at91_dataflash_status();
+		if ((status & 0x40) == 1) {
+			printk("at91_dataflash: Write error on page %i\n", pageaddr);
+			remaining = 0;
+			res = -EIO;
+		}
+
+		remaining = remaining - writelen;
+		pageaddr++;
+		offset = 0;
+		writebuf += writelen;
+		*retlen += writelen;
+
+		if (remaining > priv->page_size)
+			writelen = priv->page_size;
+		else
+			writelen = remaining;
+	}
+
+	/* Release SPI bus */
+	spi_release_bus(priv->spi);
+
+	kfree(tmpbuf);
+	kfree(command);
+	return res;
+}
+
+/* ......................................................................... */
+
+/*
+ * Initialize and register DataFlash device with MTD subsystem.
+ */
+static int __init add_dataflash(int channel, char *name, int IDsize,
+		int nr_pages, int pagesize, int pageoffset)
+{
+	struct mtd_info *device;
+	struct dataflash_local *priv;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *mtd_parts = 0;
+	int mtd_parts_nr = 0;
+#endif
+
+	if (nr_devices >= DATAFLASH_MAX_DEVICES) {
+		printk(KERN_ERR "at91_dataflash: Too many devices detected\n");
+		return 0;
+	}
+
+	device = kmalloc(sizeof(struct mtd_info) + strlen(name) + 8, GFP_KERNEL);
+	if (!device)
+		return -ENOMEM;
+	memset(device, 0, sizeof(struct mtd_info));
+
+	device->name = (char *)&device[1];
+	sprintf(device->name, "%s.spi%d", name, channel);
+	device->size = nr_pages * pagesize;
+	device->erasesize = pagesize;
+	device->owner = THIS_MODULE;
+	device->type = MTD_DATAFLASH;
+	device->flags = MTD_CAP_NORFLASH;
+	device->erase = at91_dataflash_erase;
+	device->read = at91_dataflash_read;
+	device->write = at91_dataflash_write;
+
+	priv = (struct dataflash_local *) kmalloc(sizeof(struct dataflash_local), GFP_KERNEL);
+	if (!priv) {
+		kfree(device);
+		return -ENOMEM;
+	}
+	memset(priv, 0, sizeof(struct dataflash_local));
+
+	priv->spi = channel;
+	priv->page_size = pagesize;
+	priv->page_offset = pageoffset;
+	device->priv = priv;
+
+	mtd_devices[nr_devices] = device;
+	nr_devices++;
+	printk("at91_dataflash: %s detected [spi%i] (%i bytes)\n", name, channel, device->size);
+
+#ifdef CONFIG_MTD_PARTITIONS
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	mtd_parts_nr = parse_mtd_partitions(device, part_probes, &mtd_parts, 0);
+#endif
+	if (mtd_parts_nr <= 0) {
+		switch (IDsize) {
+			case SZ_2M:
+				mtd_parts = static_partitions_2M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_2M);
+				break;
+			case SZ_4M:
+				mtd_parts = static_partitions_4M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_4M);
+				break;
+			case SZ_8M:
+				mtd_parts = static_partitions_8M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_8M);
+				break;
+		}
+	}
+
+	if (mtd_parts_nr > 0) {
+#ifdef DATAFLASH_ALWAYS_ADD_DEVICE
+		add_mtd_device(device);
+#endif
+		return add_mtd_partitions(device, mtd_parts, mtd_parts_nr);
+	}
+#endif
+	return add_mtd_device(device);		/* add whole device */
+}
+
+/*
+ * Detect and initialize DataFlash device connected to specified SPI channel.
+ *
+ *   Device            Density         ID code                 Nr Pages        Page Size       Page offset
+ *   AT45DB011B        1Mbit   (128K)  xx0011xx (0x0c)         512             264             9
+ *   AT45DB021B        2Mbit   (256K)  xx0101xx (0x14)         1025            264             9
+ *   AT45DB041B        4Mbit   (512K)  xx0111xx (0x1c)         2048            264             9
+ *   AT45DB081B        8Mbit   (1M)    xx1001xx (0x24)         4096            264             9
+ *   AT45DB0161B       16Mbit  (2M)    xx1011xx (0x2c)         4096            528             10
+ *   AT45DB0321B       32Mbit  (4M)    xx1101xx (0x34)         8192            528             10
+ *   AT45DB0642        64Mbit  (8M)    xx1111xx (0x3c)         8192            1056            11
+ *   AT45DB1282        128Mbit (16M)   xx0100xx (0x10)         16384           1056            11
+ */
+static int __init at91_dataflash_detect(int channel)
+{
+	int res = 0;
+	unsigned short status;
+
+	spi_access_bus(channel);
+	status = at91_dataflash_status();
+	spi_release_bus(channel);
+	if (status != 0xff) {			/* no dataflash device there */
+		switch (status & 0x3c) {
+			case 0x0c:	/* 0 0 1 1 */
+				res = add_dataflash(channel, "AT45DB011B", SZ_128K, 512, 264, 9);
+				break;
+			case 0x14:	/* 0 1 0 1 */
+				res = add_dataflash(channel, "AT45DB021B", SZ_256K, 1025, 264, 9);
+				break;
+			case 0x1c:	/* 0 1 1 1 */
+				res = add_dataflash(channel, "AT45DB041B", SZ_512K, 2048, 264, 9);
+				break;
+			case 0x24:	/* 1 0 0 1 */
+				res = add_dataflash(channel, "AT45DB081B", SZ_1M, 4096, 264, 9);
+				break;
+			case 0x2c:	/* 1 0 1 1 */
+				res = add_dataflash(channel, "AT45DB161B", SZ_2M, 4096, 528, 10);
+				break;
+			case 0x34:	/* 1 1 0 1 */
+				res = add_dataflash(channel, "AT45DB321B", SZ_4M, 8192, 528, 10);
+				break;
+			case 0x3c:	/* 1 1 1 1 */
+				res = add_dataflash(channel, "AT45DB642", SZ_8M, 8192, 1056, 11);
+				break;
+// Currently unsupported since Atmel removed the "Main Memory Program via Buffer" commands.
+//			case 0x10:	/* 0 1 0 0 */
+//				res = add_dataflash(channel, "AT45DB1282", SZ_16M, 16384, 1056, 11);
+//				break;
+			default:
+				printk(KERN_ERR "at91_dataflash: Unknown device (%x)\n", status & 0x3c);
+		}
+	}
+
+	return res;
+}
+
+static int __init at91_dataflash_init(void)
+{
+	spi_transfer_desc = kmalloc(sizeof(struct spi_transfer_list), GFP_KERNEL);
+	if (!spi_transfer_desc)
+		return -ENOMEM;
+
+	/* DataFlash (SPI chip select 0) */
+	at91_dataflash_detect(0);
+
+#ifdef CONFIG_MTD_AT91_DATAFLASH_CARD
+	/* DataFlash card (SPI chip select 3) */
+	at91_dataflash_detect(3);
+#endif
+
+	return 0;
+}
+
+static void __exit at91_dataflash_exit(void)
+{
+	int i;
+
+	for (i = 0; i < DATAFLASH_MAX_DEVICES; i++) {
+		if (mtd_devices[i]) {
+#ifdef CONFIG_MTD_PARTITIONS
+			del_mtd_partitions(mtd_devices[i]);
+#else
+			del_mtd_device(mtd_devices[i]);
+#endif
+			kfree(mtd_devices[i]->priv);
+			kfree(mtd_devices[i]);
+		}
+	}
+	nr_devices = 0;
+	kfree(spi_transfer_desc);
+}
+
+
+module_init(at91_dataflash_init);
+module_exit(at91_dataflash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andrew Victor");
+MODULE_DESCRIPTION("DataFlash driver for Atmel AT91RM9200");
diff -urN linux-2.6.15.orig/drivers/mtd/maps/Kconfig linux-2.6.15/drivers/mtd/maps/Kconfig
--- linux-2.6.15.orig/drivers/mtd/maps/Kconfig	Wed Jan 11 09:19:03 2006
+++ linux-2.6.15/drivers/mtd/maps/Kconfig	Wed Jan 11 10:21:37 2006
@@ -639,5 +639,25 @@
 
 	  This selection automatically selects the map_ram driver.
 
+config MTD_CSB337
+	bool "Flash mapped on Cogent CSB337"
+	depends on MTD && MACH_CSB337
+	help
+	  This enables access to the flash chip on the Cogent CSB337
+	  single board computer.  The default behavior of the startup
+	  script the comes with BSPs for that board is to pass the address
+	  of a file romfs.img, which is assumed to be a romfs filesystem image
+	  to be used as the initial root filesystem.
+
+config MTD_CSB637
+	bool "Flash mapped on Cogent CSB637"
+	depends on MTD && MACH_CSB637
+	help
+	  This enables access to the flash chip on the Cogent CSB637
+	  single board computer.  The default behavior of the startup
+	  script the comes with BSPs for that board is to pass the address
+	  of a file romfs.img, which is assumed to be a romfs filesystem image
+	  to be used as the initial root filesystem.
+
 endmenu
 
diff -urN linux-2.6.15.orig/drivers/mtd/maps/Makefile linux-2.6.15/drivers/mtd/maps/Makefile
--- linux-2.6.15.orig/drivers/mtd/maps/Makefile	Wed Jan 11 09:19:03 2006
+++ linux-2.6.15/drivers/mtd/maps/Makefile	Wed Jan 11 10:21:37 2006
@@ -72,3 +72,5 @@
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_CSB337)	+= csbxxx.o
+obj-$(CONFIG_MTD_CSB637)	+= csbxxx.o
diff -urN linux-2.6.15.orig/drivers/mtd/maps/csbxxx.c linux-2.6.15/drivers/mtd/maps/csbxxx.c
--- linux-2.6.15.orig/drivers/mtd/maps/csbxxx.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/mtd/maps/csbxxx.c	Wed Jan 11 10:21:37 2006
@@ -0,0 +1,143 @@
+/*
+ * Map driver for the Cogent CSBxxx boards.
+ *
+ * Author:	Bill Gatliff
+ * Copyright:	(C) 2005 Bill Gatliff <bgat@billgatliff.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#define MTDID "flash00"
+#define MSG_PREFIX "csbxxx: "
+
+#if defined(CONFIG_MACH_CSB337) || defined(CONFIG_MACH_CSB637)
+#define WINDOW_ADDR 0x10000000
+#define WINDOW_SIZE 0x1000000
+#else
+#error TODO: the MTD map you need goes here...
+#endif
+
+/*
+ * default map definition
+ * (generally overridden on the command line)
+ */
+static struct mtd_partition csbxxx_partitions[] = {
+	{
+		.name		= "uMON flash",
+		.size		= WINDOW_SIZE,
+		.mask_flags	= MTD_WRITEABLE		/* force read-only */
+	},
+};
+
+static void csbxxx_map_inval_cache(struct map_info *map, unsigned long from, ssize_t len)
+{
+	consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
+}
+static struct map_info csbxxx_map = {
+	.size		= WINDOW_SIZE,
+	.phys		= WINDOW_ADDR,
+	.inval_cache	= csbxxx_map_inval_cache,
+	.bankwidth	= 2,
+	.name		= MTDID,
+};
+
+static const char *probes[] = { "cmdlinepart", NULL };
+
+static struct mtd_info *mymtd = 0;
+static int mtd_parts_nb = 0;
+static struct mtd_partition *mtd_parts = 0;
+
+static int __init init_csbxxx(void)
+{
+	int ret = 0;
+	const char *part_type = 0;
+
+	csbxxx_map.virt = ioremap(csbxxx_map.phys, WINDOW_SIZE);
+	if (!csbxxx_map.virt) {
+		printk(KERN_WARNING "Failed to ioremap %s, MTD disabled\n", csbxxx_map.name);
+		ret = -ENOMEM;
+		goto err;
+	}
+	csbxxx_map.cached = ioremap_cached(csbxxx_map.phys, WINDOW_SIZE);
+	if (!csbxxx_map.cached)
+		printk(KERN_WARNING "Failed to ioremap cached %s\n", csbxxx_map.name);
+
+	simple_map_init(&csbxxx_map);
+
+	printk(KERN_NOTICE "Probing %s at physical address 0x%08lx (%d-bit bankwidth)\n",
+			csbxxx_map.name, csbxxx_map.phys, csbxxx_map.bankwidth * 8);
+
+	mymtd = do_map_probe("cfi_probe", &csbxxx_map);
+	if (!mymtd)
+		goto err;
+
+	mymtd->owner = THIS_MODULE;
+
+	mtd_parts_nb = parse_mtd_partitions(mymtd, probes, &mtd_parts, 0);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (mtd_parts_nb > 0)
+		part_type = "command line";
+	else if (mtd_parts_nb == 0) {
+		mtd_parts = csbxxx_partitions;
+		mtd_parts_nb = ARRAY_SIZE(csbxxx_partitions);
+		part_type = "static";
+	}
+	else
+		goto err;
+
+	if (mtd_parts_nb == 0)
+		printk(KERN_NOTICE MSG_PREFIX "no partition info available\n");
+	else {
+		printk(KERN_NOTICE MSG_PREFIX "using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, mtd_parts, mtd_parts_nb);
+	}
+#else
+	add_mtd_device(mymtd);
+#endif
+
+	return 0;
+
+err:
+	if (csbxxx_map.virt)
+		iounmap(csbxxx_map.virt);
+	if (csbxxx_map.cached)
+		iounmap(csbxxx_map.cached);
+	if (!ret)
+		ret = -EIO;
+
+	return ret;
+}
+
+static void __exit cleanup_csbxxx(void)
+{
+	if (!mymtd)
+		return;
+
+	del_mtd_partitions(mymtd);
+
+	map_destroy(mymtd);
+	iounmap((void *)csbxxx_map.virt);
+	if (csbxxx_map.cached)
+		iounmap(csbxxx_map.cached);
+}
+
+module_init(init_csbxxx);
+module_exit(cleanup_csbxxx);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Bill Gatliff <bgat@billgatliff.com>");
+MODULE_DESCRIPTION("MTD map driver for Cogent CSBXXX");
diff -urN linux-2.6.15.orig/drivers/mtd/nand/Kconfig linux-2.6.15/drivers/mtd/nand/Kconfig
--- linux-2.6.15.orig/drivers/mtd/nand/Kconfig	Wed Jan 11 09:19:05 2006
+++ linux-2.6.15/drivers/mtd/nand/Kconfig	Wed Jan 11 10:21:37 2006
@@ -190,5 +190,11 @@
 	help
 	  The simulator may simulate verious NAND flash chips for the
 	  MTD nand layer.
- 
+
+config MTD_NAND_AT91
+	bool "AT91 NAND Access (Smart Media)"
+	depends on MTD_NAND && ARCH_AT91RM9200 && EXPERIMENTAL
+	help
+	  Enables Access to the Smart Media Card interface on the AT91RM9200DK
+
 endmenu
diff -urN linux-2.6.15.orig/drivers/mtd/nand/Makefile linux-2.6.15/drivers/mtd/nand/Makefile
--- linux-2.6.15.orig/drivers/mtd/nand/Makefile	Mon Oct 31 09:49:51 2005
+++ linux-2.6.15/drivers/mtd/nand/Makefile	Wed Jan 11 10:21:37 2006
@@ -18,5 +18,6 @@
 obj-$(CONFIG_MTD_NAND_RTC_FROM4)	+= rtc_from4.o
 obj-$(CONFIG_MTD_NAND_SHARPSL)		+= sharpsl.o
 obj-$(CONFIG_MTD_NAND_NANDSIM)		+= nandsim.o
+obj-$(CONFIG_MTD_NAND_AT91)		+= at91_nand.o
 
 nand-objs = nand_base.o nand_bbt.o
diff -urN linux-2.6.15.orig/drivers/mtd/nand/at91_nand.c linux-2.6.15/drivers/mtd/nand/at91_nand.c
--- linux-2.6.15.orig/drivers/mtd/nand/at91_nand.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/mtd/nand/at91_nand.c	Wed Jan 11 11:45:31 2006
@@ -0,0 +1,367 @@
+/*
+ * drivers/at91/mtd/at91_nand.c
+ *
+ *  Copyright (C) 2003 Rick Bronson
+ *
+ *  Derived from drivers/mtd/nand/autcpu12.c
+ *	 Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
+ *
+ *  Derived from drivers/mtd/spia.c
+ *	 Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/sizes.h>
+
+#include <asm/arch/pio.h>
+
+#define AT91_SMART_MEDIA_ALE (1 << 22)  /* our ALE is AD22 */
+#define AT91_SMART_MEDIA_CLE (1 << 21)  /* our CLE is AD21 */
+/*
+ * MTD structure for AT91 board
+ */
+
+static struct mtd_info *at91_mtd = NULL;
+
+static int at91_fio_base;
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+/*
+ * Define partitions for flash devices
+ */
+
+static struct mtd_partition partition_info32k[] = {
+	{
+		.name	= "AT91 NAND partition 1, kernel",
+		.offset	= 0,
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 2, filesystem",
+		.offset	= 1 * SZ_1M,
+		.size	= 16 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3a, storage",
+		.offset	= (1 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3b, storage",
+		.offset	= (2 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3c, storage",
+		.offset	= (3 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3d, storage",
+		.offset	= (4 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+};
+
+static struct mtd_partition partition_info64k[] = {
+	{
+		.name	= "AT91 NAND partition 1, kernel",
+		.offset	= 0,
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 2, filesystem",
+		.offset	= 1 * SZ_1M,
+		.size	= 16 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3, storage",
+		.offset	= (1 * SZ_1M) + (16 * SZ_1M),
+		.size	= 47 * SZ_1M
+	},
+};
+
+#endif
+
+/*
+ * Hardware specific access to control-lines
+ */
+static void at91_hwcontrol (struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *my_nand = mtd->priv;
+	switch(cmd)
+	{
+	case NAND_CTL_SETCLE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base + AT91_SMART_MEDIA_CLE);
+		break;
+	case NAND_CTL_CLRCLE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+		break;
+	case NAND_CTL_SETALE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base + AT91_SMART_MEDIA_ALE);
+		break;
+	case NAND_CTL_CLRALE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+		break;
+	case NAND_CTL_SETNCE:
+		break;
+	case NAND_CTL_CLRNCE:
+		break;
+	}
+}
+
+static void at91_nand_command_largepage (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+{
+	register struct nand_chip *my_nand = mtd->priv;
+
+	/* Begin command latch cycle */
+	register unsigned long NAND_IO_ADDR = (unsigned long)(my_nand->IO_ADDR_W + AT91_SMART_MEDIA_CLE);
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command == NAND_CMD_READ1) {
+		command = NAND_CMD_READ0;
+		column += 256;
+	} else if (command == NAND_CMD_READOOB) {
+		command = NAND_CMD_READ0;
+		column += 2048;
+	}
+	writeb (command, NAND_IO_ADDR);
+
+	/* Set ALE and clear CLE to start address cycle */
+	NAND_IO_ADDR = at91_fio_base;
+
+	if (column != -1 || page_addr != -1)
+		NAND_IO_ADDR += AT91_SMART_MEDIA_ALE;
+
+	/* Serially input address */
+	if (column != -1) {
+		writeb (column, NAND_IO_ADDR);
+		writeb ((unsigned char) ((column >> 8) & 0x0f), NAND_IO_ADDR);
+	}
+	if (page_addr != -1) {
+		writeb ((unsigned char) (page_addr & 0xff), NAND_IO_ADDR);
+		writeb ((unsigned char) ((page_addr >> 8) & 0xff), NAND_IO_ADDR);
+	}
+
+	if (command == NAND_CMD_READ0) {
+		NAND_IO_ADDR = (unsigned long)(my_nand->IO_ADDR_W + AT91_SMART_MEDIA_CLE);
+		writeb (0x30, NAND_IO_ADDR);
+	}
+
+	/* wait until command is processed */
+	while (!my_nand->dev_ready(mtd))
+		;
+}
+
+/*
+ * Send command to NAND device
+ */
+static void at91_nand_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+{
+	register struct nand_chip *my_nand = mtd->priv;
+
+	/* Begin command latch cycle */
+	register unsigned long NAND_IO_ADDR = (unsigned long)(my_nand->IO_ADDR_W + AT91_SMART_MEDIA_CLE);
+
+	if (mtd->oobblock > 512 && command != NAND_CMD_READID) {
+		at91_nand_command_largepage(mtd, command, column, page_addr);
+		return;
+	}
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command != NAND_CMD_SEQIN)
+		writeb (command, NAND_IO_ADDR);
+	else {
+		if (mtd->oobblock == 256 && column >= 256) {
+			column -= 256;
+			writeb (NAND_CMD_RESET, NAND_IO_ADDR);
+			writeb (NAND_CMD_READOOB, NAND_IO_ADDR);
+			writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+		else
+			if (mtd->oobblock == 512 && column >= 256) {
+				if (column < 512) {
+					column -= 256;
+					writeb (NAND_CMD_READ1, NAND_IO_ADDR);
+					writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+				} else {
+					column -= 512;
+					writeb (NAND_CMD_READOOB, NAND_IO_ADDR);
+					writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+				}
+			} else {
+				writeb (NAND_CMD_READ0, NAND_IO_ADDR);
+				writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+	}
+
+	/* Set ALE and clear CLE to start address cycle */
+	NAND_IO_ADDR = at91_fio_base;
+
+	if (column != -1 || page_addr != -1)
+		NAND_IO_ADDR += AT91_SMART_MEDIA_ALE;
+
+	/* Serially input address */
+	if (column != -1)
+		writeb (column, NAND_IO_ADDR);
+	if (page_addr != -1) {
+		writeb ((unsigned char) (page_addr & 0xff), NAND_IO_ADDR);
+		writeb ((unsigned char) ((page_addr >> 8) & 0xff), NAND_IO_ADDR);
+		/* One more address cycle for higher density devices */
+		if (mtd->size & 0x0c000000) {
+			writeb ((unsigned char) ((page_addr >> 16) & 0x0f), NAND_IO_ADDR);
+		}
+	}
+
+	/* wait until command is processed */
+	while (!my_nand->dev_ready(mtd))
+		;
+}
+
+/*
+ * Read the Device Ready pin.
+ */
+static int at91_device_ready (struct mtd_info *mtd)
+{
+	return AT91_PIO_SmartMedia_RDY();
+}
+/*
+ * Main initialization routine
+ */
+static int __init at91_init (void)
+{
+	struct nand_chip *my_nand;
+	unsigned int csa;
+	int err = 0;
+
+	/* Allocate memory for MTD device structure and private data */
+	at91_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip), GFP_KERNEL);
+	if (!at91_mtd) {
+		printk ("Unable to allocate AT91 NAND MTD device structure.\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* map physical adress */
+	at91_fio_base = (unsigned long) ioremap(AT91_SMARTMEDIA_BASE, SZ_8M);
+	if(!at91_fio_base) {
+		printk("ioremap AT91 NAND failed\n");
+		err = -EIO;
+		goto out_mtd;
+	}
+
+	/* Get pointer to private data */
+	my_nand = (struct nand_chip *) (&at91_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) at91_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) my_nand, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	at91_mtd->priv = my_nand;
+
+	/* Set address of NAND IO lines */
+	my_nand->IO_ADDR_R = (void __iomem *)(at91_fio_base);
+	my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+	my_nand->hwcontrol = at91_hwcontrol;
+	my_nand->dev_ready = at91_device_ready;
+	my_nand->cmdfunc = at91_nand_command;	/* we need our own */
+	my_nand->eccmode = NAND_ECC_SOFT;	/* enable ECC */
+	/* 20 us command delay time */
+	my_nand->chip_delay = 20;
+
+	/* Setup Smart Media, first enable the address range of CS3 */
+	csa = at91_sys_read(AT91_EBI_CSA);
+	at91_sys_write(AT91_EBI_CSA, csa | AT91_EBI_CS3A_SMC_SMARTMEDIA);
+
+	/* set the bus interface characteristics */
+	at91_sys_write(AT91_SMC_CSR(3), AT91_SMC_ACSS_STD | AT91_SMC_DBW_8 | AT91_SMC_WSEN
+				| AT91_SMC_NWS_(5)
+				| AT91_SMC_TDF_(1)
+				| AT91_SMC_RWSETUP_(0)	/* tDS Data Set up Time 30 - ns */
+				| AT91_SMC_RWHOLD_(1)	/* tDH Data Hold Time 20 - ns */
+	);
+			
+	AT91_CfgPIO_SmartMedia();
+
+	if (AT91_PIO_SmartMedia_CardDetect())
+		printk ("No ");
+	printk ("SmartMedia card inserted.\n");
+
+	/* Scan to find existance of the device */
+	if (nand_scan (at91_mtd, 1)) {
+		err = -ENXIO;
+		goto out_ior;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/* Register the partitions */
+	switch(at91_mtd->size)
+	{
+	case SZ_32M:
+		err = add_mtd_partitions(at91_mtd, partition_info32k,
+				ARRAY_SIZE (partition_info32k));
+		break;
+	case SZ_64M:
+		err = add_mtd_partitions(at91_mtd, partition_info64k,
+				ARRAY_SIZE (partition_info64k));
+		break;
+	default:
+		printk ("Unsupported SmartMedia device\n");
+		err = -ENXIO;
+		goto out_cac;
+	}
+#else
+	err = add_mtd_device(at91_mtd);
+#endif
+	goto out;
+
+ out_cac:
+ out_ior:
+	iounmap((void *)at91_fio_base);
+ out_mtd:
+	kfree (at91_mtd);
+ out:
+	return err;
+}
+
+/*
+ * Clean up routine
+ */
+static void __exit at91_cleanup (void)
+{
+	/* Unregister partitions */
+	del_mtd_partitions(at91_mtd);
+
+	/* Unregister the device */
+	del_mtd_device (at91_mtd);
+
+	/* unmap physical adress */
+	iounmap((void *)at91_fio_base);
+
+	/* Free the MTD device structure */
+	kfree (at91_mtd);
+}
+
+module_init(at91_init);
+module_exit(at91_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Rick Bronson");
+MODULE_DESCRIPTION("Glue layer for SmartMediaCard on ATMEL AT91RM9200");
diff -urN linux-2.6.15.orig/drivers/net/arm/Kconfig linux-2.6.15/drivers/net/arm/Kconfig
--- linux-2.6.15.orig/drivers/net/arm/Kconfig	Mon Oct 31 09:44:25 2005
+++ linux-2.6.15/drivers/net/arm/Kconfig	Wed Jan 11 10:58:36 2006
@@ -44,3 +44,12 @@
 	  will generate a suitable hw address based on the board serial
 	  number (MTD support is required for this). Otherwise you will
 	  need to set a suitable hw address using ifconfig.
+
+config ARM_AT91_ETHER
+	tristate "AT91RM9200 Ethernet support"
+	depends on NET_ETHERNET && ARM && ARCH_AT91RM9200
+	select CRC32
+	select MII
+	help
+	  If you wish to compile a kernel for the AT91RM9200 and enable
+	  ethernet support, then you should always answer Y to this.
diff -urN linux-2.6.15.orig/drivers/net/arm/Makefile linux-2.6.15/drivers/net/arm/Makefile
--- linux-2.6.15.orig/drivers/net/arm/Makefile	Sun Apr  4 05:37:27 2004
+++ linux-2.6.15/drivers/net/arm/Makefile	Wed Jan 11 10:58:36 2006
@@ -8,3 +8,4 @@
 obj-$(CONFIG_ARM_ETHERH)	+= etherh.o
 obj-$(CONFIG_ARM_ETHER3)	+= ether3.o
 obj-$(CONFIG_ARM_ETHER1)	+= ether1.o
+obj-$(CONFIG_ARM_AT91_ETHER)	+= at91_ether.o
diff -urN linux-2.6.15.orig/drivers/net/arm/at91_ether.c linux-2.6.15/drivers/net/arm/at91_ether.c
--- linux-2.6.15.orig/drivers/net/arm/at91_ether.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/net/arm/at91_ether.c	Wed Jan 11 10:58:36 2006
@@ -0,0 +1,1054 @@
+/*
+ * Ethernet driver for the Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) 2003 SAN People (Pty) Ltd
+ *
+ * Based on an earlier Atmel EMAC macrocell driver by Atmel and Lineo Inc.
+ * Initial version by Rick Bronson 01/11/2003
+ *
+ * Intel LXT971A PHY support by Christopher Bahns & David Knickerbocker
+ *   (Polaroid Corporation)
+ *
+ * Realtek RTL8201(B)L PHY support by Roman Avramenko <roman@imsystems.ru>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/mii.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/dma-mapping.h>
+#include <linux/crc32.h>
+#include <linux/ethtool.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/at91rm9200_emac.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/board.h>
+
+#include "at91_ether.h"
+
+#define DRV_NAME	"at91_ether"
+#define DRV_VERSION	"1.0"
+
+static struct net_device *at91_dev = NULL;
+
+/* ..................................................................... */
+
+/*
+ * Read from a EMAC register.
+ */
+static inline unsigned long at91_emac_read(unsigned int reg)
+{
+	void __iomem *emac_base = (void __iomem *)AT91_VA_BASE_EMAC;
+	
+	return __raw_readl(emac_base + reg);
+}
+
+/*
+ * Write to a EMAC register.
+ */
+static inline void at91_emac_write(unsigned int reg, unsigned long value)
+{
+	void __iomem *emac_base = (void __iomem *)AT91_VA_BASE_EMAC;
+	
+	__raw_writel(value, emac_base + reg);
+}
+
+/* ........................... PHY INTERFACE ........................... */
+
+/*
+ * Enable the MDIO bit in MAC control register
+ * When not called from an interrupt-handler, access to the PHY must be
+ *  protected by a spinlock.
+ */
+static void enable_mdi(void)
+{
+	unsigned long ctl;
+	
+	ctl = at91_emac_read(AT91_EMAC_CTL);
+	at91_emac_write(AT91_EMAC_CTL, ctl | AT91_EMAC_MPE);	/* enable management port */
+}
+
+/*
+ * Disable the MDIO bit in the MAC control register
+ */
+static void disable_mdi(void)
+{
+	unsigned long ctl;
+	
+	ctl = at91_emac_read(AT91_EMAC_CTL);
+	at91_emac_write(AT91_EMAC_CTL, ctl & ~AT91_EMAC_MPE);	/* disable management port */
+}
+
+/*
+ * Write value to the a PHY register
+ * Note: MDI interface is assumed to already have been enabled.
+ */
+static void write_phy(unsigned char phy_addr, unsigned char address, unsigned int value)
+{
+	at91_emac_write(AT91_EMAC_MAN, AT91_EMAC_MAN_802_3 | AT91_EMAC_RW_W
+		| ((phy_addr & 0x1f) << 23) | (address << 18) | (value & AT91_EMAC_DATA));
+
+	/* Wait until IDLE bit in Network Status register is cleared */
+	// TODO: Enforce some maximum loop-count?
+	while (!(at91_emac_read(AT91_EMAC_SR) & AT91_EMAC_SR_IDLE)) { barrier(); }
+}
+
+/*
+ * Read value stored in a PHY register.
+ * Note: MDI interface is assumed to already have been enabled.
+ */
+static void read_phy(unsigned char phy_addr, unsigned char address, unsigned int *value)
+{
+	at91_emac_write(AT91_EMAC_MAN, AT91_EMAC_MAN_802_3 | AT91_EMAC_RW_R
+		| ((phy_addr & 0x1f) << 23) | (address << 18));
+
+	/* Wait until IDLE bit in Network Status register is cleared */
+	// TODO: Enforce some maximum loop-count?
+	while (!(at91_emac_read(AT91_EMAC_SR) & AT91_EMAC_SR_IDLE)) { barrier(); }
+
+	*value = at91_emac_read(AT91_EMAC_MAN) & AT91_EMAC_DATA;
+}
+
+/* ........................... PHY MANAGEMENT .......................... */
+
+/*
+ * Access the PHY to determine the current Link speed and Mode, and update the
+ * MAC accordingly.
+ * If no link or auto-negotiation is busy, then no changes are made.
+ * Returns:  0 : OK
+ *          -1 : No link
+ *          -2 : AutoNegotiation still in progress
+ */
+static int update_linkspeed(struct net_device *dev) {
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	unsigned int bmsr, bmcr, lpa, mac_cfg;
+	unsigned int speed, duplex;
+
+	/* Link status is latched, so read twice to get current value */
+	read_phy(lp->phy_address, MII_BMSR, &bmsr);
+	read_phy(lp->phy_address, MII_BMSR, &bmsr);
+	if (!(bmsr & BMSR_LSTATUS))
+		return -1;			/* no link */
+
+	read_phy(lp->phy_address, MII_BMCR, &bmcr);
+	if (bmcr & BMCR_ANENABLE) {				/* AutoNegotiation is enabled */
+		if (!(bmsr & BMSR_ANEGCOMPLETE)) return -2;	/* auto-negotitation in progress */
+
+		read_phy(lp->phy_address, MII_LPA, &lpa);
+		if ((lpa & LPA_100FULL) || (lpa & LPA_100HALF)) speed = SPEED_100;
+		else speed = SPEED_10;
+		if ((lpa & LPA_100FULL) || (lpa & LPA_10FULL)) duplex = DUPLEX_FULL;
+		else duplex = DUPLEX_HALF;
+	} else {
+		speed = (bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10;
+		duplex = (bmcr & BMCR_FULLDPLX) ? DUPLEX_FULL : DUPLEX_HALF;
+	}
+
+	/* Update the MAC */
+	mac_cfg = at91_emac_read(AT91_EMAC_CFG) & ~(AT91_EMAC_SPD | AT91_EMAC_FD);
+	if (speed == SPEED_100) {
+		if (duplex == DUPLEX_FULL)		/* 100 Full Duplex */
+			mac_cfg |= AT91_EMAC_SPD | AT91_EMAC_FD;
+		else					/* 100 Half Duplex */
+			mac_cfg |= AT91_EMAC_SPD;
+	} else {
+		if (duplex == DUPLEX_FULL)		/* 10 Full Duplex */
+			mac_cfg |= AT91_EMAC_FD;
+		else {}					/* 10 Half Duplex */
+	}
+	at91_emac_write(AT91_EMAC_CFG, mac_cfg);
+
+	printk(KERN_INFO "%s: Link now %i-%s\n", dev->name, speed, (duplex == DUPLEX_FULL) ? "FullDuplex" : "HalfDuplex");
+	return 0;
+}
+
+/*
+ * Handle interrupts from the PHY
+ */
+static irqreturn_t at91ether_phy_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	int status;
+	unsigned int phy;
+
+	/*
+	 * This hander is triggered on both edges, but the PHY chips expect
+	 * level-triggering.  We therefore have to check if the PHY actually has
+	 * an IRQ pending.
+	 */
+	enable_mdi();
+	if ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {
+		read_phy(lp->phy_address, MII_DSINTR_REG, &phy);	/* ack interrupt in Davicom PHY */
+		if (!(phy & (1 << 0)))
+			goto done;
+	}
+	else if (lp->phy_type == MII_LXT971A_ID) {
+		read_phy(lp->phy_address, MII_ISINTS_REG, &phy);	/* ack interrupt in Intel PHY */
+		if (!(phy & (1 << 2)))
+			goto done;
+	}
+	else if (lp->phy_type == MII_BCM5221_ID) {
+		read_phy(lp->phy_address, MII_BCMINTR_REG, &phy);	/* ack interrupt in Broadcom PHY */
+		if (!(phy & (1 << 0)))
+			goto done;
+	}
+	else if (lp->phy_type == MII_KS8721_ID) {
+		read_phy(lp->phy_address, MII_TPISTATUS, &phy);		/* ack interrupt in Micrel PHY */
+		if (!(phy & ((1 << 2) | 1)))
+			goto done;
+	}
+
+	status = update_linkspeed(dev);
+	if (status == -1) {			/* link is down */
+		netif_carrier_off(dev);
+		printk(KERN_INFO "%s: Link down.\n", dev->name);
+	} else if (status == -2) {		/* auto-negotiation in progress */
+		/* Do nothing - another interrupt generated when negotiation complete */
+	} else {				/* link is operational */
+		netif_carrier_on(dev);
+	}
+
+done:
+	disable_mdi();
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Initialize and enable the PHY interrupt for link-state changes
+ */
+static void enable_phyirq(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	unsigned int dsintr, irq_number;
+	int status;
+
+	if (lp->phy_type == MII_RTL8201_ID)	/* RTL8201 does not have an interrupt */
+		return;
+	if (lp->phy_type == MII_DP83847_ID)	/* DP83847 does not have an interrupt */
+		return;
+	if (lp->phy_type == MII_AC101L_ID)	/* AC101L interrupt not supported yet */
+		return;
+
+	irq_number = lp->board_data.phy_irq_pin;
+	status = request_irq(irq_number, at91ether_phy_interrupt, 0, dev->name, dev);
+	if (status) {
+		printk(KERN_ERR "at91_ether: PHY IRQ %d request failed - status %d!\n", irq_number, status);
+		return;
+	}
+
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+
+	if ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {	/* for Davicom PHY */
+		read_phy(lp->phy_address, MII_DSINTR_REG, &dsintr);
+		dsintr = dsintr & ~0xf00;		/* clear bits 8..11 */
+		write_phy(lp->phy_address, MII_DSINTR_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_LXT971A_ID) {	/* for Intel PHY */
+		read_phy(lp->phy_address, MII_ISINTE_REG, &dsintr);
+		dsintr = dsintr | 0xf2;			/* set bits 1, 4..7 */
+		write_phy(lp->phy_address, MII_ISINTE_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_BCM5221_ID) {	/* for Broadcom PHY */
+		dsintr = (1 << 15) | ( 1 << 14);
+		write_phy(lp->phy_address, MII_BCMINTR_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_KS8721_ID) {	/* for Micrel PHY */
+		dsintr = (1 << 10) | ( 1 << 8);
+		write_phy(lp->phy_address, MII_TPISTATUS, dsintr);
+	}
+
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+}
+
+/*
+ * Disable the PHY interrupt
+ */
+static void disable_phyirq(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	unsigned int dsintr;
+	unsigned int irq_number;
+
+	if (lp->phy_type == MII_RTL8201_ID) 	/* RTL8201 does not have an interrupt */
+		return;
+	if (lp->phy_type == MII_DP83847_ID)	/* DP83847 does not have an interrupt */
+		return;
+	if (lp->phy_type == MII_AC101L_ID)	/* AC101L interrupt not supported yet */
+		return;
+
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+
+	if ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {	/* for Davicom PHY */
+		read_phy(lp->phy_address, MII_DSINTR_REG, &dsintr);
+		dsintr = dsintr | 0xf00;			/* set bits 8..11 */
+		write_phy(lp->phy_address, MII_DSINTR_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_LXT971A_ID) {	/* for Intel PHY */
+		read_phy(lp->phy_address, MII_ISINTE_REG, &dsintr);
+		dsintr = dsintr & ~0xf2;			/* clear bits 1, 4..7 */
+		write_phy(lp->phy_address, MII_ISINTE_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_BCM5221_ID) {	/* for Broadcom PHY */
+		read_phy(lp->phy_address, MII_BCMINTR_REG, &dsintr);
+		dsintr = ~(1 << 14);
+		write_phy(lp->phy_address, MII_BCMINTR_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_KS8721_ID) {	/* for Micrel PHY */
+		read_phy(lp->phy_address, MII_TPISTATUS, &dsintr);
+		dsintr = ~((1 << 10) | (1 << 8));
+		write_phy(lp->phy_address, MII_TPISTATUS, dsintr);
+	}
+
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+
+	irq_number = lp->board_data.phy_irq_pin;
+	free_irq(irq_number, dev);			/* Free interrupt handler */
+}
+
+/*
+ * Perform a software reset of the PHY.
+ */
+#if 0
+static void reset_phy(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	unsigned int bmcr;
+
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+
+	/* Perform PHY reset */
+	write_phy(lp->phy_address, MII_BMCR, BMCR_RESET);
+
+	/* Wait until PHY reset is complete */
+	do {
+		read_phy(lp->phy_address, MII_BMCR, &bmcr);
+	} while (!(bmcr && BMCR_RESET));
+
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+}
+#endif
+
+/* ......................... ADDRESS MANAGEMENT ........................ */
+
+/*
+ * NOTE: Your bootloader must always set the MAC address correctly before
+ * booting into Linux.
+ *
+ * - It must always set the MAC address after reset, even if it doesn't
+ *   happen to access the Ethernet while it's booting.  Some versions of
+ *   U-Boot on the AT91RM9200-DK do not do this.
+ *
+ * - Likewise it must store the addresses in the correct byte order.
+ *   MicroMonitor (uMon) on the CSB337 does this incorrectly (and
+ *   continues to do so, for bug-compatibility).
+ */
+
+static short __init unpack_mac_address(struct net_device *dev, unsigned int hi, unsigned int lo)
+{
+	char addr[6];
+
+	if (machine_is_csb337()) {
+		addr[5] = (lo & 0xff);			/* The CSB337 bootloader stores the MAC the wrong-way around */
+		addr[4] = (lo & 0xff00) >> 8;
+		addr[3] = (lo & 0xff0000) >> 16;
+		addr[2] = (lo & 0xff000000) >> 24;
+		addr[1] = (hi & 0xff);
+		addr[0] = (hi & 0xff00) >> 8;
+	}
+	else {
+		addr[0] = (lo & 0xff);
+		addr[1] = (lo & 0xff00) >> 8;
+		addr[2] = (lo & 0xff0000) >> 16;
+		addr[3] = (lo & 0xff000000) >> 24;
+		addr[4] = (hi & 0xff);
+		addr[5] = (hi & 0xff00) >> 8;
+	}
+
+	if (is_valid_ether_addr(addr)) {
+		memcpy(dev->dev_addr, &addr, 6);
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Set the ethernet MAC address in dev->dev_addr
+ */
+static void __init get_mac_address(struct net_device *dev)
+{
+	/* Check Specific-Address 1 */
+	if (unpack_mac_address(dev, at91_emac_read(AT91_EMAC_SA1H), at91_emac_read(AT91_EMAC_SA1L)))
+		return;
+	/* Check Specific-Address 2 */
+	if (unpack_mac_address(dev, at91_emac_read(AT91_EMAC_SA2H), at91_emac_read(AT91_EMAC_SA2L)))
+		return;
+	/* Check Specific-Address 3 */
+	if (unpack_mac_address(dev, at91_emac_read(AT91_EMAC_SA3H), at91_emac_read(AT91_EMAC_SA3L)))
+		return;
+	/* Check Specific-Address 4 */
+	if (unpack_mac_address(dev, at91_emac_read(AT91_EMAC_SA4H), at91_emac_read(AT91_EMAC_SA4L)))
+		return;
+
+	printk(KERN_ERR "at91_ether: Your bootloader did not configure a MAC address.\n");
+}
+
+/*
+ * Program the hardware MAC address from dev->dev_addr.
+ */
+static void update_mac_address(struct net_device *dev)
+{
+	at91_emac_write(AT91_EMAC_SA1L, (dev->dev_addr[3] << 24) | (dev->dev_addr[2] << 16) | (dev->dev_addr[1] << 8) | (dev->dev_addr[0]));
+	at91_emac_write(AT91_EMAC_SA1H, (dev->dev_addr[5] << 8) | (dev->dev_addr[4]));
+
+	at91_emac_write(AT91_EMAC_SA2L, 0);
+	at91_emac_write(AT91_EMAC_SA2H, 0);
+}
+
+/*
+ * Store the new hardware address in dev->dev_addr, and update the MAC.
+ */
+static int set_mac_address(struct net_device *dev, void* addr)
+{
+	struct sockaddr *address = addr;
+
+	if (!is_valid_ether_addr(address->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(dev->dev_addr, address->sa_data, dev->addr_len);
+	update_mac_address(dev);
+
+	printk("%s: Setting MAC address to %02x:%02x:%02x:%02x:%02x:%02x\n", dev->name,
+		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	return 0;
+}
+
+/*
+ * Add multicast addresses to the internal multicast-hash table.
+ */
+static void at91ether_sethashtable(struct net_device *dev)
+{
+	struct dev_mc_list *curr;
+	unsigned char mc_filter[2];
+	unsigned int i, bitnr;
+
+	mc_filter[0] = mc_filter[1] = 0;
+
+	curr = dev->mc_list;
+	for (i = 0; i < dev->mc_count; i++, curr = curr->next) {
+		if (!curr) break;	/* unexpected end of list */
+
+		bitnr = ether_crc(ETH_ALEN, curr->dmi_addr) >> 26;
+		mc_filter[bitnr >> 5] |= 1 << (bitnr & 31);
+	}
+
+	at91_emac_write(AT91_EMAC_HSH, mc_filter[1]);
+	at91_emac_write(AT91_EMAC_HSL, mc_filter[0]);
+}
+
+/*
+ * Enable/Disable promiscuous and multicast modes.
+ */
+static void at91ether_set_rx_mode(struct net_device *dev)
+{
+	unsigned long cfg;
+	
+	cfg = at91_emac_read(AT91_EMAC_CFG);
+
+	if (dev->flags & IFF_PROMISC)			/* Enable promiscuous mode */
+		cfg |= AT91_EMAC_CAF;
+	else if (dev->flags & (~IFF_PROMISC))		/* Disable promiscuous mode */
+		cfg &= ~AT91_EMAC_CAF;
+
+	if (dev->flags & IFF_ALLMULTI) {		/* Enable all multicast mode */
+		at91_emac_write(AT91_EMAC_HSH, -1);
+		at91_emac_write(AT91_EMAC_HSL, -1);
+		cfg |= AT91_EMAC_MTI;
+	} else if (dev->mc_count > 0) {			/* Enable specific multicasts */
+		at91ether_sethashtable(dev);
+		cfg |= AT91_EMAC_MTI;
+	} else if (dev->flags & (~IFF_ALLMULTI)) {	/* Disable all multicast mode */
+		at91_emac_write(AT91_EMAC_HSH, 0);
+		at91_emac_write(AT91_EMAC_HSL, 0);
+		cfg &= ~AT91_EMAC_MTI;
+	}
+	
+	at91_emac_write(AT91_EMAC_CFG, cfg);
+}
+
+
+/* ......................... ETHTOOL SUPPORT ........................... */
+
+
+static int mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	unsigned int value;
+
+	read_phy(phy_id, location, &value);
+	return value;
+}
+
+static void mdio_write(struct net_device *dev, int phy_id, int location, int value)
+{
+	write_phy(phy_id, location, value);
+}
+
+static int at91ether_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	int ret;
+
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+
+	ret = mii_ethtool_gset(&lp->mii, cmd);
+
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+
+	if (lp->phy_media == PORT_FIBRE) {		/* override media type since mii.c doesn't know */
+		cmd->supported = SUPPORTED_FIBRE;
+		cmd->port = PORT_FIBRE;
+	}
+	
+	return ret;
+}
+
+static int at91ether_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	int ret;
+
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+
+	ret = mii_ethtool_sset(&lp->mii, cmd);
+
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+
+	return ret;
+}
+
+static int at91ether_nwayreset(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	int ret;
+
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+
+	ret = mii_nway_restart(&lp->mii);
+
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+
+	return ret;
+}
+
+static void at91ether_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
+	strlcpy(info->bus_info, dev->class_dev.dev->bus_id, sizeof(info->bus_info));
+}
+
+static struct ethtool_ops at91ether_ethtool_ops = {
+	.get_settings	= at91ether_get_settings,
+	.set_settings	= at91ether_set_settings,
+	.get_drvinfo	= at91ether_get_drvinfo,
+	.nway_reset	= at91ether_nwayreset,
+	.get_link	= ethtool_op_get_link,
+};
+
+
+/* ................................ MAC ................................ */
+
+/*
+ * Initialize and start the Receiver and Transmit subsystems
+ */
+static void at91ether_start(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	struct recv_desc_bufs *dlist, *dlist_phys;
+	int i;
+	unsigned long ctl;
+
+	dlist = lp->dlist;
+	dlist_phys = lp->dlist_phys;
+
+	for (i = 0; i < MAX_RX_DESCR; i++) {
+		dlist->descriptors[i].addr = (unsigned int) &dlist_phys->recv_buf[i][0];
+		dlist->descriptors[i].size = 0;
+	}
+
+	/* Set the Wrap bit on the last descriptor */
+	dlist->descriptors[i-1].addr |= EMAC_DESC_WRAP;
+
+	/* Reset buffer index */
+	lp->rxBuffIndex = 0;
+
+	/* Program address of descriptor list in Rx Buffer Queue register */
+	at91_emac_write(AT91_EMAC_RBQP, (unsigned long) dlist_phys);
+
+	/* Enable Receive and Transmit */
+	ctl = at91_emac_read(AT91_EMAC_CTL);
+	at91_emac_write(AT91_EMAC_CTL, ctl | AT91_EMAC_RE | AT91_EMAC_TE);
+}
+
+/*
+ * Open the ethernet interface
+ */
+static int at91ether_open(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	int link;
+	unsigned long ctl;
+
+        if (!is_valid_ether_addr(dev->dev_addr))
+        	return -EADDRNOTAVAIL;
+
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_EMAC);	/* Re-enable Peripheral clock */
+	
+	/* Clear internal statistics */
+	ctl = at91_emac_read(AT91_EMAC_CTL);
+	at91_emac_write(AT91_EMAC_CTL, ctl | AT91_EMAC_CSR);
+
+	/* Update the MAC address (incase user has changed it) */
+	update_mac_address(dev);
+
+	/* Enable PHY interrupt */
+	enable_phyirq(dev);
+
+	/* Enable MAC interrupts */
+	at91_emac_write(AT91_EMAC_IER, AT91_EMAC_RCOM | AT91_EMAC_RBNA
+				| AT91_EMAC_TUND | AT91_EMAC_RTRY | AT91_EMAC_TCOM
+				| AT91_EMAC_ROVR | AT91_EMAC_ABT);
+
+	/* Determine current link speed */
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+	link = update_linkspeed(dev);
+	if (link == -1) {				/* link is down */
+		netif_carrier_off(dev);
+		printk(KERN_INFO "%s: Link down.\n", dev->name);
+	} else if (link == -2) {			/* auto-negotiation in progress */
+		/* Do nothing - another interrupt generated when negotiation complete */
+	} else {					/* link is operational */
+		netif_carrier_on(dev);
+	}
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+
+	at91ether_start(dev);
+	netif_start_queue(dev);
+	return 0;
+}
+
+/*
+ * Close the interface
+ */
+static int at91ether_close(struct net_device *dev)
+{
+	unsigned long ctl;
+
+	/* Disable Receiver and Transmitter */
+	ctl = at91_emac_read(AT91_EMAC_CTL);
+	at91_emac_write(AT91_EMAC_CTL, ctl & ~(AT91_EMAC_TE | AT91_EMAC_RE));
+
+	/* Disable PHY interrupt */
+	disable_phyirq(dev);
+
+	/* Disable MAC interrupts */
+	at91_emac_write(AT91_EMAC_IDR, AT91_EMAC_RCOM | AT91_EMAC_RBNA
+				| AT91_EMAC_TUND | AT91_EMAC_RTRY | AT91_EMAC_TCOM
+				| AT91_EMAC_ROVR | AT91_EMAC_ABT);
+
+	netif_stop_queue(dev);
+
+	at91_sys_write(AT91_PMC_PCDR, 1 << AT91_ID_EMAC);	/* Disable Peripheral clock */
+
+	return 0;
+}
+
+/*
+ * Transmit packet.
+ */
+static int at91ether_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+
+	if (at91_emac_read(AT91_EMAC_TSR) & AT91_EMAC_TSR_BNQ) {
+		netif_stop_queue(dev);
+
+		/* Store packet information (to free when Tx completed) */
+		lp->skb = skb;
+		lp->skb_length = skb->len;
+		lp->skb_physaddr = dma_map_single(NULL, skb->data, skb->len, DMA_TO_DEVICE);
+		lp->stats.tx_bytes += skb->len;
+
+		/* Set address of the data in the Transmit Address register */
+		at91_emac_write(AT91_EMAC_TAR, lp->skb_physaddr);
+		/* Set length of the packet in the Transmit Control register */
+		at91_emac_write(AT91_EMAC_TCR, skb->len);
+
+		dev->trans_start = jiffies;
+	} else {
+		printk(KERN_ERR "at91_ether.c: at91ether_tx() called, but device is busy!\n");
+		return 1;	/* if we return anything but zero, dev.c:1055 calls kfree_skb(skb)
+				on this skb, he also reports -ENETDOWN and printk's, so either
+				we free and return(0) or don't free and return 1 */
+	}
+
+	return 0;
+}
+
+/*
+ * Update the current statistics from the internal statistics registers.
+ */
+static struct net_device_stats *at91ether_stats(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	int ale, lenerr, seqe, lcol, ecol;
+
+	if (netif_running(dev)) {
+		lp->stats.rx_packets += at91_emac_read(AT91_EMAC_OK);		/* Good frames received */
+		ale = at91_emac_read(AT91_EMAC_ALE);
+		lp->stats.rx_frame_errors += ale;				/* Alignment errors */
+		lenerr = at91_emac_read(AT91_EMAC_ELR) + at91_emac_read(AT91_EMAC_USF);
+		lp->stats.rx_length_errors += lenerr;				/* Excessive Length or Undersize Frame error */
+		seqe = at91_emac_read(AT91_EMAC_SEQE);
+		lp->stats.rx_crc_errors += seqe;				/* CRC error */
+		lp->stats.rx_fifo_errors += at91_emac_read(AT91_EMAC_DRFC);	/* Receive buffer not available */
+		lp->stats.rx_errors += (ale + lenerr + seqe
+			+ at91_emac_read(AT91_EMAC_CDE) + at91_emac_read(AT91_EMAC_RJB));
+
+		lp->stats.tx_packets += at91_emac_read(AT91_EMAC_FRA);		/* Frames successfully transmitted */
+		lp->stats.tx_fifo_errors += at91_emac_read(AT91_EMAC_TUE);	/* Transmit FIFO underruns */
+		lp->stats.tx_carrier_errors += at91_emac_read(AT91_EMAC_CSE);	/* Carrier Sense errors */
+		lp->stats.tx_heartbeat_errors += at91_emac_read(AT91_EMAC_SQEE);/* Heartbeat error */
+
+		lcol = at91_emac_read(AT91_EMAC_LCOL);
+		ecol = at91_emac_read(AT91_EMAC_ECOL);
+		lp->stats.tx_window_errors += lcol;			/* Late collisions */
+		lp->stats.tx_aborted_errors += ecol;			/* 16 collisions */
+
+		lp->stats.collisions += (at91_emac_read(AT91_EMAC_SCOL) + at91_emac_read(AT91_EMAC_MCOL) + lcol + ecol);
+	}
+	return &lp->stats;
+}
+
+/*
+ * Extract received frame from buffer descriptors and sent to upper layers.
+ * (Called from interrupt context)
+ */
+static void at91ether_rx(struct net_device *dev)
+{
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	struct recv_desc_bufs *dlist;
+	unsigned char *p_recv;
+	struct sk_buff *skb;
+	unsigned int pktlen;
+
+	dlist = lp->dlist;
+	while (dlist->descriptors[lp->rxBuffIndex].addr & EMAC_DESC_DONE) {
+		p_recv = dlist->recv_buf[lp->rxBuffIndex];
+		pktlen = dlist->descriptors[lp->rxBuffIndex].size & 0x7ff;	/* Length of frame including FCS */
+		skb = alloc_skb(pktlen + 2, GFP_ATOMIC);
+		if (skb != NULL) {
+			skb_reserve(skb, 2);
+			memcpy(skb_put(skb, pktlen), p_recv, pktlen);
+
+			skb->dev = dev;
+			skb->protocol = eth_type_trans(skb, dev);
+			skb->len = pktlen;
+			dev->last_rx = jiffies;
+			lp->stats.rx_bytes += pktlen;
+			netif_rx(skb);
+		}
+		else {
+			lp->stats.rx_dropped += 1;
+			printk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n", dev->name);
+		}
+
+		if (dlist->descriptors[lp->rxBuffIndex].size & EMAC_MULTICAST)
+			lp->stats.multicast++;
+
+		dlist->descriptors[lp->rxBuffIndex].addr &= ~EMAC_DESC_DONE;	/* reset ownership bit */
+		if (lp->rxBuffIndex == MAX_RX_DESCR-1)				/* wrap after last buffer */
+			lp->rxBuffIndex = 0;
+		else
+			lp->rxBuffIndex++;
+	}
+}
+
+/*
+ * MAC interrupt handler
+ */
+static irqreturn_t at91ether_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct at91_private *lp = (struct at91_private *) dev->priv;
+	unsigned long intstatus, ctl;
+
+	/* MAC Interrupt Status register indicates what interrupts are pending.
+	   It is automatically cleared once read. */
+	intstatus = at91_emac_read(AT91_EMAC_ISR);
+
+	if (intstatus & AT91_EMAC_RCOM)		/* Receive complete */
+		at91ether_rx(dev);
+
+	if (intstatus & AT91_EMAC_TCOM) {		/* Transmit complete */
+		/* The TCOM bit is set even if the transmission failed. */
+		if (intstatus & (AT91_EMAC_TUND | AT91_EMAC_RTRY))
+			lp->stats.tx_errors += 1;
+
+		if (lp->skb) {
+			dev_kfree_skb_irq(lp->skb);
+			lp->skb = NULL;
+			dma_unmap_single(NULL, lp->skb_physaddr, lp->skb_length, DMA_TO_DEVICE);
+		}
+		netif_wake_queue(dev);
+	}
+
+	/* Work-around for Errata #11 */
+	if (intstatus & AT91_EMAC_RBNA) {
+		ctl = at91_emac_read(AT91_EMAC_CTL);
+		at91_emac_write(AT91_EMAC_CTL, ctl & ~AT91_EMAC_RE);
+		at91_emac_write(AT91_EMAC_CTL, ctl | AT91_EMAC_RE);
+	}
+
+	if (intstatus & AT91_EMAC_ROVR)
+		printk("%s: ROVR error\n", dev->name);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Initialize the ethernet interface
+ */
+static int __init at91ether_setup(unsigned long phy_type, unsigned short phy_address, struct platform_device *pdev)
+{
+	struct at91_eth_data *board_data = pdev->dev.platform_data;
+	struct net_device *dev;
+	struct at91_private *lp;
+	unsigned int val;
+	int res;
+
+	if (at91_dev)			/* already initialized */
+		return 0;
+
+	dev = alloc_etherdev(sizeof(struct at91_private));
+	if (!dev)
+		return -ENOMEM;
+
+	dev->base_addr = AT91_VA_BASE_EMAC;
+	dev->irq = AT91_ID_EMAC;
+	SET_MODULE_OWNER(dev);
+
+	/* Install the interrupt handler */
+	if (request_irq(dev->irq, at91ether_interrupt, 0, dev->name, dev)) {
+		free_netdev(dev);
+		return -EBUSY;
+	}
+
+	/* Allocate memory for DMA Receive descriptors */
+	lp = (struct at91_private *)dev->priv;
+	lp->dlist = (struct recv_desc_bufs *) dma_alloc_coherent(NULL, sizeof(struct recv_desc_bufs), (dma_addr_t *) &lp->dlist_phys, GFP_KERNEL);
+	if (lp->dlist == NULL) {
+		free_irq(dev->irq, dev);
+		free_netdev(dev);
+		return -ENOMEM;
+	}
+	lp->board_data = *board_data;
+	platform_set_drvdata(pdev, dev);
+
+	spin_lock_init(&lp->lock);
+
+	ether_setup(dev);
+	dev->open = at91ether_open;
+	dev->stop = at91ether_close;
+	dev->hard_start_xmit = at91ether_tx;
+	dev->get_stats = at91ether_stats;
+	dev->set_multicast_list = at91ether_set_rx_mode;
+	dev->set_mac_address = set_mac_address;
+	dev->ethtool_ops = &at91ether_ethtool_ops;
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	get_mac_address(dev);		/* Get ethernet address and store it in dev->dev_addr */
+	update_mac_address(dev);	/* Program ethernet address into MAC */
+
+	at91_emac_write(AT91_EMAC_CTL, 0);
+
+	if (lp->board_data.is_rmii)
+		at91_emac_write(AT91_EMAC_CFG, AT91_EMAC_CLK_DIV32 | AT91_EMAC_BIG | AT91_EMAC_RMII);
+	else
+		at91_emac_write(AT91_EMAC_CFG, AT91_EMAC_CLK_DIV32 | AT91_EMAC_BIG);
+
+	/* Perform PHY-specific initialization */
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+	if ((phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {
+		read_phy(phy_address, MII_DSCR_REG, &val);
+		if ((val & (1 << 10)) == 0)			/* DSCR bit 10 is 0 -- fiber mode */
+			lp->phy_media = PORT_FIBRE;
+	} else if (machine_is_csb337()) {
+		/* mix link activity status into LED2 link state */
+		write_phy(phy_address, MII_LEDCTRL_REG, 0x0d22);
+	}
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+
+	lp->mii.dev = dev;		/* Support for ethtool */
+	lp->mii.mdio_read = mdio_read;
+	lp->mii.mdio_write = mdio_write;
+
+	lp->phy_type = phy_type;	/* Type of PHY connected */
+	lp->phy_address = phy_address;	/* MDI address of PHY */
+
+	/* Register the network interface */
+	res = register_netdev(dev);
+	if (res) {
+		free_irq(dev->irq, dev);
+		free_netdev(dev);
+		dma_free_coherent(NULL, sizeof(struct recv_desc_bufs), lp->dlist, (dma_addr_t)lp->dlist_phys);
+		return res;
+	}
+	at91_dev = dev;
+
+	/* Determine current link speed */
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+	(void) update_linkspeed(dev);
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+	netif_carrier_off(dev);		/* will be enabled in open() */
+
+	/* Display ethernet banner */
+	printk(KERN_INFO "%s: AT91 ethernet at 0x%08x int=%d %s%s (%02x:%02x:%02x:%02x:%02x:%02x)\n",
+		dev->name, (uint) dev->base_addr, dev->irq,
+		at91_emac_read(AT91_EMAC_CFG) & AT91_EMAC_SPD ? "100-" : "10-",
+		at91_emac_read(AT91_EMAC_CFG) & AT91_EMAC_FD ? "FullDuplex" : "HalfDuplex",
+		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+	if ((phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID))
+		printk(KERN_INFO "%s: Davicom 9196 PHY %s\n", dev->name, (lp->phy_media == PORT_FIBRE) ? "(Fiber)" : "(Copper)");
+	else if (phy_type == MII_LXT971A_ID)
+		printk(KERN_INFO "%s: Intel LXT971A PHY\n", dev->name);
+	else if (phy_type == MII_RTL8201_ID)
+		printk(KERN_INFO "%s: Realtek RTL8201(B)L PHY\n", dev->name);
+	else if (phy_type == MII_BCM5221_ID)
+		printk(KERN_INFO "%s: Broadcom BCM5221 PHY\n", dev->name);
+	else if (phy_type == MII_DP83847_ID)
+		printk(KERN_INFO "%s: National Semiconductor DP83847 PHY\n", dev->name);
+	else if (phy_type == MII_AC101L_ID)
+		printk(KERN_INFO "%s: Altima AC101L PHY\n", dev->name);
+	else if (phy_type == MII_KS8721_ID)
+		printk(KERN_INFO "%s: Micrel KS8721 PHY\n", dev->name);
+
+	return 0;
+}
+
+/*
+ * Detect MAC and PHY and perform initialization
+ */
+static int __init at91ether_probe(struct platform_device *pdev)
+{
+	unsigned int phyid1, phyid2;
+	int detected = -1;
+	unsigned long phy_id;
+	unsigned short phy_address = 0;
+
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_EMAC);	/* Enable Peripheral clock */
+
+	while ((detected != 0) && (phy_address < 32)) {
+		/* Read the PHY ID registers */
+		enable_mdi();
+		read_phy(phy_address, MII_PHYSID1, &phyid1);
+		read_phy(phy_address, MII_PHYSID2, &phyid2);
+		disable_mdi();
+
+		phy_id = (phyid1 << 16) | (phyid2 & 0xfff0);
+		switch (phy_id) {
+			case MII_DM9161_ID:		/* Davicom 9161: PHY_ID1 = 0x181, PHY_ID2 = B881 */
+			case MII_DM9161A_ID:		/* Davicom 9161A: PHY_ID1 = 0x181, PHY_ID2 = B8A0 */
+			case MII_LXT971A_ID:		/* Intel LXT971A: PHY_ID1 = 0x13, PHY_ID2 = 78E0 */
+			case MII_RTL8201_ID:		/* Realtek RTL8201: PHY_ID1 = 0, PHY_ID2 = 0x8201 */
+			case MII_BCM5221_ID:		/* Broadcom BCM5221: PHY_ID1 = 0x40, PHY_ID2 = 0x61e0 */
+			case MII_DP83847_ID:		/* National Semiconductor DP83847:  */
+			case MII_AC101L_ID:		/* Altima AC101L: PHY_ID1 = 0x22, PHY_ID2 = 0x5520 */
+			case MII_KS8721_ID:		/* Micrel KS8721: PHY_ID1 = 0x22, PHY_ID2 = 0x1610 */
+				detected = at91ether_setup(phy_id, phy_address, pdev);
+				break;
+		}
+
+		phy_address++;
+	}
+
+	at91_sys_write(AT91_PMC_PCDR, 1 << AT91_ID_EMAC);	/* Disable Peripheral clock */
+
+	return detected;
+}
+
+static int __devexit at91ether_remove(struct platform_device *pdev)
+{
+	struct at91_private *lp = (struct at91_private *) at91_dev->priv;
+
+	unregister_netdev(at91_dev);
+	free_irq(at91_dev->irq, at91_dev);
+	dma_free_coherent(NULL, sizeof(struct recv_desc_bufs), lp->dlist, (dma_addr_t)lp->dlist_phys);
+
+	free_netdev(at91_dev);
+	at91_dev = NULL;
+	return 0;
+}
+
+static struct platform_driver at91ether_driver = {
+	.probe		= at91ether_probe,
+	.remove		= __devexit_p(at91ether_remove),
+	/* FIXME:  support suspend and resume */
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91ether_init(void)
+{
+	return platform_driver_register(&at91ether_driver);
+}
+
+static void __exit at91ether_exit(void)
+{
+	platform_driver_unregister(&at91ether_driver);
+}
+
+module_init(at91ether_init)
+module_exit(at91ether_exit)
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AT91RM9200 EMAC Ethernet driver");
+MODULE_AUTHOR("Andrew Victor");
diff -urN linux-2.6.15.orig/drivers/net/arm/at91_ether.h linux-2.6.15/drivers/net/arm/at91_ether.h
--- linux-2.6.15.orig/drivers/net/arm/at91_ether.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/net/arm/at91_ether.h	Wed Jan 11 10:58:36 2006
@@ -0,0 +1,101 @@
+/*
+ * Ethernet driver for the Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * Based on an earlier Atmel EMAC macrocell driver by Atmel and Lineo Inc.
+ * Initial version by Rick Bronson.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef AT91_ETHERNET
+#define AT91_ETHERNET
+
+
+/* Davicom 9161 PHY */
+#define MII_DM9161_ID   0x0181b880
+#define MII_DM9161A_ID	0x0181b8a0
+
+/* Davicom specific registers */
+#define MII_DSCR_REG	16
+#define MII_DSCSR_REG   17
+#define MII_DSINTR_REG  21
+
+/* Intel LXT971A PHY */
+#define MII_LXT971A_ID	0x001378E0
+
+/* Intel specific registers */
+#define MII_ISINTE_REG	18
+#define MII_ISINTS_REG	19
+#define MII_LEDCTRL_REG	20
+
+/* Realtek RTL8201 PHY */
+#define MII_RTL8201_ID	0x00008200
+
+/* Broadcom BCM5221 PHY */
+#define MII_BCM5221_ID	0x004061e0
+
+/* Broadcom specific registers */
+#define MII_BCMINTR_REG	26
+
+/* National Semiconductor DP83847 */
+#define MII_DP83847_ID	0x20005c30
+
+/* Altima AC101L PHY */
+#define MII_AC101L_ID	0x00225520
+
+/* Micrel KS8721 PHY */
+#define MII_KS8721_ID	0x00221610
+
+/* ........................................................................ */
+
+#define MAX_RBUFF_SZ	0x600		/* 1518 rounded up */
+#define MAX_RX_DESCR	9		/* max number of receive buffers */
+
+#define EMAC_DESC_DONE	0x00000001	/* bit for if DMA is done */
+#define EMAC_DESC_WRAP	0x00000002	/* bit for wrap */
+
+#define EMAC_BROADCAST	0x80000000	/* broadcast address */
+#define EMAC_MULTICAST	0x40000000	/* multicast address */
+#define EMAC_UNICAST	0x20000000	/* unicast address */
+
+struct rbf_t
+{
+	unsigned int addr;
+	unsigned long size;
+};
+
+struct recv_desc_bufs
+{
+	struct rbf_t descriptors[MAX_RX_DESCR];		/* must be on sizeof (rbf_t) boundary */
+	char recv_buf[MAX_RX_DESCR][MAX_RBUFF_SZ];	/* must be on long boundary */
+};
+
+struct at91_private
+{
+	struct net_device_stats stats;
+	struct mii_if_info mii;			/* ethtool support */
+	struct at91_eth_data board_data;	/* board-specific configuration */
+
+	/* PHY */
+	unsigned long phy_type;			/* type of PHY (PHY_ID) */
+	spinlock_t lock;			/* lock for MDI interface */
+	short phy_media;			/* media interface type */
+	unsigned short phy_address;		/* 5-bit MDI address of PHY (0..31) */
+
+	/* Transmit */
+	struct sk_buff *skb;			/* holds skb until xmit interrupt completes */
+	dma_addr_t skb_physaddr;		/* phys addr from pci_map_single */
+	int skb_length;				/* saved skb length for pci_unmap_single */
+
+	/* Receive */
+	int rxBuffIndex;			/* index into receive descriptor list */
+	struct recv_desc_bufs *dlist;		/* descriptor list address */
+	struct recv_desc_bufs *dlist_phys;	/* descriptor list physical address */
+};
+
+#endif
diff -urN linux-2.6.15.orig/drivers/pcmcia/Kconfig linux-2.6.15/drivers/pcmcia/Kconfig
--- linux-2.6.15.orig/drivers/pcmcia/Kconfig	Wed Jan 11 09:19:11 2006
+++ linux-2.6.15/drivers/pcmcia/Kconfig	Wed Jan 11 10:36:47 2006
@@ -238,6 +238,13 @@
 	  Say Y here to support the CompactFlash controller on OMAP.
 	  Note that this doesn't support "True IDE" mode.
 
+config AT91_CF
+	tristate "AT91 CompactFlash Controller"
+	depends on PCMCIA && ARCH_AT91RM9200
+	help
+	  Say Y here to support the CompactFlash controller on AT91 chips.
+	  Or choose M to compile the driver as a module named "at91_cf".
+
 config PCCARD_NONSTATIC
 	tristate
 
diff -urN linux-2.6.15.orig/drivers/pcmcia/Makefile linux-2.6.15/drivers/pcmcia/Makefile
--- linux-2.6.15.orig/drivers/pcmcia/Makefile	Wed Jan 11 09:19:11 2006
+++ linux-2.6.15/drivers/pcmcia/Makefile	Wed Jan 11 10:36:47 2006
@@ -36,6 +36,7 @@
 obj-$(CONFIG_PCMCIA_VRC4171)			+= vrc4171_card.o
 obj-$(CONFIG_PCMCIA_VRC4173)			+= vrc4173_cardu.o
 obj-$(CONFIG_OMAP_CF)				+= omap_cf.o
+obj-$(CONFIG_AT91_CF)				+= at91_cf.o
 
 sa11xx_core-y					+= soc_common.o sa11xx_base.o
 pxa2xx_core-y					+= soc_common.o pxa2xx_base.o
diff -urN linux-2.6.15.orig/drivers/pcmcia/at91_cf.c linux-2.6.15/drivers/pcmcia/at91_cf.c
--- linux-2.6.15.orig/drivers/pcmcia/at91_cf.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/pcmcia/at91_cf.c	Wed Jan 11 11:35:26 2006
@@ -0,0 +1,360 @@
+/*
+ * at91_cf.c -- AT91 CompactFlash controller driver
+ *
+ * Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <pcmcia/ss.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/sizes.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pio.h>
+
+
+#define	CF_PHYS		0x50000000	/* CS4: up to 0x5fffffff */
+#define	CF_SIZE		0x30000000	/* CS5+CS6: unavailable */
+
+/*
+ * A0..A10 work in each range; A23 indicates I/O space;  A25 is CFRNW;
+ * some other bit in {A24,A22..A11} is nREG to flag memory access
+ * (vs attributes).  So more than 2KB/region would just be waste.
+ */
+#define	CF_ATTR_PHYS	(CF_PHYS)
+#define	CF_IO_PHYS	(CF_PHYS + (1 << 23))
+#define	CF_MEM_PHYS	(CF_PHYS + 0x017ff800)
+
+/*--------------------------------------------------------------------------*/
+
+static const char driver_name[] = "at91_cf";
+
+struct at91_cf_socket {
+	struct pcmcia_socket	socket;
+
+	unsigned		present:1;
+
+	struct platform_device	*pdev;
+	struct at91_cf_data	*board;
+};
+
+#define	SZ_2K			(2 * SZ_1K)
+
+static inline int at91_cf_present(struct at91_cf_socket *cf)
+{
+	return !at91_get_gpio_value(cf->board->det_pin);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static int at91_cf_ss_init(struct pcmcia_socket *s)
+{
+	return 0;
+}
+
+static irqreturn_t at91_cf_irq(int irq, void *_cf, struct pt_regs *r)
+{
+	struct at91_cf_socket	*cf = (void *) _cf;
+
+	if (irq == cf->board->det_pin) {
+		unsigned	present = at91_cf_present(cf);
+
+		/* kick pccardd as needed */
+		if (present != cf->present) {
+			cf->present = present;
+			pr_debug("%s: card %s\n", driver_name,
+				present ? "present" : "gone");
+			pcmcia_parse_events(&cf->socket, SS_DETECT);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static int at91_cf_get_status(struct pcmcia_socket *s, u_int *sp)
+{
+	struct at91_cf_socket	*cf;
+
+	if (!sp)
+		return -EINVAL;
+
+	/* NOTE: we assume 3VCARD, not XVCARD...  */
+	cf = container_of(s, struct at91_cf_socket, socket);
+	if (at91_cf_present(cf)) {
+		int	rdy = cf->board->irq_pin;	/* RDY/nIRQ */
+		int	vcc = cf->board->vcc_pin;
+
+		*sp = SS_DETECT | SS_3VCARD;
+		if (!rdy || at91_get_gpio_value(rdy))
+			*sp |= SS_READY;
+		if (!vcc || at91_get_gpio_value(vcc))
+			*sp |= SS_POWERON;
+	} else
+		*sp = 0;
+	return 0;
+}
+
+static int at91_cf_set_socket(struct pcmcia_socket *sock, struct socket_state_t *s)
+{
+	struct at91_cf_socket	*cf;
+
+	cf = container_of(sock, struct at91_cf_socket, socket);
+
+	/* switch Vcc if needed and possible */
+	if (cf->board->vcc_pin) {
+		switch (s->Vcc) {
+		case 0:
+			at91_set_gpio_value(cf->board->vcc_pin, 0);
+			break;
+		case 33:
+			at91_set_gpio_value(cf->board->vcc_pin, 1);
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	/* toggle reset if needed */
+	at91_set_gpio_value(cf->board->rst_pin, s->flags & SS_RESET);
+
+	pr_debug("%s: Vcc %d, io_irq %d, flags %04x csc %04x\n",
+		driver_name, s->Vcc, s->io_irq, s->flags, s->csc_mask);
+
+	return 0;
+}
+
+static int at91_cf_ss_suspend(struct pcmcia_socket *s)
+{
+	return at91_cf_set_socket(s, &dead_socket);
+}
+
+/* we already mapped the I/O region */
+static int at91_cf_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)
+{
+	struct at91_cf_socket	*cf;
+	u32			csr;
+
+	cf = container_of(s, struct at91_cf_socket, socket);
+	io->flags &= MAP_ACTIVE|MAP_16BIT|MAP_AUTOSZ;
+
+	/*
+	 * Use 16 bit accesses unless/until we need 8-bit i/o space.
+	 * Always set CSR4 ... PCMCIA won't always unmap things.
+	 */
+	csr = at91_sys_read(AT91_SMC_CSR(4)) & ~AT91_SMC_DBW;
+
+	/*
+	 * NOTE: this CF controller ignores IOIS16, so we can't really do
+	 * MAP_AUTOSZ.  The 16bit mode allows single byte access on either
+	 * D0-D7 (even addr) or D8-D15 (odd), so it's close enough for many
+	 * purposes (and handles ide-cs).
+	 *
+	 * The 8bit mode is needed for odd byte access on D0-D7.  It seems
+	 * some cards only like that way to get at the odd byte, despite
+	 * CF 3.0 spec table 35 also giving the D8-D15 option.
+	 */
+	if (!(io->flags & (MAP_16BIT|MAP_AUTOSZ))) {
+		csr |= AT91_SMC_DBW_8;
+		pr_debug("%s: 8bit i/o bus\n", driver_name);
+	} else {
+		csr |= AT91_SMC_DBW_16;
+		pr_debug("%s: 16bit i/o bus\n", driver_name);
+	}
+	at91_sys_write(AT91_SMC_CSR(4), csr);
+
+	io->start = cf->socket.io_offset;
+	io->stop = io->start + SZ_2K - 1;
+	return 0;
+}
+
+/* pcmcia layer maps/unmaps mem regions */
+static int at91_cf_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *map)
+{
+	struct at91_cf_socket	*cf;
+
+	if (map->card_start)
+		return -EINVAL;
+	cf = container_of(s, struct at91_cf_socket, socket);
+	map->flags &= MAP_ACTIVE|MAP_ATTRIB|MAP_16BIT;
+	if (map->flags & MAP_ATTRIB)
+		map->static_start = CF_ATTR_PHYS;
+	else
+		map->static_start = CF_MEM_PHYS;
+	return 0;
+}
+
+static struct pccard_operations at91_cf_ops = {
+	.init			= at91_cf_ss_init,
+	.suspend		= at91_cf_ss_suspend,
+	.get_status		= at91_cf_get_status,
+	.set_socket		= at91_cf_set_socket,
+	.set_io_map		= at91_cf_set_io_map,
+	.set_mem_map		= at91_cf_set_mem_map,
+};
+
+/*--------------------------------------------------------------------------*/
+
+static int __init at91_cf_probe(struct device *dev)
+{
+	struct at91_cf_socket	*cf;
+	struct at91_cf_data	*board = dev->platform_data;
+	struct platform_device	*pdev = to_platform_device(dev);
+	unsigned int		csa;
+	int			status;
+
+	if (!board || !board->det_pin || !board->rst_pin)
+		return -ENODEV;
+
+	cf = kcalloc(1, sizeof *cf, GFP_KERNEL);
+	if (!cf)
+		return -ENOMEM;
+
+	cf->board = board;
+	cf->pdev = pdev;
+	dev_set_drvdata(dev, cf);
+
+	/* CF takes over CS4, CS5, CS6 */
+	csa = at91_sys_read(AT91_EBI_CSA);
+	at91_sys_write(AT91_EBI_CSA, csa | AT91_EBI_CS4A_SMC_COMPACTFLASH);
+
+	/* force poweron defaults for these pins ... */
+	(void) at91_set_A_periph(AT91_PIN_PC9  /* A25/CFRNW */, 0);
+	(void) at91_set_A_periph(AT91_PIN_PC10 /* NCS4/CFCS */, 0);
+	(void) at91_set_A_periph(AT91_PIN_PC11 /* NCS5/CFCE1 */, 0);
+	(void) at91_set_A_periph(AT91_PIN_PC12 /* NCS6/CFCE2 */, 0);
+
+	/* nWAIT is _not_ a default setting */
+	(void) at91_set_A_periph(AT91_PIN_PC6 /* nWAIT */, 1);
+
+	/*
+	 * Static memory controller timing adjustments.
+	 * REVISIT:  these timings are in terms of MCK cycles, so
+	 * when MCK changes (cpufreq etc) so must these values...
+	 */
+	at91_sys_write(AT91_SMC_CSR(4), AT91_SMC_ACSS_STD | AT91_SMC_DBW_16 | AT91_SMC_BAT | AT91_SMC_WSEN
+				| AT91_SMC_NWS_(32)		/* wait states */
+				| AT91_SMC_RWSETUP_(6)		/* setup time */
+				| AT91_SMC_RWHOLD_(4)		/* hold time */
+	);
+
+	/* must be a GPIO; ergo must trigger on both edges */
+	status = request_irq(board->det_pin, at91_cf_irq,
+			SA_SAMPLE_RANDOM, driver_name, cf);
+	if (status < 0)
+		goto fail0;
+
+	/*
+	 * The card driver will request this irq later as needed.
+	 * but it causes lots of "irqNN: nobody cared" messages
+	 * unless we report that we handle everything (sigh).
+	 * (Note:  DK board doesn't wire the IRQ pin...)
+	 */
+	if (board->irq_pin) {
+		status = request_irq(board->irq_pin, at91_cf_irq,
+				SA_SHIRQ, driver_name, cf);
+		if (status < 0)
+			goto fail0a;
+		cf->socket.pci_irq = board->irq_pin;
+	}
+	else
+		cf->socket.pci_irq = NR_IRQS + 1;
+
+	/* pcmcia layer only remaps "real" memory not iospace */
+	cf->socket.io_offset = (unsigned long) ioremap(CF_IO_PHYS, SZ_2K);
+	if (!cf->socket.io_offset)
+		goto fail1;
+
+	/* reserve CS4, CS5, and CS6 regions; but use just CS4 */
+	if (!request_mem_region(CF_PHYS, CF_SIZE, driver_name))
+		goto fail1;
+
+	pr_info("%s: irqs det #%d, io #%d\n", driver_name,
+		board->det_pin, board->irq_pin);
+
+	cf->socket.owner = THIS_MODULE;
+	cf->socket.dev.dev = dev;
+	cf->socket.ops = &at91_cf_ops;
+	cf->socket.resource_ops = &pccard_static_ops;
+	cf->socket.features = SS_CAP_PCCARD | SS_CAP_STATIC_MAP
+				| SS_CAP_MEM_ALIGN;
+	cf->socket.map_size = SZ_2K;
+	cf->socket.io[0].NumPorts = SZ_2K;
+
+	status = pcmcia_register_socket(&cf->socket);
+	if (status < 0)
+		goto fail2;
+
+	return 0;
+
+fail2:
+	iounmap((void __iomem *) cf->socket.io_offset);
+	release_mem_region(CF_PHYS, CF_SIZE);
+fail1:
+	if (board->irq_pin)
+		free_irq(board->irq_pin, cf);
+fail0a:
+	free_irq(board->det_pin, cf);
+fail0:
+	at91_sys_write(AT91_EBI_CSA, csa);
+	kfree(cf);
+	return status;
+}
+
+static int __exit at91_cf_remove(struct device *dev)
+{
+	struct at91_cf_socket *cf = dev_get_drvdata(dev);
+	unsigned int csa;
+
+	pcmcia_unregister_socket(&cf->socket);
+	free_irq(cf->board->irq_pin, cf);
+	free_irq(cf->board->det_pin, cf);
+	iounmap((void __iomem *) cf->socket.io_offset);
+	release_mem_region(CF_PHYS, CF_SIZE);
+
+	csa = at91_sys_read(AT91_EBI_CSA);
+	at91_sys_write(AT91_EBI_CSA, csa & ~AT91_EBI_CS4A);
+
+	kfree(cf);
+	return 0;
+}
+
+static struct device_driver at91_cf_driver = {
+	.name		= (char *) driver_name,
+	.bus		= &platform_bus_type,
+	.probe		= at91_cf_probe,
+	.remove		= __exit_p(at91_cf_remove),
+	.suspend 	= pcmcia_socket_dev_suspend,
+	.resume 	= pcmcia_socket_dev_resume,
+};
+
+/*--------------------------------------------------------------------------*/
+
+static int __init at91_cf_init(void)
+{
+	return driver_register(&at91_cf_driver);
+}
+module_init(at91_cf_init);
+
+static void __exit at91_cf_exit(void)
+{
+	driver_unregister(&at91_cf_driver);
+}
+module_exit(at91_cf_exit);
+
+MODULE_DESCRIPTION("AT91 Compact Flash Driver");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.15.orig/drivers/serial/Kconfig linux-2.6.15/drivers/serial/Kconfig
--- linux-2.6.15.orig/drivers/serial/Kconfig	Wed Jan 11 09:19:19 2006
+++ linux-2.6.15/drivers/serial/Kconfig	Wed Jan 11 09:24:58 2006
@@ -270,6 +270,40 @@
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_AT91
+	bool "AT91RM9200 serial port support"
+	depends on ARM && ARCH_AT91RM9200
+	select SERIAL_CORE
+	help
+	  This enables the driver for the on-chip UARTs of the AT91RM9200
+	  processor.
+
+config SERIAL_AT91_CONSOLE
+	bool "Support for console on AT91RM9200 serial port"
+	depends on SERIAL_AT91=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Say Y here if you wish to use a UART on the AT91RM9200 as the system
+	  console (the system console is the device which receives all kernel
+	  messages and warnings and which allows logins in single user mode).
+
+config SERIAL_AT91_TTYAT
+	bool "Install as device ttyAT0-4 instead of ttyS0-4"
+	depends on SERIAL_AT91=y
+	help
+	  Say Y here if you wish to have the five internal AT91RM9200 UARTs
+	  appear as /dev/ttyAT0-4 (major 240, minor 0-4) instead of the
+	  normal /dev/ttyS0-4 (major 4, minor 64-68). This is necessary if
+	  you also want other UARTs, such as external 8250/16C550 compatible
+	  UARTs.
+	  The ttySn nodes are legally reserved for the 8250 serial driver
+	  but are often misused by other serial drivers.
+
+	  To use this, you should create suitable ttyATn device nodes in
+	  /dev/, and pass "console=ttyATn" to the kernel.
+
+	  Say Y if you have an external 8250/16C550 UART.  If unsure, say N.
+ 
 config SERIAL_CLPS711X
 	tristate "CLPS711X serial port support"
 	depends on ARM && ARCH_CLPS711X
diff -urN linux-2.6.15.orig/drivers/serial/Makefile linux-2.6.15/drivers/serial/Makefile
--- linux-2.6.15.orig/drivers/serial/Makefile	Wed Jan 11 09:19:19 2006
+++ linux-2.6.15/drivers/serial/Makefile	Wed Jan 11 09:24:58 2006
@@ -57,3 +57,4 @@
 obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
 obj-$(CONFIG_SERIAL_VR41XX) += vr41xx_siu.o
 obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
+obj-$(CONFIG_SERIAL_AT91) += at91_serial.o
diff -urN linux-2.6.15.orig/drivers/serial/at91_serial.c linux-2.6.15/drivers/serial/at91_serial.c
--- linux-2.6.15.orig/drivers/serial/at91_serial.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/serial/at91_serial.c	Wed Jan 11 09:37:42 2006
@@ -0,0 +1,894 @@
+/*
+ *  linux/drivers/char/at91_serial.c
+ *
+ *  Driver for Atmel AT91RM9200 Serial ports
+ *
+ *  Copyright (C) 2003 Rick Bronson
+ *
+ *  Based on drivers/char/serial_sa1100.c, by Deep Blue Solutions Ltd.
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/tty_flip.h>
+
+#include <asm/io.h>
+
+#include <asm/arch/at91rm9200_usart.h>
+#include <asm/mach/serial_at91rm9200.h>
+#include <asm/arch/board.h>
+#include <asm/arch/pio.h>
+
+
+#if defined(CONFIG_SERIAL_AT91_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/serial_core.h>
+
+#ifdef CONFIG_SERIAL_AT91_TTYAT
+
+/* Use device name ttyAT, major 204 and minor 154-169.  This is necessary if we
+ * should coexist with the 8250 driver, such as if we have an external 16C550
+ * UART. */
+#define SERIAL_AT91_MAJOR	204
+#define MINOR_START		154
+#define AT91_DEVICENAME		"ttyAT"
+
+#else
+
+/* Use device name ttyS, major 4, minor 64-68.  This is the usual serial port
+ * name, but it is legally reserved for the 8250 driver. */
+#define SERIAL_AT91_MAJOR	TTY_MAJOR
+#define MINOR_START		64
+#define AT91_DEVICENAME		"ttyS"
+
+#endif
+
+#define AT91_VA_BASE_DBGU	((unsigned long) AT91_VA_BASE_SYS + AT91_DBGU)
+#define AT91_ISR_PASS_LIMIT	256
+
+#define UART_PUT_CR(port,v)	writel(v, (port)->membase + AT91_US_CR)
+#define UART_GET_MR(port)	readl((port)->membase + AT91_US_MR)
+#define UART_PUT_MR(port,v)	writel(v, (port)->membase + AT91_US_MR)
+#define UART_PUT_IER(port,v)	writel(v, (port)->membase + AT91_US_IER)
+#define UART_PUT_IDR(port,v)	writel(v, (port)->membase + AT91_US_IDR)
+#define UART_GET_IMR(port)	readl((port)->membase + AT91_US_IMR)
+#define UART_GET_CSR(port)	readl((port)->membase + AT91_US_CSR)
+#define UART_GET_CHAR(port)	readl((port)->membase + AT91_US_RHR)
+#define UART_PUT_CHAR(port,v)	writel(v, (port)->membase + AT91_US_THR)
+#define UART_GET_BRGR(port)	readl((port)->membase + AT91_US_BRGR)
+#define UART_PUT_BRGR(port,v)	writel(v, (port)->membase + AT91_US_BRGR)
+#define UART_PUT_RTOR(port,v)	writel(v, (port)->membase + AT91_US_RTOR)
+
+// #define UART_GET_CR(port)	readl((port)->membase + AT91_US_CR)		// is write-only
+
+ /* PDC registers */
+#define UART_PUT_PTCR(port,v)	writel(v, (port)->membase + AT91_PDC_PTCR)
+#define UART_PUT_RPR(port,v)	writel(v, (port)->membase + AT91_PDC_RPR)
+#define UART_PUT_RCR(port,v)	writel(v, (port)->membase + AT91_PDC_RCR)
+#define UART_GET_RCR(port)	readl((port)->membase + AT91_PDC_RCR)
+#define UART_PUT_RNPR(port,v)	writel(v, (port)->membase + AT91_PDC_RNPR)
+#define UART_PUT_RNCR(port,v)	writel(v, (port)->membase + AT91_PDC_RNCR)
+
+
+static int (*at91_open)(struct uart_port *);
+static void (*at91_close)(struct uart_port *);
+
+#ifdef SUPPORT_SYSRQ
+static struct console at91_console;
+#endif
+
+/*
+ * Return TIOCSER_TEMT when transmitter FIFO and Shift register is empty.
+ */
+static u_int at91_tx_empty(struct uart_port *port)
+{
+	return (UART_GET_CSR(port) & AT91_US_TXEMPTY) ? TIOCSER_TEMT : 0;
+}
+
+/*
+ * Set state of the modem control output lines
+ */
+static void at91_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+	unsigned int control = 0;
+
+	/*
+	 * Errata #39: RTS0 is not internally connected to PA21.  We need to drive
+	 *  the pin manually.
+	 */
+	if (port->mapbase == AT91_VA_BASE_US0) {
+		if (mctrl & TIOCM_RTS)
+			at91_sys_write(AT91_PIOA + PIO_CODR, AT91_PA21_RTS0);
+		else
+			at91_sys_write(AT91_PIOA + PIO_SODR, AT91_PA21_RTS0);
+	}
+
+	if (mctrl & TIOCM_RTS)
+		control |= AT91_US_RTSEN;
+	else
+		control |= AT91_US_RTSDIS;
+
+	if (mctrl & TIOCM_DTR)
+		control |= AT91_US_DTREN;
+	else
+		control |= AT91_US_DTRDIS;
+
+	UART_PUT_CR(port,control);
+}
+
+/*
+ * Get state of the modem control input lines
+ */
+static u_int at91_get_mctrl(struct uart_port *port)
+{
+	unsigned int status, ret = 0;
+
+	status = UART_GET_CSR(port);
+	
+	/*
+	 * The control signals are active low.
+	 */
+	if (!(status & AT91_US_DCD))
+		ret |= TIOCM_CD;
+	if (!(status & AT91_US_CTS))
+		ret |= TIOCM_CTS;
+	if (!(status & AT91_US_DSR))
+		ret |= TIOCM_DSR;
+	if (!(status & AT91_US_RI))
+		ret |= TIOCM_RI;
+
+	return ret;
+}
+
+/*
+ * Stop transmitting.
+ */
+static void at91_stop_tx(struct uart_port *port)
+{
+	UART_PUT_IDR(port, AT91_US_TXRDY);
+	port->read_status_mask &= ~AT91_US_TXRDY;
+}
+
+/*
+ * Start transmitting.
+ */
+static void at91_start_tx(struct uart_port *port)
+{
+	port->read_status_mask |= AT91_US_TXRDY;
+	UART_PUT_IER(port, AT91_US_TXRDY);
+}
+
+/*
+ * Stop receiving - port is in process of being closed.
+ */
+static void at91_stop_rx(struct uart_port *port)
+{
+	UART_PUT_IDR(port, AT91_US_RXRDY);
+}
+
+/*
+ * Enable modem status interrupts
+ */
+static void at91_enable_ms(struct uart_port *port)
+{
+	port->read_status_mask |= (AT91_US_RIIC | AT91_US_DSRIC | AT91_US_DCDIC | AT91_US_CTSIC);
+	UART_PUT_IER(port, AT91_US_RIIC | AT91_US_DSRIC | AT91_US_DCDIC | AT91_US_CTSIC);
+}
+
+/*
+ * Control the transmission of a break signal
+ */
+static void at91_break_ctl(struct uart_port *port, int break_state)
+{
+	if (break_state != 0)
+		UART_PUT_CR(port, AT91_US_STTBRK);	/* start break */
+	else
+		UART_PUT_CR(port, AT91_US_STPBRK);	/* stop break */
+}
+
+/*
+ * Characters received (called from interrupt handler)
+ */
+static void at91_rx_chars(struct uart_port *port, struct pt_regs *regs)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int status, ch, flg;
+
+	status = UART_GET_CSR(port) & port->read_status_mask;
+	while (status & (AT91_US_RXRDY)) {
+		ch = UART_GET_CHAR(port);
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		port->icount.rx++;
+
+		flg = TTY_NORMAL;
+
+		/*
+		 * note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (unlikely(status & (AT91_US_PARE | AT91_US_FRAME | AT91_US_OVRE))) {
+			UART_PUT_CR(port, AT91_US_RSTSTA);	/* clear error */
+			if (status & (AT91_US_PARE))
+				port->icount.parity++;
+			if (status & (AT91_US_FRAME))
+				port->icount.frame++;
+			if (status & (AT91_US_OVRE))
+				port->icount.overrun++;
+
+			if (status & AT91_US_PARE)
+				flg = TTY_PARITY;
+			else if (status & AT91_US_FRAME)
+				flg = TTY_FRAME;
+			if (status & AT91_US_OVRE) {
+				/*
+				 * overrun does *not* affect the character
+				 * we read from the FIFO
+				 */
+				tty_insert_flip_char(tty, ch, flg);
+				ch = 0;
+				flg = TTY_OVERRUN;
+			}
+#ifdef SUPPORT_SYSRQ
+			port->sysrq = 0;
+#endif
+		}
+
+		if (uart_handle_sysrq_char(port, ch, regs))
+			goto ignore_char;
+
+		tty_insert_flip_char(tty, ch, flg);
+
+	ignore_char:
+		status = UART_GET_CSR(port) & port->read_status_mask;
+	}
+
+	tty_flip_buffer_push(tty);
+}
+
+/*
+ * Transmit characters (called from interrupt handler)
+ */
+static void at91_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+
+	if (port->x_char) {
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		at91_stop_tx(port);
+		return;
+	}
+
+	while (UART_GET_CSR(port) & AT91_US_TXRDY) {
+		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		at91_stop_tx(port);
+}
+
+/*
+ * Interrupt handler
+ */
+static irqreturn_t at91_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	unsigned int status, pending, pass_counter = 0;
+
+	status = UART_GET_CSR(port);
+	pending = status & port->read_status_mask;
+	if (pending) {
+		do {
+			if (pending & AT91_US_RXRDY)
+				at91_rx_chars(port, regs);
+
+			/* Clear the relevent break bits */
+			if (pending & AT91_US_RXBRK) {
+				UART_PUT_CR(port, AT91_US_RSTSTA);
+				port->icount.brk++;
+				uart_handle_break(port);
+			}
+
+			// TODO: All reads to CSR will clear these interrupts!
+			if (pending & AT91_US_RIIC) port->icount.rng++;
+			if (pending & AT91_US_DSRIC) port->icount.dsr++;
+			if (pending & AT91_US_DCDIC)
+				uart_handle_dcd_change(port, !(status & AT91_US_DCD));
+			if (pending & AT91_US_CTSIC)
+				uart_handle_cts_change(port, !(status & AT91_US_CTS));
+			if (pending & (AT91_US_RIIC | AT91_US_DSRIC | AT91_US_DCDIC | AT91_US_CTSIC))
+				wake_up_interruptible(&port->info->delta_msr_wait);
+
+			if (pending & AT91_US_TXRDY)
+				at91_tx_chars(port);
+			if (pass_counter++ > AT91_ISR_PASS_LIMIT)
+				break;
+
+			status = UART_GET_CSR(port);
+			pending = status & port->read_status_mask;
+		} while (pending);
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * Perform initialization and enable port for reception
+ */
+static int at91_startup(struct uart_port *port)
+{
+	int retval;
+
+	/*
+	 * Ensure that no interrupts are enabled otherwise when
+	 * request_irq() is called we could get stuck trying to
+	 * handle an unexpected interrupt.
+	 */
+	UART_PUT_IDR(port, -1);
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(port->irq, at91_interrupt, SA_SHIRQ, "at91_serial", port);
+	if (retval) {
+		printk("at91_serial: at91_startup - Can't get irq\n");
+		return retval;
+	}
+
+	/*
+	 * If there is a specific "open" function (to register
+	 * control line interrupts)
+	 */
+	if (at91_open) {
+		retval = at91_open(port);
+		if (retval) {
+			free_irq(port->irq, port);
+			return retval;
+		}
+	}
+
+	port->read_status_mask = AT91_US_RXRDY | AT91_US_TXRDY | AT91_US_OVRE
+			| AT91_US_FRAME | AT91_US_PARE | AT91_US_RXBRK;
+	/*
+	 * Finally, enable the serial port
+	 */
+	UART_PUT_CR(port, AT91_US_RSTSTA | AT91_US_RSTRX);
+	UART_PUT_CR(port, AT91_US_TXEN | AT91_US_RXEN);		/* enable xmit & rcvr */
+	UART_PUT_IER(port, AT91_US_RXRDY);			/* do receive only */
+	return 0;
+}
+
+/*
+ * Disable the port
+ */
+static void at91_shutdown(struct uart_port *port)
+{
+	/*
+	 * Disable all interrupts, port and break condition.
+	 */
+	UART_PUT_CR(port, AT91_US_RSTSTA);
+	UART_PUT_IDR(port, -1);
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(port->irq, port);
+
+	/*
+	 * If there is a specific "close" function (to unregister
+	 * control line interrupts)
+	 */
+	if (at91_close)
+		at91_close(port);
+}
+
+/*
+ * Power / Clock management.
+ */
+static void at91_serial_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+	switch (state) {
+		case 0:
+			/*
+			 * Enable the peripheral clock for this serial port.
+			 * This is called on uart_open() or a resume event.
+			 */
+			at91_sys_write(AT91_PMC_PCER, 1 << port->irq);
+			break;
+		case 3:
+			/*
+			 * Disable the peripheral clock for this serial port.
+			 * This is called on uart_close() or a suspend event.
+			 */
+			if (port->irq != AT91_ID_SYS)			/* is this a shared clock? */
+				at91_sys_write(AT91_PMC_PCDR, 1 << port->irq);
+			break;
+		default:
+			printk(KERN_ERR "at91_serial: unknown pm %d\n", state);
+	}
+}
+
+/*
+ * Change the port parameters
+ */
+static void at91_set_termios(struct uart_port *port, struct termios * termios, struct termios * old)
+{
+	unsigned long flags;
+	unsigned int mode, imr, quot, baud;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	/* Get current mode register */
+	mode = UART_GET_MR(port) & ~(AT91_US_CHRL | AT91_US_NBSTOP | AT91_US_PAR);
+
+	/* byte size */
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		mode |= AT91_US_CHRL_5;
+		break;
+	case CS6:
+		mode |= AT91_US_CHRL_6;
+		break;
+	case CS7:
+		mode |= AT91_US_CHRL_7;
+		break;
+	default:
+		mode |= AT91_US_CHRL_8;
+		break;
+	}
+
+	/* stop bits */
+	if (termios->c_cflag & CSTOPB)
+		mode |= AT91_US_NBSTOP_2;
+
+	/* parity */
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & CMSPAR) {			/* Mark or Space parity */
+			if (termios->c_cflag & PARODD)
+				mode |= AT91_US_PAR_MARK;
+			else
+				mode |= AT91_US_PAR_SPACE;
+		}
+		else if (termios->c_cflag & PARODD)
+			mode |= AT91_US_PAR_ODD;
+		else
+			mode |= AT91_US_PAR_EVEN;
+	}
+	else
+		mode |= AT91_US_PAR_NONE;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	port->read_status_mask |= AT91_US_OVRE;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= AT91_US_FRAME | AT91_US_PARE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= AT91_US_RXBRK;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= (AT91_US_FRAME | AT91_US_PARE);
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= AT91_US_RXBRK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= AT91_US_OVRE;
+	}
+
+	// TODO: Ignore all characters if CREAD is set.
+
+	/* update the per-port timeout */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/* disable interrupts and drain transmitter */
+	imr = UART_GET_IMR(port);	/* get interrupt mask */
+	UART_PUT_IDR(port, -1);		/* disable all interrupts */
+	while (!(UART_GET_CSR(port) & AT91_US_TXEMPTY)) { barrier(); }
+
+	/* disable receiver and transmitter */
+	UART_PUT_CR(port, AT91_US_TXDIS | AT91_US_RXDIS);
+
+	/* set the parity, stop bits and data size */
+	UART_PUT_MR(port, mode);
+
+	/* set the baud rate */
+	UART_PUT_BRGR(port, quot);
+	UART_PUT_CR(port, AT91_US_RSTSTA | AT91_US_RSTRX);
+	UART_PUT_CR(port, AT91_US_TXEN | AT91_US_RXEN);
+
+	/* restore interrupts */
+	UART_PUT_IER(port, imr);
+
+	/* CTS flow-control and modem-status interrupts */
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		port->ops->enable_ms(port);
+		
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/*
+ * Return string describing the specified port
+ */
+static const char *at91_type(struct uart_port *port)
+{
+	return (port->type == PORT_AT91RM9200) ? "AT91_SERIAL" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void at91_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase,
+		(port->mapbase == AT91_VA_BASE_DBGU) ? 512 : SZ_16K);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int at91_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase,
+		(port->mapbase == AT91_VA_BASE_DBGU) ? 512 : SZ_16K,
+		"at91_serial") != NULL ? 0 : -EBUSY;
+
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void at91_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_AT91RM9200;
+		at91_request_port(port);
+	}
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int at91_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_AT91RM9200)
+		ret = -EINVAL;
+	if (port->irq != ser->irq)
+		ret = -EINVAL;
+	if (ser->io_type != SERIAL_IO_MEM)
+		ret = -EINVAL;
+	if (port->uartclk / 16 != ser->baud_base)
+		ret = -EINVAL;
+	if ((void *)port->mapbase != ser->iomem_base)
+		ret = -EINVAL;
+	if (port->iobase != ser->port)
+		ret = -EINVAL;
+	if (ser->hub6 != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops at91_pops = {
+	.tx_empty	= at91_tx_empty,
+	.set_mctrl	= at91_set_mctrl,
+	.get_mctrl	= at91_get_mctrl,
+	.stop_tx	= at91_stop_tx,
+	.start_tx	= at91_start_tx,
+	.stop_rx	= at91_stop_rx,
+	.enable_ms	= at91_enable_ms,
+	.break_ctl	= at91_break_ctl,
+	.startup	= at91_startup,
+	.shutdown	= at91_shutdown,
+	.set_termios	= at91_set_termios,
+	.type		= at91_type,
+	.release_port	= at91_release_port,
+	.request_port	= at91_request_port,
+	.config_port 	= at91_config_port,
+	.verify_port 	= at91_verify_port,
+	.pm		= at91_serial_pm,
+};
+
+static struct uart_port at91_ports[AT91_NR_UART];
+
+void __init at91_init_ports(void)
+{
+	static int first = 1;
+	int i;
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < AT91_NR_UART; i++) {
+		at91_ports[i].iotype	= UPIO_MEM;
+		at91_ports[i].flags     = UPF_BOOT_AUTOCONF;
+		at91_ports[i].uartclk   = at91_master_clock;
+		at91_ports[i].ops	= &at91_pops;
+		at91_ports[i].fifosize  = 1;
+		at91_ports[i].line	= i;
+ 	}
+}
+
+void __init at91_register_uart_fns(struct at91rm9200_port_fns *fns)
+{
+	if (fns->enable_ms)
+		at91_pops.enable_ms = fns->enable_ms;
+	if (fns->get_mctrl)
+		at91_pops.get_mctrl = fns->get_mctrl;
+	if (fns->set_mctrl)
+		at91_pops.set_mctrl = fns->set_mctrl;
+	at91_open          = fns->open;
+	at91_close         = fns->close;
+	at91_pops.pm       = fns->pm;
+	at91_pops.set_wake = fns->set_wake;
+}
+
+/*
+ * Setup ports.
+ */
+void __init at91_register_uart(int idx, int port)
+{
+	if ((idx < 0) || (idx >= AT91_NR_UART)) {
+		printk(KERN_ERR "%s: bad index number %d\n", __FUNCTION__, idx);
+		return;
+	}
+
+	switch (port) {
+	case 0:
+		at91_ports[idx].membase = (void __iomem *) AT91_VA_BASE_US0;
+		at91_ports[idx].mapbase = AT91_VA_BASE_US0;
+		at91_ports[idx].irq     = AT91_ID_US0;
+		AT91_CfgPIO_USART0();
+		break;
+	case 1:
+		at91_ports[idx].membase = (void __iomem *) AT91_VA_BASE_US1;
+		at91_ports[idx].mapbase = AT91_VA_BASE_US1;
+		at91_ports[idx].irq     = AT91_ID_US1;
+		AT91_CfgPIO_USART1();
+		break;
+	case 2:
+		at91_ports[idx].membase = (void __iomem *) AT91_VA_BASE_US2;
+		at91_ports[idx].mapbase = AT91_VA_BASE_US2;
+		at91_ports[idx].irq     = AT91_ID_US2;
+		AT91_CfgPIO_USART2();
+		break;
+	case 3:
+		at91_ports[idx].membase = (void __iomem *) AT91_VA_BASE_US3;
+		at91_ports[idx].mapbase = AT91_VA_BASE_US3;
+		at91_ports[idx].irq     = AT91_ID_US3;
+		AT91_CfgPIO_USART3();
+		break;
+	case 4:
+		at91_ports[idx].membase = (void __iomem *) AT91_VA_BASE_DBGU;
+		at91_ports[idx].mapbase = AT91_VA_BASE_DBGU;
+		at91_ports[idx].irq     = AT91_ID_SYS;
+		AT91_CfgPIO_DBGU();
+		break;
+	default:
+		printk(KERN_ERR  "%s : bad port number %d\n", __FUNCTION__, port);
+	}
+}
+
+#ifdef CONFIG_SERIAL_AT91_CONSOLE
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void at91_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = at91_ports + co->index;
+	unsigned int status, i, imr;
+
+	/*
+	 *	First, save IMR and then disable interrupts
+	 */
+	imr = UART_GET_IMR(port);	/* get interrupt mask */
+	UART_PUT_IDR(port, AT91_US_RXRDY | AT91_US_TXRDY);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			status = UART_GET_CSR(port);
+		} while (!(status & AT91_US_TXRDY));
+		UART_PUT_CHAR(port, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = UART_GET_CSR(port);
+			} while (!(status & AT91_US_TXRDY));
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore IMR
+	 */
+	do {
+		status = UART_GET_CSR(port);
+	} while (!(status & AT91_US_TXRDY));
+	UART_PUT_IER(port, imr);	/* set interrupts back the way they were */
+}
+
+/*
+ * If the port was already initialised (eg, by a boot loader), try to determine
+ * the current setup.
+ */
+static void __init at91_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	unsigned int mr, quot;
+
+// TODO: CR is a write-only register
+//	unsigned int cr;
+//
+//	cr = UART_GET_CR(port) & (AT91_US_RXEN | AT91_US_TXEN);
+//	if (cr == (AT91_US_RXEN | AT91_US_TXEN)) {
+//		/* ok, the port was enabled */
+//	}
+
+	mr = UART_GET_MR(port) & AT91_US_CHRL;
+	if (mr == AT91_US_CHRL_8)
+		*bits = 8;
+	else
+		*bits = 7;
+
+	mr = UART_GET_MR(port) & AT91_US_PAR;
+	if (mr == AT91_US_PAR_EVEN)
+		*parity = 'e';
+	else if (mr == AT91_US_PAR_ODD)
+		*parity = 'o';
+
+	quot = UART_GET_BRGR(port);
+	*baud = port->uartclk / (16 * (quot));
+}
+
+static int __init at91_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(at91_ports, AT91_NR_UART, co);
+
+	/*
+	 * Enable the serial console, in-case bootloader did not do it.
+	 */
+	at91_sys_write(AT91_PMC_PCER, 1 << port->irq);	/* enable clock */
+	UART_PUT_IDR(port, -1);				/* disable interrupts */
+	UART_PUT_CR(port, AT91_US_RSTSTA | AT91_US_RSTRX);
+	UART_PUT_CR(port, AT91_US_TXEN | AT91_US_RXEN);
+	
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		at91_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver at91_uart;
+
+static struct console at91_console = {
+	.name		= AT91_DEVICENAME,
+	.write		= at91_console_write,
+	.device		= uart_console_device,
+	.setup		= at91_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &at91_uart,
+};
+
+#define AT91_CONSOLE_DEVICE	&at91_console
+
+static int  __init at91_console_init(void)
+{
+	at91_init_ports();
+
+	at91_console.index = at91_console_port;
+	register_console(&at91_console);
+	return 0;
+}
+console_initcall(at91_console_init);
+
+#else
+#define AT91_CONSOLE_DEVICE	NULL
+#endif
+
+static struct uart_driver at91_uart = {
+	.owner			= THIS_MODULE,
+	.driver_name		= AT91_DEVICENAME,
+	.dev_name		= AT91_DEVICENAME,
+	.devfs_name		= AT91_DEVICENAME,
+	.major			= SERIAL_AT91_MAJOR,
+	.minor			= MINOR_START,
+	.nr			= AT91_NR_UART,
+	.cons			= AT91_CONSOLE_DEVICE,
+};
+
+static int __init at91_serial_init(void)
+{
+	int ret, i;
+
+	at91_init_ports();
+
+	ret = uart_register_driver(&at91_uart);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < AT91_NR_UART; i++) {
+		if (at91_serial_map[i] >= 0)
+			uart_add_one_port(&at91_uart, &at91_ports[i]);
+	}
+
+	return 0;
+}
+
+static void __exit at91_serial_exit(void)
+{
+	int i;
+
+	for (i = 0; i < AT91_NR_UART; i++) {
+ 		if (at91_serial_map[i] >= 0)
+			uart_remove_one_port(&at91_uart, &at91_ports[i]);
+  	}
+
+	uart_unregister_driver(&at91_uart);
+}
+
+module_init(at91_serial_init);
+module_exit(at91_serial_exit);
+
+MODULE_AUTHOR("Rick Bronson");
+MODULE_DESCRIPTION("AT91 generic serial port driver");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.15.orig/drivers/usb/Kconfig linux-2.6.15/drivers/usb/Kconfig
--- linux-2.6.15.orig/drivers/usb/Kconfig	Mon Oct 31 09:50:13 2005
+++ linux-2.6.15/drivers/usb/Kconfig	Wed Jan 11 10:42:46 2006
@@ -22,6 +22,7 @@
 	default y if ARCH_LH7A404
 	default y if ARCH_S3C2410
 	default y if PXA27x
+	default y if ARCH_AT91RM9200
 	# PPC:
 	default y if STB03xxx
 	default y if PPC_MPC52xx
diff -urN linux-2.6.15.orig/drivers/usb/Makefile linux-2.6.15/drivers/usb/Makefile
--- linux-2.6.15.orig/drivers/usb/Makefile	Wed Jan 11 09:19:20 2006
+++ linux-2.6.15/drivers/usb/Makefile	Wed Jan 11 10:42:46 2006
@@ -15,6 +15,7 @@
 obj-$(CONFIG_USB_UHCI_HCD)	+= host/
 obj-$(CONFIG_USB_SL811_HCD)	+= host/
 obj-$(CONFIG_ETRAX_USB_HOST)	+= host/
+obj-$(CONFIG_USB_OHCI_AT91)	+= host/
 
 obj-$(CONFIG_USB_ACM)		+= class/
 obj-$(CONFIG_USB_AUDIO)		+= class/
diff -urN linux-2.6.15.orig/drivers/usb/gadget/Kconfig linux-2.6.15/drivers/usb/gadget/Kconfig
--- linux-2.6.15.orig/drivers/usb/gadget/Kconfig	Mon Oct 31 09:50:13 2005
+++ linux-2.6.15/drivers/usb/gadget/Kconfig	Wed Jan 11 10:42:46 2006
@@ -187,6 +187,23 @@
 
 	   Select this only if your OMAP board has a Mini-AB connector.
 
+config USB_GADGET_AT91
+	boolean "AT91 USB Device Port"
+	depends on ARCH_AT91RM9200
+	select USB_GADGET_SELECTED
+	help
+	   Many Atmel AT91 processors (such as the AT91RM2000) have a
+	   full speed USB Device Port with support for five configurable
+	   endpoints (plus endpoint zero).
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "at91_udc" and force all
+	   gadget drivers to also be dynamically linked.
+
+config USB_AT91
+	tristate
+	depends on USB_GADGET_AT91
+	default USB_GADGET
 
 config USB_GADGET_DUMMY_HCD
 	boolean "Dummy HCD (DEVELOPMENT)"
diff -urN linux-2.6.15.orig/drivers/usb/gadget/Makefile linux-2.6.15/drivers/usb/gadget/Makefile
--- linux-2.6.15.orig/drivers/usb/gadget/Makefile	Mon Oct 31 09:46:38 2005
+++ linux-2.6.15/drivers/usb/gadget/Makefile	Wed Jan 11 10:42:46 2006
@@ -7,6 +7,7 @@
 obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
 obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
 obj-$(CONFIG_USB_LH7A40X)	+= lh7a40x_udc.o
+obj-$(CONFIG_USB_AT91)		+= at91_udc.o
 
 #
 # USB gadget drivers
diff -urN linux-2.6.15.orig/drivers/usb/gadget/at91_udc.c linux-2.6.15/drivers/usb/gadget/at91_udc.c
--- linux-2.6.15.orig/drivers/usb/gadget/at91_udc.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/usb/gadget/at91_udc.c	Wed Jan 11 11:47:12 2006
@@ -0,0 +1,1774 @@
+/*
+ * at91_udc -- driver for at91-series USB peripheral controller
+ *
+ * Copyright (C) 2004 by Thomas Rathbone
+ * Copyright (C) 2005 by HP Labs
+ * Copyright (C) 2005 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA  02111-1307, USA.
+ */
+
+#undef	DEBUG
+#undef	VERBOSE
+#undef	PACKET_TRACE
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <asm/hardware/clock.h>
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/at91rm9200_udp.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/board.h>
+
+#include "at91_udc.h"
+
+
+/*
+ * This controller is simple and PIO-only.  It's used in many AT91-series
+ * ARMv4T controllers, including the at91rm9200 (arm920T, with MMU) and
+ * several no-mmu versions.
+ *
+ * This driver expects the board has been wired with two GPIOs suppporting
+ * a VBUS sensing IRQ, and a D+ pullup.  (They may be omitted, but the
+ * testing hasn't covered such cases.)  The pullup is most important; it
+ * provides software control over whether the host enumerates the device.
+ * The VBUS sensing helps during enumeration, and allows both USB clocks
+ * (and the transceiver) to stay gated off until they're necessary, saving
+ * power.  During USB suspend, the 48 MHz clock is gated off.
+ */
+
+#define	DRIVER_VERSION	"8 March 2005"
+
+static const char driver_name [] = "at91_udc";
+static const char ep0name[] = "ep0";
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Read from a UDP register.
+ */
+static inline unsigned long at91_udp_read(unsigned int reg)
+{
+	void __iomem *udp_base = (void __iomem *)AT91_VA_BASE_UDP;
+	
+	return __raw_readl(udp_base + reg);
+}
+
+/*
+ * Write to a UDP register.
+ */
+static inline void at91_udp_write(unsigned int reg, unsigned long value)
+{
+	void __iomem *udp_base = (void __iomem *)AT91_VA_BASE_UDP;
+
+	__raw_writel(value, udp_base + reg);
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char debug_filename[] = "driver/udc";
+
+#define FOURBITS "%s%s%s%s"
+#define EIGHTBITS FOURBITS FOURBITS
+
+static void proc_ep_show(struct seq_file *s, struct at91_ep *ep)
+{
+	static char		*types[] = {
+		"control", "out-iso", "out-bulk", "out-int",
+		"BOGUS",   "in-iso",  "in-bulk",  "in-int"};
+
+	u32			csr;
+	struct at91_request	*req;
+	unsigned long	flags;
+
+	local_irq_save(flags);
+
+	csr = __raw_readl(ep->creg);
+
+	/* NOTE:  not collecting per-endpoint irq statistics... */
+
+	seq_printf(s, "\n");
+	seq_printf(s, "%s, maxpacket %d %s%s %s%s\n",
+			ep->ep.name, ep->ep.maxpacket,
+			ep->is_in ? "in" : "out",
+			ep->is_iso ? " iso" : "",
+			ep->is_pingpong
+				? (ep->fifo_bank ? "pong" : "ping")
+				: "",
+			ep->stopped ? " stopped" : "");
+	seq_printf(s, "csr %08x rxbytes=%d %s %s %s" EIGHTBITS "\n",
+		csr,
+		(csr & 0x07ff0000) >> 16,
+		(csr & (1 << 15)) ? "enabled" : "disabled",
+		(csr & (1 << 11)) ? "DATA1" : "DATA0",
+		types[(csr & 0x700) >> 8],
+
+		/* iff type is control then print current direction */
+		(!(csr & 0x700))
+			? ((csr & (1 << 7)) ? " IN" : " OUT")
+			: "",
+		(csr & (1 << 6)) ? " rxdatabk1" : "",
+		(csr & (1 << 5)) ? " forcestall" : "",
+		(csr & (1 << 4)) ? " txpktrdy" : "",
+
+		(csr & (1 << 3)) ? " stallsent" : "",
+		(csr & (1 << 2)) ? " rxsetup" : "",
+		(csr & (1 << 1)) ? " rxdatabk0" : "",
+		(csr & (1 << 0)) ? " txcomp" : "");
+	if (list_empty (&ep->queue))
+		seq_printf(s, "\t(queue empty)\n");
+
+	else list_for_each_entry (req, &ep->queue, queue) {
+		unsigned	length = req->req.actual;
+
+		seq_printf(s, "\treq %p len %d/%d buf %p\n",
+				&req->req, length,
+				req->req.length, req->req.buf);
+	}
+	local_irq_restore(flags);
+}
+
+static void proc_irq_show(struct seq_file *s, const char *label, u32 mask)
+{
+	int i;
+
+	seq_printf(s, "%s %04x:%s%s" FOURBITS, label, mask,
+		(mask & (1 << 13)) ? " wakeup" : "",
+		(mask & (1 << 12)) ? " endbusres" : "",
+
+		(mask & (1 << 11)) ? " sofint" : "",
+		(mask & (1 << 10)) ? " extrsm" : "",
+		(mask & (1 << 9)) ? " rxrsm" : "",
+		(mask & (1 << 8)) ? " rxsusp" : "");
+	for (i = 0; i < 8; i++) {
+		if (mask & (1 << i))
+			seq_printf(s, " ep%d", i);
+	}
+	seq_printf(s, "\n");
+}
+
+static int proc_udc_show(struct seq_file *s, void *unused)
+{
+	struct at91_udc	*udc = s->private;
+	struct at91_ep	*ep;
+	u32		tmp;
+
+	seq_printf(s, "%s: version %s\n", driver_name, DRIVER_VERSION);
+
+	seq_printf(s, "vbus %s, pullup %s, %s powered%s, gadget %s\n\n",
+		udc->vbus ? "present" : "off",
+		udc->enabled
+			? (udc->vbus ? "active" : "enabled")
+			: "disabled",
+		udc->selfpowered ? "self" : "VBUS",
+		udc->suspended ? ", suspended" : "",
+		udc->driver ? udc->driver->driver.name : "(none)");
+
+	/* don't access registers when interface isn't clocked */
+	if (!udc->clocked) {
+		seq_printf(s, "(not clocked)\n");
+		return 0;
+	}
+
+	tmp = at91_udp_read(AT91_UDP_FRM_NUM);
+	seq_printf(s, "frame %05x:%s%s frame=%d\n", tmp,
+		(tmp & AT91_UDP_FRM_OK) ? " ok" : "",
+		(tmp & AT91_UDP_FRM_ERR) ? " err" : "",
+		(tmp & AT91_UDP_NUM));
+
+	tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+	seq_printf(s, "glbstate %02x:%s" FOURBITS "\n", tmp,
+		(tmp & AT91_UDP_RMWUPE) ? " rmwupe" : "",
+		(tmp & AT91_UDP_RSMINPR) ? " rsminpr" : "",
+		(tmp & AT91_UDP_ESR) ? " esr" : "",
+		(tmp & AT91_UDP_CONFG) ? " confg" : "",
+		(tmp & AT91_UDP_FADDEN) ? " fadden" : "");
+
+	tmp = at91_udp_read(AT91_UDP_FADDR);
+	seq_printf(s, "faddr   %03x:%s fadd=%d\n", tmp,
+		(tmp & AT91_UDP_FEN) ? " fen" : "",
+		(tmp & AT91_UDP_FADD));
+
+	proc_irq_show(s, "imr   ", at91_udp_read(AT91_UDP_IMR));
+	proc_irq_show(s, "isr   ", at91_udp_read(AT91_UDP_ISR));
+
+	if (udc->enabled && udc->vbus) {
+		proc_ep_show(s, &udc->ep[0]);
+		list_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {
+			if (ep->desc)
+				proc_ep_show(s, ep);
+		}
+	}
+	return 0;
+}
+
+static int proc_udc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_udc_show, PDE(inode)->data);
+}
+
+static struct file_operations proc_ops = {
+	.open		= proc_udc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void create_debug_file(struct at91_udc *udc)
+{
+	struct proc_dir_entry *pde;
+
+	pde = create_proc_entry (debug_filename, 0, NULL);
+	udc->pde = pde;
+	if (pde == NULL)
+		return;
+
+	pde->proc_fops = &proc_ops;
+	pde->data = udc;
+}
+
+static void remove_debug_file(struct at91_udc *udc)
+{
+	if (udc->pde)
+		remove_proc_entry(debug_filename, NULL);
+}
+
+#else
+
+static inline void create_debug_file(struct at91_udc *udc) {}
+static inline void remove_debug_file(struct at91_udc *udc) {}
+
+#endif
+
+
+/*-------------------------------------------------------------------------*/
+
+static void done(struct at91_ep *ep, struct at91_request *req, int status)
+{
+	unsigned	stopped = ep->stopped;
+
+	list_del_init(&req->queue);
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+	if (status && status != -ESHUTDOWN)
+		VDBG("%s done %p, status %d\n", ep->ep.name, req, status);
+
+	ep->stopped = 1;
+	req->req.complete(&ep->ep, &req->req);
+	ep->stopped = stopped;
+
+	/* ep0 is always ready; other endpoints need a non-empty queue */
+	if (list_empty(&ep->queue) && ep->int_mask != (1 << 0))
+		at91_udp_write(AT91_UDP_IDR, ep->int_mask);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* bits indicating OUT fifo has data ready */
+#define	RX_DATA_READY	(AT91_UDP_RX_DATA_BK0 | AT91_UDP_RX_DATA_BK1)
+
+/*
+ * Endpoint FIFO CSR bits have a mix of bits, making it unsafe to just write
+ * back most of the value you just read (because of side effects, including
+ * bits that may change after reading and before writing).
+ *
+ * Except when changing a specific bit, always write values which:
+ *  - clear SET_FX bits (setting them could change something)
+ *  - set CLR_FX bits (clearing them could change something)
+ *
+ * There are also state bits like FORCESTALL, EPEDS, DIR, and EPTYPE
+ * that shouldn't normally be changed.
+ */
+#define	SET_FX	(AT91_UDP_TXPKTRDY)
+#define	CLR_FX	(RX_DATA_READY | AT91_UDP_RXSETUP | AT91_UDP_STALLSENT | AT91_UDP_TXCOMP)
+
+/* pull OUT packet data from the endpoint's fifo */
+static int read_fifo (struct at91_ep *ep, struct at91_request *req)
+{
+	u32 __iomem	*creg = ep->creg;
+	u8 __iomem	*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));
+	u32		csr;
+	u8		*buf;
+	unsigned int	count, bufferspace, is_done;
+
+	buf = req->req.buf + req->req.actual;
+	bufferspace = req->req.length - req->req.actual;
+
+	/*
+	 * there might be nothing to read if ep_queue() calls us,
+	 * or if we already emptied both pingpong buffers
+	 */
+rescan:
+	csr = __raw_readl(creg);
+	if ((csr & RX_DATA_READY) == 0)
+		return 0;
+
+	count = (csr & AT91_UDP_RXBYTECNT) >> 16;
+	if (count > ep->ep.maxpacket)
+		count = ep->ep.maxpacket;
+	if (count > bufferspace) {
+		DBG("%s buffer overflow\n", ep->ep.name);
+		req->req.status = -EOVERFLOW;
+		count = bufferspace;
+	}
+	__raw_readsb(dreg, buf, count);
+
+	/* release and swap pingpong mem bank */
+	csr |= CLR_FX;
+	if (ep->is_pingpong) {
+		if (ep->fifo_bank == 0) {
+			csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);
+			ep->fifo_bank = 1;
+		} else {
+			csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK1);
+			ep->fifo_bank = 0;
+		}
+	} else
+		csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);
+	__raw_writel(csr, creg);
+
+	req->req.actual += count;
+	is_done = (count < ep->ep.maxpacket);
+	if (count == bufferspace)
+		is_done = 1;
+
+	PACKET("%s %p out/%d%s\n", ep->ep.name, &req->req, count,
+			is_done ? " (done)" : "");
+
+	/*
+	 * avoid extra trips through IRQ logic for packets already in
+	 * the fifo ... maybe preventing an extra (expensive) OUT-NAK
+	 */
+	if (is_done)
+		done(ep, req, 0);
+	else if (ep->is_pingpong) {
+		bufferspace -= count;
+		buf += count;
+		goto rescan;
+	}
+
+	return is_done;
+}
+
+/* load fifo for an IN packet */
+static int write_fifo(struct at91_ep *ep, struct at91_request *req)
+{
+	u32 __iomem	*creg = ep->creg;
+	u32		csr = __raw_readl(creg);
+	u8 __iomem	*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));
+	unsigned	total, count, is_last;
+
+	/*
+	 * TODO: allow for writing two packets to the fifo ... that'll
+	 * reduce the amount of IN-NAKing, but probably won't affect
+	 * throughput much.  (Unlike preventing OUT-NAKing!)
+	 */
+
+	/*
+	 * If ep_queue() calls us, the queue is empty and possibly in
+	 * odd states like TXCOMP not yet cleared (we do it, saving at
+	 * least one IRQ) or the fifo not yet being free.  Those aren't
+	 * issues normally (IRQ handler fast path).
+	 */
+	if (unlikely(csr & (AT91_UDP_TXCOMP | AT91_UDP_TXPKTRDY))) {
+		if (csr & AT91_UDP_TXCOMP) {
+			csr |= CLR_FX;
+			csr &= ~(SET_FX | AT91_UDP_TXCOMP);
+			__raw_writel(csr, creg);
+			csr = __raw_readl(creg);
+		}
+		if (csr & AT91_UDP_TXPKTRDY)
+			return 0;
+	}
+
+	total = req->req.length - req->req.actual;
+	if (ep->ep.maxpacket < total) {
+		count = ep->ep.maxpacket;
+		is_last = 0;
+	} else {
+		count = total;
+		is_last = (count < ep->ep.maxpacket) || !req->req.zero;
+	}
+
+	/*
+	 * Write the packet, maybe it's a ZLP.
+	 *
+	 * NOTE:  incrementing req->actual before we receive the ACK means
+	 * gadget driver IN bytecounts can be wrong in fault cases.  That's
+	 * fixable with PIO drivers like this one (save "count" here, and
+	 * do the increment later on TX irq), but not for most DMA hardware.
+	 *
+	 * So all gadget drivers must accept that potential error.  Some
+	 * hardware supports precise fifo status reporting, letting them
+	 * recover when the actual bytecount matters (e.g. for USB Test
+	 * and Measurement Class devices).
+	 */
+	__raw_writesb(dreg, req->req.buf + req->req.actual, count);
+	csr &= ~SET_FX;
+	csr |= CLR_FX | AT91_UDP_TXPKTRDY;
+	__raw_writel(csr, creg);
+	req->req.actual += count;
+
+	PACKET("%s %p in/%d%s\n", ep->ep.name, &req->req, count,
+			is_last ? " (done)" : "");
+	if (is_last)
+		done(ep, req, 0);
+	return is_last;
+}
+
+static void nuke(struct at91_ep *ep, int status)
+{
+	struct at91_request *req;
+
+	// terminer chaque requete dans la queue
+	ep->stopped = 1;
+	if (list_empty(&ep->queue))
+		return;
+
+	VDBG("%s %s\n", __FUNCTION__, ep->ep.name);
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct at91_request, queue);
+		done(ep, req, status);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int at91_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+{
+	struct at91_ep	*ep = container_of(_ep, struct at91_ep, ep);
+	struct at91_udc	*dev = ep->udc;
+	u16		maxpacket;
+	u32		tmp;
+	unsigned long	flags;
+
+	if (!_ep || !ep
+			|| !desc || ep->desc
+			|| _ep->name == ep0name
+			|| desc->bDescriptorType != USB_DT_ENDPOINT
+			|| (maxpacket = le16_to_cpu(desc->wMaxPacketSize)) == 0
+			|| maxpacket > ep->maxpacket) {
+		DBG("bad ep or descriptor\n");
+		return -EINVAL;
+	}
+
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DBG("bogus device state\n");
+		return -ESHUTDOWN;
+	}
+
+	tmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	switch (tmp) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		DBG("only one control endpoint\n");
+		return -EINVAL;
+	case USB_ENDPOINT_XFER_INT:
+		if (maxpacket > 64)
+			goto bogus_max;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		switch (maxpacket) {
+		case 8:
+		case 16:
+		case 32:
+		case 64:
+			goto ok;
+		}
+bogus_max:
+		DBG("bogus maxpacket %d\n", maxpacket);
+		return -EINVAL;
+	case USB_ENDPOINT_XFER_ISOC:
+		if (!ep->is_pingpong) {
+			DBG("iso requires double buffering\n");
+			return -EINVAL;
+		}
+		break;
+	}
+
+ok:
+	local_irq_save(flags);
+
+	/* initialize endpoint to match this descriptor */
+	ep->is_in = (desc->bEndpointAddress & USB_DIR_IN) != 0;
+	ep->is_iso = (tmp == USB_ENDPOINT_XFER_ISOC);
+	ep->stopped = 0;
+	if (ep->is_in)
+		tmp |= 0x04;
+	tmp <<= 8;
+	tmp |= AT91_UDP_EPEDS;
+	__raw_writel(tmp, ep->creg);
+
+	ep->desc = desc;
+	ep->ep.maxpacket = maxpacket;
+
+	/*
+	 * reset/init endpoint fifo.  NOTE:  leaves fifo_bank alone,
+	 * since endpoint resets don't reset hw pingpong state.
+	 */
+	at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+	at91_udp_write(AT91_UDP_RST_EP, 0);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int at91_ep_disable (struct usb_ep * _ep)
+{
+	struct at91_ep	*ep = container_of(_ep, struct at91_ep, ep);
+	unsigned long	flags;
+
+	if (ep == &ep->udc->ep[0])
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	nuke(ep, -ESHUTDOWN);
+
+	/* restore the endpoint's pristine config */
+	ep->desc = NULL;
+	ep->ep.maxpacket = ep->maxpacket;
+
+	/* reset fifos and endpoint */
+	if (ep->udc->clocked) {
+		at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+		at91_udp_write(AT91_UDP_RST_EP, 0);
+		__raw_writel(0, ep->creg);
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+/*
+ * this is a PIO-only driver, so there's nothing
+ * interesting for request or buffer allocation.
+ */
+
+static struct usb_request *at91_ep_alloc_request (struct usb_ep *_ep, unsigned int gfp_flags)
+{
+	struct at91_request *req;
+
+	req = kcalloc(1, sizeof (struct at91_request), SLAB_KERNEL);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+static void at91_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct at91_request *req;
+
+	req = container_of(_req, struct at91_request, req);
+	BUG_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+static void *at91_ep_alloc_buffer(
+	struct usb_ep *_ep,
+	unsigned bytes,
+	dma_addr_t *dma,
+	unsigned int gfp_flags)
+{
+	*dma = ~0;
+	return kmalloc(bytes, gfp_flags);
+}
+
+static void at91_ep_free_buffer(
+	struct usb_ep *ep,
+	void *buf,
+	dma_addr_t dma,
+	unsigned bytes)
+{
+	kfree(buf);
+}
+
+static int at91_ep_queue(struct usb_ep *_ep,
+			struct usb_request *_req, unsigned int gfp_flags)
+{
+	struct at91_request	*req;
+	struct at91_ep		*ep;
+	struct at91_udc		*dev;
+	int			status;
+	unsigned long		flags;
+
+	req = container_of(_req, struct at91_request, req);
+	ep = container_of(_ep, struct at91_ep, ep);
+
+	if (!_req || !_req->complete
+			|| !_req->buf || !list_empty(&req->queue)) {
+		DBG("invalid request\n");
+		return -EINVAL;
+	}
+
+	if (!_ep || (!ep->desc && ep->ep.name != ep0name)) {
+		DBG("invalid ep\n");
+		return -EINVAL;
+	}
+
+	dev = ep->udc;
+
+	if (!dev || !dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DBG("invalid device\n");
+		return -EINVAL;
+	}
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	local_irq_save(flags);
+
+	/* try to kickstart any empty and idle queue */
+	if (list_empty(&ep->queue) && !ep->stopped) {
+		int	is_ep0;
+
+		/*
+		 * If this control request has a non-empty DATA stage, this
+		 * will start that stage.  It works just like a non-control
+		 * request (until the status stage starts, maybe early).
+		 *
+		 * If the data stage is empty, then this starts a successful
+		 * IN/STATUS stage.  (Unsuccessful ones use set_halt.)
+		 */
+		is_ep0 = (ep->ep.name == ep0name);
+		if (is_ep0) {
+			u32	tmp;
+
+			if (!dev->req_pending) {
+				status = -EINVAL;
+				goto done;
+			}
+
+			/*
+			 * defer changing CONFG until after the gadget driver
+			 * reconfigures the endpoints.
+			 */
+			if (dev->wait_for_config_ack) {
+				tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+				tmp ^= AT91_UDP_CONFG;
+				VDBG("toggle config\n");
+				at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+			}
+			if (req->req.length == 0) {
+ep0_in_status:
+				PACKET("ep0 in/status\n");
+				status = 0;
+				tmp = __raw_readl(ep->creg);
+				tmp &= ~SET_FX;
+				tmp |= CLR_FX | AT91_UDP_TXPKTRDY;
+				__raw_writel(tmp, ep->creg);
+				dev->req_pending = 0;
+				goto done;
+			}
+		}
+
+		if (ep->is_in)
+			status = write_fifo(ep, req);
+		else {
+			status = read_fifo(ep, req);
+
+			/* IN/STATUS stage is otherwise triggered by irq */
+			if (status && is_ep0)
+				goto ep0_in_status;
+		}
+	} else
+		status = 0;
+
+	if (req && !status) {
+		list_add_tail (&req->queue, &ep->queue);
+		at91_udp_write(AT91_UDP_IER, ep->int_mask);
+	}
+done:
+	local_irq_restore(flags);
+	return (status < 0) ? status : 0;
+}
+
+static int at91_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct at91_ep	*ep;
+	struct at91_request	*req;
+
+	ep = container_of(_ep, struct at91_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req)
+		return -EINVAL;
+
+	done(ep, req, -ECONNRESET);
+	return 0;
+}
+
+static int at91_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct at91_ep	*ep = container_of(_ep, struct at91_ep, ep);
+	u32 __iomem	*creg;
+	u32		csr;
+	unsigned long	flags;
+	int		status = 0;
+
+	if (!_ep || ep->is_iso || !ep->udc->clocked)
+		return -EINVAL;
+
+	creg = ep->creg;
+	local_irq_save(flags);
+
+	csr = __raw_readl(creg);
+
+	/*
+	 * fail with still-busy IN endpoints, ensuring correct sequencing
+	 * of data tx then stall.  note that the fifo rx bytecount isn't
+	 * completely accurate as a tx bytecount.
+	 */
+	if (ep->is_in && (!list_empty(&ep->queue) || (csr >> 16) != 0))
+		status = -EAGAIN;
+	else {
+		csr |= CLR_FX;
+		csr &= ~SET_FX;
+		if (value) {
+			csr |= AT91_UDP_FORCESTALL;
+			VDBG("halt %s\n", ep->ep.name);
+		} else {
+			at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+			at91_udp_write(AT91_UDP_RST_EP, 0);
+			csr &= ~AT91_UDP_FORCESTALL;
+		}
+		__raw_writel(csr, creg);
+	}
+
+	local_irq_restore(flags);
+	return status;
+}
+
+static struct usb_ep_ops at91_ep_ops = {
+	.enable		= at91_ep_enable,
+	.disable	= at91_ep_disable,
+	.alloc_request	= at91_ep_alloc_request,
+	.free_request	= at91_ep_free_request,
+	.alloc_buffer	= at91_ep_alloc_buffer,
+	.free_buffer	= at91_ep_free_buffer,
+	.queue		= at91_ep_queue,
+	.dequeue	= at91_ep_dequeue,
+	.set_halt	= at91_ep_set_halt,
+	// there's only imprecise fifo status reporting
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int at91_get_frame(struct usb_gadget *gadget)
+{
+	if (!to_udc(gadget)->clocked)
+		return -EINVAL;
+	return at91_udp_read(AT91_UDP_FRM_NUM) & AT91_UDP_NUM;
+}
+
+static int at91_wakeup(struct usb_gadget *gadget)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	u32		glbstate;
+	int		status = -EINVAL;
+	unsigned long	flags;
+
+	DBG("%s\n", __FUNCTION__ );
+	local_irq_save(flags);
+
+	if (!udc->clocked || !udc->suspended)
+		goto done;
+
+	/* NOTE:  some "early versions" handle ESR differently ... */
+
+	glbstate = at91_udp_read(AT91_UDP_GLB_STAT);
+	if (!(glbstate & AT91_UDP_ESR))
+		goto done;
+	glbstate |= AT91_UDP_ESR;
+	at91_udp_write(AT91_UDP_GLB_STAT, glbstate);
+
+done:
+	local_irq_restore(flags);
+	return status;
+}
+
+/* reinit == restore inital software state */
+static void udc_reinit(struct at91_udc *udc)
+{
+	u32 i;
+
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	INIT_LIST_HEAD(&udc->gadget.ep0->ep_list);
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct at91_ep *ep = &udc->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+		ep->desc = NULL;
+		ep->stopped = 0;
+		ep->fifo_bank = 0;
+		ep->ep.maxpacket = ep->maxpacket;
+		// initialiser une queue par endpoint
+		INIT_LIST_HEAD(&ep->queue);
+	}
+}
+
+static void stop_activity(struct at91_udc *udc)
+{
+	struct usb_gadget_driver *driver = udc->driver;
+	int i;
+
+	if (udc->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct at91_ep *ep = &udc->ep[i];
+		ep->stopped = 1;
+		nuke(ep, -ESHUTDOWN);
+	}
+	if (driver)
+		driver->disconnect(&udc->gadget);
+
+	udc_reinit(udc);
+}
+
+static void clk_on(struct at91_udc *udc)
+{
+	if (udc->clocked)
+		return;
+	udc->clocked = 1;
+	clk_enable(udc->iclk);
+	clk_enable(udc->fclk);
+}
+
+static void clk_off(struct at91_udc *udc)
+{
+	if (!udc->clocked)
+		return;
+	udc->clocked = 0;
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+	clk_disable(udc->iclk);
+	clk_disable(udc->fclk);
+}
+
+/*
+ * activate/deactivate link with host; minimize power usage for
+ * inactive links by cutting clocks and transceiver power.
+ */
+static void pullup(struct at91_udc *udc, int is_on)
+{
+	if (!udc->enabled || !udc->vbus)
+		is_on = 0;
+	DBG("%sactive\n", is_on ? "" : "in");
+	if (is_on) {
+		clk_on(udc);
+		at91_udp_write(AT91_UDP_TXVC, 0);
+		at91_set_gpio_value(udc->board.pullup_pin, 1);
+	} else  {
+		stop_activity(udc);
+		at91_udp_write(AT91_UDP_TXVC, AT91_UDP_TXVC_TXVDIS);
+		at91_set_gpio_value(udc->board.pullup_pin, 0);
+		clk_off(udc);
+
+		// REVISIT:  with transceiver disabled, will D- float
+		// so that a host would falsely detect a device?
+	}
+}
+
+/* vbus is here!  turn everything on that's ready */
+static int at91_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	unsigned long	flags;
+
+	// VDBG("vbus %s\n", is_active ? "on" : "off");
+	local_irq_save(flags);
+	udc->vbus = (is_active != 0);
+	pullup(udc, is_active);
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int at91_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	unsigned long	flags;
+
+	local_irq_save(flags);
+	udc->enabled = is_on = !!is_on;
+	pullup(udc, is_on);
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int at91_set_selfpowered(struct usb_gadget *gadget, int is_on)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	unsigned long	flags;
+
+	local_irq_save(flags);
+	udc->selfpowered = (is_on != 0);
+	local_irq_restore(flags);
+	return 0;
+}
+
+static const struct usb_gadget_ops at91_udc_ops = {
+	.get_frame		= at91_get_frame,
+	.wakeup			= at91_wakeup,
+	.set_selfpowered	= at91_set_selfpowered,
+	.vbus_session		= at91_vbus_session,
+	.pullup			= at91_pullup,
+
+	/*
+	 * VBUS-powered devices may also also want to support bigger
+	 * power budgets after an appropriate SET_CONFIGURATION.
+	 */
+	// .vbus_power		= at91_vbus_power,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int handle_ep(struct at91_ep *ep)
+{
+	struct at91_request	*req;
+	u32 __iomem		*creg = ep->creg;
+	u32			csr = __raw_readl(creg);
+
+	if (!list_empty(&ep->queue))
+		req = list_entry(ep->queue.next,
+			struct at91_request, queue);
+	else
+		req = NULL;
+
+	if (ep->is_in) {
+		if (csr & (AT91_UDP_STALLSENT | AT91_UDP_TXCOMP)) {
+			csr |= CLR_FX;
+			csr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_TXCOMP);
+			__raw_writel(csr, creg);
+		}
+		if (req)
+			return write_fifo(ep, req);
+
+	} else {
+		if (csr & AT91_UDP_STALLSENT) {
+			/* STALLSENT bit == ISOERR */
+			if (ep->is_iso && req)
+				req->req.status = -EILSEQ;
+			csr |= CLR_FX;
+			csr &= ~(SET_FX | AT91_UDP_STALLSENT);
+			__raw_writel(csr, creg);
+			csr = __raw_readl(creg);
+		}
+		if (req && (csr & RX_DATA_READY))
+			return read_fifo(ep, req);
+	}
+	return 0;
+}
+
+union setup {
+	u8			raw[8];
+	struct usb_ctrlrequest	r;
+};
+
+static void handle_setup(struct at91_udc *udc, struct at91_ep *ep, u32 csr)
+{
+	u32 __iomem	*creg = ep->creg;
+	u8 __iomem	*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));
+	unsigned	rxcount, i = 0;
+	u32		tmp;
+	union setup	pkt;
+	int		status = 0;
+
+	/* read and ack SETUP; hard-fail for bogus packets */
+	rxcount = (csr & AT91_UDP_RXBYTECNT) >> 16;
+	if (likely(rxcount == 8)) {
+		while (rxcount--)
+			pkt.raw[i++] = __raw_readb(dreg);
+		if (pkt.r.bRequestType & USB_DIR_IN) {
+			csr |= AT91_UDP_DIR;
+			ep->is_in = 1;
+		} else {
+			csr &= ~AT91_UDP_DIR;
+			ep->is_in = 0;
+		}
+	} else {
+		// REVISIT this happens sometimes under load; why??
+		ERR("SETUP len %d, csr %08x\n", rxcount, csr);
+		status = -EINVAL;
+	}
+	csr |= CLR_FX;
+	csr &= ~(SET_FX | AT91_UDP_RXSETUP);
+	__raw_writel(csr, creg);
+	udc->wait_for_addr_ack = 0;
+	udc->wait_for_config_ack = 0;
+	ep->stopped = 0;
+	if (unlikely(status != 0))
+		goto stall;
+
+#define w_index		le16_to_cpu(pkt.r.wIndex)
+#define w_value		le16_to_cpu(pkt.r.wValue)
+#define w_length	le16_to_cpu(pkt.r.wLength)
+
+	VDBG("SETUP %02x.%02x v%04x i%04x l%04x\n",
+			pkt.r.bRequestType, pkt.r.bRequest,
+			w_value, w_index, w_length);
+
+	/*
+	 * A few standard requests get handled here, ones that touch
+	 * hardware ... notably for device and endpoint features.
+	 */
+	udc->req_pending = 1;
+	csr = __raw_readl(creg);
+	csr |= CLR_FX;
+	csr &= ~SET_FX;
+	switch ((pkt.r.bRequestType << 8) | pkt.r.bRequest) {
+
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_SET_ADDRESS:
+		__raw_writel(csr | AT91_UDP_TXPKTRDY, creg);
+		udc->addr = w_value;
+		udc->wait_for_addr_ack = 1;
+		udc->req_pending = 0;
+		/* FADDR is set later, when we ack host STATUS */
+		return;
+
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_SET_CONFIGURATION:
+		tmp = at91_udp_read(AT91_UDP_GLB_STAT) & AT91_UDP_CONFG;
+		if (pkt.r.wValue)
+			udc->wait_for_config_ack = (tmp == 0);
+		else
+			udc->wait_for_config_ack = (tmp != 0);
+		if (udc->wait_for_config_ack)
+			VDBG("wait for config\n");
+		/* CONFG is toggled later, if gadget driver succeeds */
+		break;
+
+	/*
+	 * Hosts may set or clear remote wakeup status, and
+	 * devices may report they're VBUS powered.
+	 */
+	case ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_GET_STATUS:
+		tmp = (udc->selfpowered << USB_DEVICE_SELF_POWERED);
+		if (at91_udp_read(AT91_UDP_GLB_STAT) & AT91_UDP_ESR)
+			tmp |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+		PACKET("get device status\n");
+		__raw_writeb(tmp, dreg);
+		__raw_writeb(0, dreg);
+		goto write_in;
+		/* then STATUS starts later, automatically */
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_SET_FEATURE:
+		if (w_value != USB_DEVICE_REMOTE_WAKEUP)
+			goto stall;
+		tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+		tmp |= AT91_UDP_ESR;
+		at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+		goto succeed;
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_CLEAR_FEATURE:
+		if (w_value != USB_DEVICE_REMOTE_WAKEUP)
+			goto stall;
+		tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+		tmp &= ~AT91_UDP_ESR;
+		at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+		goto succeed;
+
+	/*
+	 * Interfaces have no feature settings; this is pretty useless.
+	 * we won't even insist the interface exists...
+	 */
+	case ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)
+			| USB_REQ_GET_STATUS:
+		PACKET("get interface status\n");
+		__raw_writeb(0, dreg);
+		__raw_writeb(0, dreg);
+		goto write_in;
+		/* then STATUS starts later, automatically */
+	case ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)
+			| USB_REQ_SET_FEATURE:
+	case ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)
+			| USB_REQ_CLEAR_FEATURE:
+		goto stall;
+
+	/*
+	 * Hosts may clear bulk/intr endpoint halt after the gadget
+	 * driver sets it (not widely used); or set it (for testing)
+	 */
+	case ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)
+			| USB_REQ_GET_STATUS:
+		tmp = w_index & USB_ENDPOINT_NUMBER_MASK;
+		ep = &udc->ep[tmp];
+		if (tmp > NUM_ENDPOINTS || (tmp && !ep->desc))
+			goto stall;
+
+		if (tmp) {
+			if ((w_index & USB_DIR_IN)) {
+				if (!ep->is_in)
+					goto stall;
+			} else if (ep->is_in)
+				goto stall;
+		}
+		PACKET("get %s status\n", ep->ep.name);
+		if (__raw_readl(ep->creg) & AT91_UDP_FORCESTALL)
+			tmp = (1 << USB_ENDPOINT_HALT);
+		else
+			tmp = 0;
+		__raw_writeb(tmp, dreg);
+		__raw_writeb(0, dreg);
+		goto write_in;
+		/* then STATUS starts later, automatically */
+	case ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)
+			| USB_REQ_SET_FEATURE:
+		tmp = w_index & USB_ENDPOINT_NUMBER_MASK;
+		ep = &udc->ep[tmp];
+		if (w_value != USB_ENDPOINT_HALT || tmp > NUM_ENDPOINTS)
+			goto stall;
+		if (!ep->desc || ep->is_iso)
+			goto stall;
+		if ((w_index & USB_DIR_IN)) {
+			if (!ep->is_in)
+				goto stall;
+		} else if (ep->is_in)
+			goto stall;
+
+		tmp = __raw_readl(ep->creg);
+		tmp &= ~SET_FX;
+		tmp |= CLR_FX | AT91_UDP_FORCESTALL;
+		__raw_writel(tmp, ep->creg);
+		goto succeed;
+	case ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)
+			| USB_REQ_CLEAR_FEATURE:
+		tmp = w_index & USB_ENDPOINT_NUMBER_MASK;
+		ep = &udc->ep[tmp];
+		if (w_value != USB_ENDPOINT_HALT || tmp > NUM_ENDPOINTS)
+			goto stall;
+		if (tmp == 0)
+			goto succeed;
+		if (!ep->desc || ep->is_iso)
+			goto stall;
+		if ((w_index & USB_DIR_IN)) {
+			if (!ep->is_in)
+				goto stall;
+		} else if (ep->is_in)
+			goto stall;
+
+		at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+		at91_udp_write(AT91_UDP_RST_EP, 0);
+		tmp = __raw_readl(ep->creg);
+		tmp |= CLR_FX;
+		tmp &= ~(SET_FX | AT91_UDP_FORCESTALL);
+		__raw_writel(tmp, ep->creg);
+		if (!list_empty(&ep->queue))
+			handle_ep(ep);
+		goto succeed;
+	}
+
+#undef w_value
+#undef w_index
+#undef w_length
+
+	/* pass request up to the gadget driver */
+	status = udc->driver->setup(&udc->gadget, &pkt.r);
+	if (status < 0) {
+stall:
+		VDBG("req %02x.%02x protocol STALL; stat %d\n",
+				pkt.r.bRequestType, pkt.r.bRequest, status);
+		csr |= AT91_UDP_FORCESTALL;
+		__raw_writel(csr, creg);
+		udc->req_pending = 0;
+	}
+	return;
+
+succeed:
+	/* immediate successful (IN) STATUS after zero length DATA */
+	PACKET("ep0 in/status\n");
+write_in:
+	csr |= AT91_UDP_TXPKTRDY;
+	__raw_writel(csr, creg);
+	udc->req_pending = 0;
+	return;
+}
+
+static void handle_ep0(struct at91_udc *udc)
+{
+	struct at91_ep		*ep0 = &udc->ep[0];
+	u32 __iomem		*creg = ep0->creg;
+	u32			csr = __raw_readl(creg);
+	struct at91_request	*req;
+
+	if (unlikely(csr & AT91_UDP_STALLSENT)) {
+		nuke(ep0, -EPROTO);
+		udc->req_pending = 0;
+		csr |= CLR_FX;
+		csr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_FORCESTALL);
+		__raw_writel(csr, creg);
+		VDBG("ep0 stalled\n");
+		csr = __raw_readl(creg);
+	}
+	if (csr & AT91_UDP_RXSETUP) {
+		nuke(ep0, 0);
+		udc->req_pending = 0;
+		handle_setup(udc, ep0, csr);
+		return;
+	}
+
+	if (list_empty(&ep0->queue))
+		req = NULL;
+	else
+		req = list_entry(ep0->queue.next, struct at91_request, queue);
+
+	/* host ACKed an IN packet that we sent */
+	if (csr & AT91_UDP_TXCOMP) {
+		csr |= CLR_FX;
+		csr &= ~(SET_FX | AT91_UDP_TXCOMP);
+
+		/* write more IN DATA? */
+		if (req && ep0->is_in) {
+			if (handle_ep(ep0))
+				udc->req_pending = 0;
+
+		/*
+		 * Ack after:
+		 *  - last IN DATA packet (including GET_STATUS)
+		 *  - IN/STATUS for OUT DATA
+		 *  - IN/STATUS for any zero-length DATA stage
+		 * except for the IN DATA case, the host should send
+		 * an OUT status later, which we'll ack.
+		 */
+		} else {
+			udc->req_pending = 0;
+			__raw_writel(csr, creg);
+
+			/*
+			 * SET_ADDRESS takes effect only after the STATUS
+			 * (to the original address) gets acked.
+			 */
+			if (udc->wait_for_addr_ack) {
+				u32	tmp;
+
+				at91_udp_write(AT91_UDP_FADDR, AT91_UDP_FEN | udc->addr);
+				tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+				tmp &= ~AT91_UDP_FADDEN;
+				if (udc->addr)
+					tmp |= AT91_UDP_FADDEN;
+				at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+
+				udc->wait_for_addr_ack = 0;
+				VDBG("address %d\n", udc->addr);
+			}
+		}
+	}
+
+	/* OUT packet arrived ... */
+	else if (csr & AT91_UDP_RX_DATA_BK0) {
+		csr |= CLR_FX;
+		csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);
+
+		/* OUT DATA stage */
+		if (!ep0->is_in) {
+			if (req) {
+				if (handle_ep(ep0)) {
+					/* send IN/STATUS */
+					PACKET("ep0 in/status\n");
+					csr = __raw_readl(creg);
+					csr &= ~SET_FX;
+					csr |= CLR_FX | AT91_UDP_TXPKTRDY;
+					__raw_writel(csr, creg);
+					udc->req_pending = 0;
+				}
+			} else if (udc->req_pending) {
+				/*
+				 * AT91 hardware has a hard time with this
+				 * "deferred response" mode for control-OUT
+				 * transfers.  (For control-IN it's fine.)
+				 *
+				 * The normal solution leaves OUT data in the
+				 * fifo until the gadget driver is ready.
+				 * We couldn't do that here without disabling
+				 * the IRQ that tells about SETUP packets,
+				 * e.g. when the host gets impatient...
+				 *
+				 * Working around it by copying into a buffer
+				 * would almost be a non-deferred response,
+				 * except that it wouldn't permit reliable
+				 * stalling of the request.  Instead, demand
+				 * that gadget drivers not use this mode.
+				 */
+				DBG("no control-OUT deferred responses!\n");
+				__raw_writel(csr | AT91_UDP_FORCESTALL, creg);
+				udc->req_pending = 0;
+			}
+
+		/* STATUS stage for control-IN; ack.  */
+		} else {
+			PACKET("ep0 out/status ACK\n");
+			__raw_writel(csr, creg);
+
+			/* "early" status stage */
+			if (req)
+				done(ep0, req, 0);
+		}
+	}
+}
+
+static irqreturn_t at91_udc_irq (int irq, void *_udc, struct pt_regs *r)
+{
+	struct at91_udc		*udc = _udc;
+	u32			rescans = 5;
+
+	while (rescans--) {
+		u32	status = at91_udp_read(AT91_UDP_ISR);
+
+		status &= at91_udp_read(AT91_UDP_IMR);
+		if (!status)
+			break;
+
+		/* USB reset irq:  not maskable */
+		if (status & AT91_UDP_ENDBUSRES) {
+			at91_udp_write(AT91_UDP_IDR, ~MINIMUS_INTERRUPTUS);
+			at91_udp_write(AT91_UDP_IER, MINIMUS_INTERRUPTUS);
+			/* Atmel code clears this irq twice */
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_ENDBUSRES);
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_ENDBUSRES);
+			VDBG("end bus reset\n");
+			udc->addr = 0;
+			stop_activity(udc);
+
+			/* enable ep0 */
+			at91_udp_write(AT91_UDP_CSR(0), AT91_UDP_EPEDS | AT91_UDP_EPTYPE_CTRL);
+			udc->gadget.speed = USB_SPEED_FULL;
+			udc->suspended = 0;
+			at91_udp_write(AT91_UDP_IER, AT91_UDP_EP(0));
+
+			/*
+			 * NOTE:  this driver keeps clocks off unless the
+			 * USB host is present.  That saves power, and also
+			 * eliminates IRQs (reset, resume, suspend) that can
+			 * otherwise flood from the controller.  If your
+			 * board doesn't support VBUS detection, suspend and
+			 * resume irq logic may need more attention...
+			 */
+
+		/* host initiated suspend (3+ms bus idle) */
+		} else if (status & AT91_UDP_RXSUSP) {
+			at91_udp_write(AT91_UDP_IDR, AT91_UDP_RXSUSP);
+			at91_udp_write(AT91_UDP_IER, AT91_UDP_RXRSM);
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_RXSUSP);
+			// VDBG("bus suspend\n");
+			if (udc->suspended)
+				continue;
+			udc->suspended = 1;
+
+			/*
+			 * NOTE:  when suspending a VBUS-powered device, the
+			 * gadget driver should switch into slow clock mode
+			 * and then into standby to avoid drawing more than
+			 * 500uA power (2500uA for some high-power configs).
+			 */
+			if (udc->driver && udc->driver->suspend)
+				udc->driver->suspend(&udc->gadget);
+
+		/* host initiated resume */
+		} else if (status & AT91_UDP_RXRSM) {
+			at91_udp_write(AT91_UDP_IDR, AT91_UDP_RXRSM);
+			at91_udp_write(AT91_UDP_IER, AT91_UDP_RXSUSP);
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_RXRSM);
+			// VDBG("bus resume\n");
+			if (!udc->suspended)
+				continue;
+			udc->suspended = 0;
+
+			/*
+			 * NOTE:  for a VBUS-powered device, the gadget driver
+			 * would normally want to switch out of slow clock
+			 * mode into normal mode.
+			 */
+			if (udc->driver && udc->driver->resume)
+				udc->driver->resume(&udc->gadget);
+
+		/* endpoint IRQs are cleared by handling them */
+		} else {
+			int		i;
+			unsigned	mask = 1;
+			struct at91_ep	*ep = &udc->ep[1];
+
+			if (status & mask)
+				handle_ep0(udc);
+			for (i = 1; i < NUM_ENDPOINTS; i++) {
+				mask <<= 1;
+				if (status & mask)
+					handle_ep(ep);
+				ep++;
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct at91_udc controller = {
+	.gadget = {
+		.ops = &at91_udc_ops,
+		.ep0 = &controller.ep[0].ep,
+		.name = driver_name,
+		.dev = {
+			.bus_id = "gadget"
+		}
+	},
+	.ep[0] = {
+		.ep = {
+			.name	= ep0name,
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 8,
+		.creg		= (void __iomem *)(AT91_VA_BASE_UDP + AT91_UDP_CSR(0)),
+		.int_mask	= 1 << 0,
+	},
+	.ep[1] = {
+		.ep = {
+			.name	= "ep1",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 64,
+		.creg		= (void __iomem *)(AT91_VA_BASE_UDP + AT91_UDP_CSR(1)),
+		.int_mask	= 1 << 1,
+	},
+	.ep[2] = {
+		.ep = {
+			.name	= "ep2",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 64,
+		.creg		= (void __iomem *)(AT91_VA_BASE_UDP + AT91_UDP_CSR(2)),
+		.int_mask	= 1 << 2,
+	},
+	.ep[3] = {
+		.ep = {
+			/* could actually do bulk too */
+			.name	= "ep3-int",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 8,
+		.creg		= (void __iomem *)(AT91_VA_BASE_UDP + AT91_UDP_CSR(3)),
+		.int_mask	= 1 << 3,
+	},
+	.ep[4] = {
+		.ep = {
+			.name	= "ep4",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 256,
+		.creg		= (void __iomem *)(AT91_VA_BASE_UDP + AT91_UDP_CSR(4)),
+		.int_mask	= 1 << 4,
+	},
+	.ep[5] = {
+		.ep = {
+			.name	= "ep5",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 256,
+		.creg		= (void __iomem *)(AT91_VA_BASE_UDP + AT91_UDP_CSR(5)),
+		.int_mask	= 1 << 5,
+	},
+	/* ep6 and ep7 are also reserved */
+};
+
+static irqreturn_t at91_vbus_irq(int irq, void *_udc, struct pt_regs *r)
+{
+	struct at91_udc	*udc = _udc;
+	unsigned	value;
+
+	/* vbus needs at least brief debouncing */
+	udelay(10);
+	value = at91_get_gpio_value(udc->board.vbus_pin);
+	if (value != udc->vbus)
+		at91_vbus_session(&udc->gadget, value);
+
+	return IRQ_HANDLED;
+}
+
+int usb_gadget_register_driver (struct usb_gadget_driver *driver)
+{
+	struct at91_udc	*udc = &controller;
+	int		retval;
+
+	if (!driver
+			|| driver->speed != USB_SPEED_FULL
+			|| !driver->bind
+			|| !driver->unbind
+			|| !driver->setup) {
+		DBG("bad parameter.\n");
+		return -EINVAL;
+	}
+
+	if (udc->driver) {
+		DBG("UDC already has a gadget driver\n");
+		return -EBUSY;
+	}
+
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+	udc->gadget.dev.driver_data = &driver->driver;
+	udc->enabled = 1;
+	udc->selfpowered = 1;
+
+	retval = driver->bind(&udc->gadget);
+	if (retval) {
+		DBG("driver->bind() returned %d\n", retval);
+		udc->driver = NULL;
+		return retval;
+	}
+
+	local_irq_disable();
+	pullup(udc, 1);
+	local_irq_enable();
+
+	DBG("bound to %s\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_register_driver);
+
+int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
+{
+	struct at91_udc *udc = &controller;
+
+	if (!driver || driver != udc->driver)
+		return -EINVAL;
+
+	local_irq_disable();
+	udc->enabled = 0;
+	pullup(udc, 0);
+	local_irq_enable();
+
+	driver->unbind(&udc->gadget);
+	udc->driver = NULL;
+
+	DBG("unbound from %s\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------*/
+
+static void at91udc_shutdown(struct platform_device *dev)
+{
+	/* force disconnect on reboot */
+	pullup(platform_get_drvdata(dev), 0);
+}
+
+static int __devinit at91udc_probe(struct platform_device *pdev)
+{
+	struct device	*dev = &pdev->dev;
+	struct at91_udc	*udc;
+	int		retval;
+
+	if (!dev->platform_data) {
+		/* small (so we copy it) but critical! */
+		DBG("missing platform_data\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(AT91_BASE_UDP, SZ_16K, driver_name)) {
+		DBG("someone's using UDC memory\n");
+		return -EBUSY;
+	}
+
+	/* init software state */
+	udc = &controller;
+	udc->gadget.dev.parent = dev;
+	udc->board = *(struct at91_udc_data *) dev->platform_data;
+	udc->pdev = pdev;
+	udc_reinit(udc);
+	udc->enabled = 0;
+
+	/* get interface and function clocks */
+	udc->iclk = clk_get(dev, "udc_clk");
+	udc->fclk = clk_get(dev, "udpck");
+	if (IS_ERR(udc->iclk) || IS_ERR(udc->fclk)) {
+		DBG("clocks missing\n");
+		return -ENODEV;
+	}
+
+	retval = device_register(&udc->gadget.dev);
+	if (retval < 0)
+		goto fail0;
+
+	/* disable everything until there's a gadget driver and vbus */
+	pullup(udc, 0);
+
+	/* request UDC and maybe VBUS irqs */
+	if (request_irq(AT91_ID_UDP, at91_udc_irq, SA_INTERRUPT, driver_name, udc)) {
+		DBG("request irq %d failed\n", AT91_ID_UDP);
+		retval = -EBUSY;
+		goto fail1;
+	}
+	if (udc->board.vbus_pin > 0) {
+		if (request_irq(udc->board.vbus_pin, at91_vbus_irq, SA_INTERRUPT, driver_name, udc)) {
+			DBG("request vbus irq %d failed\n", udc->board.vbus_pin);
+			free_irq(AT91_ID_UDP, udc);
+			retval = -EBUSY;
+			goto fail1;
+		}
+	} else {
+		DBG("no VBUS detection, assuming always-on\n");
+		udc->vbus = 1;
+	}
+	dev_set_drvdata(dev, udc);
+	create_debug_file(udc);
+
+	INFO("%s version %s\n", driver_name, DRIVER_VERSION);
+	return 0;
+
+fail1:
+	device_unregister(&udc->gadget.dev);
+fail0:
+	release_mem_region(AT91_VA_BASE_UDP, SZ_16K);
+	DBG("%s probe failed, %d\n", driver_name, retval);
+	return retval;
+}
+
+static int __devexit at91udc_remove(struct platform_device *dev)
+{
+	struct at91_udc *udc = platform_get_drvdata(dev);
+
+	DBG("remove\n");
+
+	pullup(udc, 0);
+
+	if (udc->driver != 0)
+		usb_gadget_unregister_driver(udc->driver);
+
+	remove_debug_file(udc);
+	if (udc->board.vbus_pin > 0)
+		free_irq(udc->board.vbus_pin, udc);
+	free_irq(AT91_ID_UDP, udc);
+	device_unregister(&udc->gadget.dev);
+	release_mem_region(AT91_BASE_UDP, SZ_16K);
+
+	clk_put(udc->iclk);
+	clk_put(udc->fclk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int at91udc_suspend(struct platform_device *dev, u32 state, u32 level)
+{
+	struct at91_udc *udc = platform_get_drvdata(dev);
+
+	/*
+	 * The "safe" suspend transitions are opportunistic ... e.g. when
+	 * the USB link is suspended (48MHz clock autogated off), or when
+	 * it's disconnected (programmatically gated off, elsewhere).
+	 * Then we can suspend, and the chip can enter slow clock mode.
+	 *
+	 * The problem case is some component (user mode?) suspending this
+	 * device while it's active, with the 48 MHz clock in use.  There
+	 * are two basic approaches:  (a) veto suspend levels involving slow
+	 * clock mode, (b) disconnect, so 48 MHz will no longer be in use
+	 * and we can enter slow clock mode.  This uses (b) for now, since
+	 * it's simplest until AT91 PM exists and supports the other option.
+	 */
+	if (udc->vbus && !udc->suspended)
+		pullup(udc, 0);
+	return 0;
+}
+
+static int at91udc_resume(struct platform_device *dev, u32 level)
+{
+	struct at91_udc *udc = platform_get_drvdata(dev);
+
+	/* maybe reconnect to host; if so, clocks on */
+	pullup(udc, 1);
+	return 0;
+}
+#else
+#define	at91udc_suspend	NULL
+#define	at91udc_resume	NULL
+#endif
+
+static struct platform_driver at91_udc = {
+	.probe		= at91udc_probe,
+	.remove		= __devexit_p(at91udc_remove),
+	.shutdown	= at91udc_shutdown,
+	.suspend	= at91udc_suspend,
+	.resume 	= at91udc_resume,
+	.driver		= {
+		.name	= (char *) driver_name,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __devinit udc_init_module(void)
+{
+	return platform_driver_register(&at91_udc);
+}
+module_init(udc_init_module);
+
+static void __devexit udc_exit_module(void)
+{
+	platform_driver_unregister(&at91_udc);
+}
+module_exit(udc_exit_module);
+
+MODULE_DESCRIPTION("AT91RM9200 udc driver");
+MODULE_AUTHOR("Thomas Rathbone, David Brownell");
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.15.orig/drivers/usb/gadget/at91_udc.h linux-2.6.15/drivers/usb/gadget/at91_udc.h
--- linux-2.6.15.orig/drivers/usb/gadget/at91_udc.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/usb/gadget/at91_udc.h	Wed Jan 11 10:42:46 2006
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2004 by Thomas Rathbone, HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef AT91_UDC_H
+#define AT91_UDC_H
+
+#define	NUM_ENDPOINTS	6
+
+/*
+ * hardware won't disable bus reset, or resume while the controller
+ * is suspended ... watching suspend helps keep the logic symmetric.
+ */
+#define	MINIMUS_INTERRUPTUS \
+	(AT91_UDP_ENDBUSRES | AT91_UDP_RXRSM | AT91_UDP_RXSUSP)
+
+struct at91_ep {
+	struct usb_ep			ep;
+	struct list_head		queue;
+	struct at91_udc			*udc;
+	void __iomem			*creg;
+
+	unsigned			maxpacket:16;
+	u8				int_mask;
+	unsigned			is_pingpong:1;
+
+	unsigned			stopped:1;
+	unsigned			is_in:1;
+	unsigned			is_iso:1;
+	unsigned			fifo_bank:1;
+
+	const struct usb_endpoint_descriptor
+					*desc;
+};
+
+/*
+ * driver is non-SMP, and just blocks IRQs whenever it needs
+ * access protection for chip registers or driver state
+ */
+struct at91_udc {
+	struct usb_gadget		gadget;
+	struct at91_ep			ep[NUM_ENDPOINTS];
+	struct usb_gadget_driver	*driver;
+	unsigned			vbus:1;
+	unsigned			enabled:1;
+	unsigned			clocked:1;
+	unsigned			suspended:1;
+	unsigned			req_pending:1;
+	unsigned			wait_for_addr_ack:1;
+	unsigned			wait_for_config_ack:1;
+	unsigned			selfpowered:1;
+	u8				addr;
+	struct at91_udc_data		board;
+	struct clk			*iclk, *fclk;
+	struct platform_device		*pdev;
+	struct proc_dir_entry		*pde;
+};
+
+static inline struct at91_udc *to_udc(struct usb_gadget *g)
+{
+	return container_of(g, struct at91_udc, gadget);
+}
+
+struct at91_request {
+	struct usb_request		req;
+	struct list_head		queue;
+};
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+#define DBG(stuff...)		printk(KERN_DEBUG "udc: " stuff)
+#else
+#define DBG(stuff...)		do{}while(0)
+#endif
+
+#ifdef VERBOSE
+#    define VDBG		DBG
+#else
+#    define VDBG(stuff...)	do{}while(0)
+#endif
+
+#ifdef PACKET_TRACE
+#    define PACKET		VDBG
+#else
+#    define PACKET(stuff...)	do{}while(0)
+#endif
+
+#define ERR(stuff...)		printk(KERN_ERR "udc: " stuff)
+#define WARN(stuff...)		printk(KERN_WARNING "udc: " stuff)
+#define INFO(stuff...)		printk(KERN_INFO "udc: " stuff)
+
+#endif
+
diff -urN linux-2.6.15.orig/drivers/usb/host/ohci-at91.c linux-2.6.15/drivers/usb/host/ohci-at91.c
--- linux-2.6.15.orig/drivers/usb/host/ohci-at91.c	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/drivers/usb/host/ohci-at91.c	Wed Jan 11 11:46:46 2006
@@ -0,0 +1,306 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ *  Copyright (C) 2004 SAN People (Pty) Ltd.
+ *  Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ *
+ * AT91RM9200 Bus Glue
+ *
+ * Based on fragments of 2,4 driver by Rick Bronson.
+ * Based on ohci-omap.c
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/hardware/clock.h>
+#include <asm/arch/board.h>
+
+#ifndef CONFIG_ARCH_AT91RM9200
+#error "This file is AT91RM9200 bus glue.  CONFIG_ARCH_AT91RM9200 must be defined."
+#endif
+
+/* interface and function clocks */
+static struct clk *iclk, *fclk;
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+static void at91_start_hc(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ohci_regs __iomem *regs = hcd->regs;
+
+	dev_dbg(&pdev->dev, "starting AT91RM9200 OHCI USB Controller\n");
+
+	/*
+	 * Start the USB clocks.
+	 */
+	clk_enable(iclk);
+	clk_enable(fclk);
+
+	/*
+	 * The USB host controller must remain in reset.
+	 */
+	writel(0, &regs->control);
+}
+
+static void at91_stop_hc(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ohci_regs __iomem *regs = hcd->regs;
+
+	dev_dbg(&pdev->dev, "stopping AT91RM9200 OHCI USB Controller\n");
+
+	/*
+	 * Put the USB host controller into reset.
+	 */
+	writel(0, &regs->control);
+
+	/*
+	 * Stop the USB clocks.
+	 */
+	clk_disable(fclk);
+	clk_disable(iclk);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int usb_hcd_at91_remove (struct usb_hcd *, struct platform_device *);
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_hcd_at91_probe - initialize AT91RM9200-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ * Store this function in the HCD's struct pci_driver as probe().
+ */
+int usb_hcd_at91_probe (const struct hc_driver *driver, struct platform_device *pdev)
+{
+	int retval;
+	struct usb_hcd *hcd = NULL;
+
+	if (pdev->num_resources != 2) {
+		pr_debug("hcd probe: invalid num_resources");
+		return -ENODEV;
+	}
+
+	if ((pdev->resource[0].flags != IORESOURCE_MEM) || (pdev->resource[1].flags != IORESOURCE_IRQ)) {
+		pr_debug("hcd probe: invalid resource type\n");
+		return -ENODEV;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, "at91rm9200");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed\n");
+		retval = -EIO;
+		goto err2;
+	}
+
+	iclk = clk_get(&pdev->dev, "ohci_clk");
+	fclk = clk_get(&pdev->dev, "uhpck");
+
+	at91_start_hc(pdev);
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, pdev->resource[1].start, SA_INTERRUPT);
+	if (retval == 0)
+		return retval;
+
+	/* Error handling */
+	at91_stop_hc(pdev);
+
+	clk_put(fclk);
+	clk_put(iclk);
+
+	iounmap(hcd->regs);
+
+ err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+ err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_at91_remove - shutdown processing for AT91RM9200-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_at91_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+static int usb_hcd_at91_remove (struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	at91_stop_hc(pdev);
+	iounmap(hcd->regs);
+ 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+ 	clk_put(fclk);
+ 	clk_put(iclk);
+ 	fclk = iclk = NULL;
+
+	dev_set_drvdata(&pdev->dev, NULL);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+ohci_at91_start (struct usb_hcd *hcd)
+{
+//	struct at91_ohci_data	*board = hcd->self.controller->platform_data;
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+//	hcd->self.root_hub->maxchild = board->ports;
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_at91_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"AT91RM9200 OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_at91_start,
+	.stop =			ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+
+#ifdef CONFIG_PM
+	.hub_suspend =		ohci_hub_suspend,
+	.hub_resume =		ohci_hub_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_at91_drv_probe(struct platform_device *dev)
+{
+	return usb_hcd_at91_probe(&ohci_at91_hc_driver, dev);
+}
+
+static int ohci_hcd_at91_drv_remove(struct platform_device *dev)
+{
+	return usb_hcd_at91_remove(platform_get_drvdata(dev), dev);
+}
+
+#ifdef CONFIG_PM
+static int ohci_hcd_at91_drv_suspend(struct platform_device *dev, u32 state, u32 level)
+{
+	printk("%s(%s:%d): not implemented yet\n",
+		__func__, __FILE__, __LINE__);
+
+	clk_disable(fclk);
+
+	return 0;
+}
+
+static int ohci_hcd_at91_drv_resume(struct platform_device *dev, u32 state)
+{
+	printk("%s(%s:%d): not implemented yet\n",
+		__func__, __FILE__, __LINE__);
+
+	clk_enable(fclk);
+
+	return 0;
+}
+#else
+#define ohci_hcd_at91_drv_suspend NULL
+#define ohci_hcd_at91_drv_resume  NULL
+#endif
+
+static struct platform_driver ohci_hcd_at91_driver = {
+	.probe		= ohci_hcd_at91_drv_probe,
+	.remove		= ohci_hcd_at91_drv_remove,
+	.suspend	= ohci_hcd_at91_drv_suspend,
+	.resume		= ohci_hcd_at91_drv_resume,
+	.driver		= {
+		.name	= "at91rm9200-ohci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ohci_hcd_at91_init (void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return platform_driver_register(&ohci_hcd_at91_driver);
+}
+
+static void __exit ohci_hcd_at91_cleanup (void)
+{
+	platform_driver_unregister(&ohci_hcd_at91_driver);
+}
+
+module_init (ohci_hcd_at91_init);
+module_exit (ohci_hcd_at91_cleanup);
diff -urN linux-2.6.15.orig/drivers/usb/host/ohci-hcd.c linux-2.6.15/drivers/usb/host/ohci-hcd.c
--- linux-2.6.15.orig/drivers/usb/host/ohci-hcd.c	Wed Jan 11 09:19:20 2006
+++ linux-2.6.15/drivers/usb/host/ohci-hcd.c	Wed Jan 11 10:42:46 2006
@@ -917,6 +917,10 @@
 #include "ohci-ppc-soc.c"
 #endif
 
+#ifdef CONFIG_ARCH_AT91RM9200
+#include "ohci-at91.c"
+#endif
+
 #if !(defined(CONFIG_PCI) \
       || defined(CONFIG_SA1111) \
       || defined(CONFIG_ARCH_S3C2410) \
@@ -925,6 +929,7 @@
       || defined (CONFIG_PXA27x) \
       || defined (CONFIG_SOC_AU1X00) \
       || defined (CONFIG_USB_OHCI_HCD_PPC_SOC) \
+      || defined (CONFIG_ARCH_AT91RM9200) \
 	)
 #error "missing bus glue for ohci-hcd"
 #endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91_spi.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91_spi.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91_spi.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91_spi.h	Wed Jan 11 10:21:37 2006
@@ -0,0 +1,56 @@
+/*
+ * Serial Peripheral Interface (SPI) driver for the Atmel AT91RM9200
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef AT91_SPI_H
+#define AT91_SPI_H
+
+/* Maximum number of buffers in a single SPI transfer.
+ *  DataFlash uses maximum of 2
+ *  spidev interface supports up to 8.
+ */
+#define MAX_SPI_TRANSFERS	8
+
+#define NR_SPI_DEVICES  	4	/* number of devices on SPI bus */
+
+#define DATAFLASH_CLK		6000000
+#define DEFAULT_SPI_BAUD	(at91_master_clock / (2 * DATAFLASH_CLK))
+
+#define SPI_MAJOR		153	/* registered device number */
+
+/*
+ * Describes the buffers for a SPI transfer.
+ * A transmit & receive buffer must be specified for each transfer
+ */
+struct spi_transfer_list {
+	void* tx[MAX_SPI_TRANSFERS];	/* transmit */
+	int txlen[MAX_SPI_TRANSFERS];
+	void* rx[MAX_SPI_TRANSFERS];	/* receive */
+	int rxlen[MAX_SPI_TRANSFERS];
+	int nr_transfers;		/* number of transfers */
+	int curr;			/* current transfer */
+};
+
+struct spi_local {
+	unsigned int pcs;		/* Peripheral Chip Select value */
+	short pio_enabled;		/* has PIO been enabled? */
+
+	struct spi_transfer_list *xfers;	/* current transfer list */
+	dma_addr_t tx, rx;		/* DMA address for current transfer */
+	dma_addr_t txnext, rxnext;	/* DMA address for next transfer */
+};
+
+
+/* Exported functions */
+extern void spi_access_bus(short device);
+extern void spi_release_bus(short device);
+extern int spi_transfer(struct spi_transfer_list* list);
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200.h	Wed Jan 11 09:38:33 2006
@@ -0,0 +1,261 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Common definitions.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_H
+#define AT91RM9200_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ	0	/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS	1	/* System Peripheral */
+#define AT91_ID_PIOA	2	/* Parallel IO Controller A */
+#define AT91_ID_PIOB	3	/* Parallel IO Controller B */
+#define AT91_ID_PIOC	4	/* Parallel IO Controller C */
+#define AT91_ID_PIOD	5	/* Parallel IO Controller D */
+#define AT91_ID_US0	6	/* USART 0 */
+#define AT91_ID_US1	7	/* USART 1 */
+#define AT91_ID_US2	8	/* USART 2 */
+#define AT91_ID_US3	9	/* USART 3 */
+#define AT91_ID_MCI	10	/* Multimedia Card Interface */
+#define AT91_ID_UDP	11	/* USB Device Port */
+#define AT91_ID_TWI	12	/* Two-Wire Interface */
+#define AT91_ID_SPI	13	/* Serial Peripheral Interface */
+#define AT91_ID_SSC0	14	/* Serial Synchronous Controller 0 */
+#define AT91_ID_SSC1	15	/* Serial Synchronous Controller 1 */
+#define AT91_ID_SSC2	16	/* Serial Synchronous Controller 2 */
+#define AT91_ID_TC0	17	/* Timer Counter 0 */
+#define AT91_ID_TC1	18	/* Timer Counter 1 */
+#define AT91_ID_TC2	19	/* Timer Counter 2 */
+#define AT91_ID_TC3	20	/* Timer Counter 3 */
+#define AT91_ID_TC4	21	/* Timer Counter 4 */
+#define AT91_ID_TC5	22	/* Timer Counter 5 */
+#define AT91_ID_UHP	23	/* USB Host port */
+#define AT91_ID_EMAC	24	/* Ethernet MAC */
+#define AT91_ID_IRQ0	25	/* Advanced Interrupt Controller (IRQ0) */
+#define AT91_ID_IRQ1	26	/* Advanced Interrupt Controller (IRQ1) */
+#define AT91_ID_IRQ2	27	/* Advanced Interrupt Controller (IRQ2) */
+#define AT91_ID_IRQ3	28	/* Advanced Interrupt Controller (IRQ3) */
+#define AT91_ID_IRQ4	29	/* Advanced Interrupt Controller (IRQ4) */
+#define AT91_ID_IRQ5	30	/* Advanced Interrupt Controller (IRQ5) */
+#define AT91_ID_IRQ6	31	/* Advanced Interrupt Controller (IRQ6) */
+
+
+/*
+ * Peripheral physical base addresses.
+ */
+#define AT91_BASE_TCB0		0xfffa0000
+#define AT91_BASE_TC0		0xfffa0000
+#define AT91_BASE_TC1		0xfffa0040
+#define AT91_BASE_TC2		0xfffa0080
+#define AT91_BASE_TCB1		0xfffa4000
+#define AT91_BASE_TC3		0xfffa4000
+#define AT91_BASE_TC4		0xfffa4040
+#define AT91_BASE_TC5		0xfffa4080
+#define AT91_BASE_UDP		0xfffb0000
+#define AT91_BASE_MCI		0xfffb4000
+#define AT91_BASE_TWI		0xfffb8000
+#define AT91_BASE_EMAC		0xfffbc000
+#define AT91_BASE_US0		0xfffc0000
+#define AT91_BASE_US1		0xfffc4000
+#define AT91_BASE_US2		0xfffc8000
+#define AT91_BASE_US3		0xfffcc000
+#define AT91_BASE_SSC0		0xfffd0000
+#define AT91_BASE_SSC1		0xfffd4000
+#define AT91_BASE_SSC2		0xfffd8000
+#define AT91_BASE_SPI		0xfffe0000
+#define AT91_BASE_SYS		0xfffff000
+
+
+/*
+ * PIO pin definitions (peripheral A/B multiplexing).
+ */
+#define AT91_PA0_MISO		(1 <<  0)	/* A: SPI Master-In Slave-Out */
+#define AT91_PA0_PCK3		(1 <<  0)	/* B: PMC Programmable Clock Output 3 */
+#define AT91_PA1_MOSI		(1 <<  1)	/* A: SPI Master-Out Slave-In */
+#define AT91_PA1_PCK0		(1 <<  1)	/* B: PMC Programmable Clock Output 0 */
+#define AT91_PA2_SPCK		(1 <<  2)	/* A: SPI Serial Clock */
+#define AT91_PA2_IRQ4		(1 <<  2)	/* B: External Interrupt 4 */
+#define AT91_PA3_NPCS0		(1 <<  3)	/* A: SPI Peripheral Chip Select 0 */
+#define AT91_PA3_IRQ5		(1 <<  3)	/* B: External Interrupt 5 */
+#define AT91_PA4_NPCS1		(1 <<  4)	/* A: SPI Peripheral Chip Select 1 */
+#define AT91_PA4_PCK1		(1 <<  4)	/* B: PMC Programmable Clock Output 1 */
+#define AT91_PA5_NPCS2		(1 <<  5)	/* A: SPI Peripheral Chip Select 2 */
+#define AT91_PA5_TXD3		(1 <<  5)	/* B: USART Transmit Data 3 */
+#define AT91_PA6_NPCS3		(1 <<  6)	/* A: SPI Peripheral Chip Select 3 */
+#define AT91_PA6_RXD3		(1 <<  6)	/* B: USART Receive Data 3 */
+#define AT91_PA7_ETXCK_EREFCK	(1 <<  7)	/* A: Ethernet Reference Clock / Transmit Clock */
+#define AT91_PA7_PCK2		(1 <<  7)	/* B: PMC Programmable Clock Output 2 */
+#define AT91_PA8_ETXEN		(1 <<  8)	/* A: Ethernet Transmit Enable */
+#define AT91_PA8_MCCDB		(1 <<  8)	/* B: MMC Multimedia Card B Command */
+#define AT91_PA9_ETX0		(1 <<  9)	/* A: Ethernet Transmit Data 0 */
+#define AT91_PA9_MCDB0		(1 <<  9)	/* B: MMC Multimedia Card B Data 0 */
+#define AT91_PA10_ETX1		(1 << 10)	/* A: Ethernet Transmit Data 1 */
+#define AT91_PA10_MCDB1		(1 << 10)	/* B: MMC Multimedia Card B Data 1 */
+#define AT91_PA11_ECRS_ECRSDV	(1 << 11)	/* A: Ethernet Carrier Sense / Data Valid */
+#define AT91_PA11_MCDB2		(1 << 11)	/* B: MMC Multimedia Card B Data 2 */
+#define AT91_PA12_ERX0		(1 << 12)	/* A: Ethernet Receive Data 0 */
+#define AT91_PA12_MCDB3		(1 << 12)	/* B: MMC Multimedia Card B Data 3 */
+#define AT91_PA13_ERX1		(1 << 13)	/* A: Ethernet Receive Data 1 */
+#define AT91_PA13_TCLK0		(1 << 13)	/* B: TC External Clock Input 0 */
+#define AT91_PA14_ERXER		(1 << 14)	/* A: Ethernet Receive Error */
+#define AT91_PA14_TCLK1		(1 << 14)	/* B: TC External Clock Input 1 */
+#define AT91_PA15_EMDC		(1 << 15)	/* A: Ethernet Management Data Clock */
+#define AT91_PA15_TCLK2		(1 << 15)	/* B: TC External Clock Input 2 */
+#define AT91_PA16_EMDIO		(1 << 16)	/* A: Ethernet Management Data I/O */
+#define AT91_PA16_IRQ6		(1 << 16)	/* B: External Interrupt 6 */
+#define AT91_PA17_TXD0		(1 << 17)	/* A: USART Transmit Data 0 */
+#define AT91_PA17_TIOA0		(1 << 17)	/* B: TC I/O Line A 0 */
+#define AT91_PA18_RXD0		(1 << 18)	/* A: USART Receive Data 0 */
+#define AT91_PA18_TIOB0		(1 << 18)	/* B: TC I/O Line B 0 */
+#define AT91_PA19_SCK0		(1 << 19)	/* A: USART Serial Clock 0 */
+#define AT91_PA19_TIOA1		(1 << 19)	/* B: TC I/O Line A 1 */
+#define AT91_PA20_CTS0		(1 << 20)	/* A: USART Clear To Send 0 */
+#define AT91_PA20_TIOB1		(1 << 20)	/* B: TC I/O Line B 1 */
+#define AT91_PA21_RTS0		(1 << 21)	/* A: USART Ready To Send 0 */
+#define AT91_PA21_TIOA2		(1 << 21)	/* B: TC I/O Line A 2 */
+#define AT91_PA22_RXD2		(1 << 22)	/* A: USART Receive Data 2 */
+#define AT91_PA22_TIOB2		(1 << 22)	/* B: TC I/O Line B 2 */
+#define AT91_PA23_TXD2		(1 << 23)	/* A: USART Transmit Data 2 */
+#define AT91_PA23_IRQ3		(1 << 23)	/* B: External Interrupt 3 */
+#define AT91_PA24_SCK2		(1 << 24)	/* A: USART Serial Clock 2 */
+#define AT91_PA24_PCK1		(1 << 24)	/* B: PMC Programmable Clock Output 1 */
+#define AT91_PA25_TWD		(1 << 25)	/* A: TWI Two-wire Serial Data */
+#define AT91_PA25_IRQ2		(1 << 25)	/* B: External Interrupt 2 */
+#define AT91_PA26_TWCK		(1 << 26)	/* A: TWI Two-wire Serial Clock */
+#define AT91_PA26_IRQ1		(1 << 26)	/* B: External Interrupt 1 */
+#define AT91_PA27_MCCK		(1 << 27)	/* A: MMC Multimedia Card Clock */
+#define AT91_PA27_TCLK3		(1 << 27)	/* B: TC External Clock Input 3 */
+#define AT91_PA28_MCCDA		(1 << 28)	/* A: MMC Multimedia Card A Command */
+#define AT91_PA28_TCLK4		(1 << 28)	/* B: TC External Clock Input 4 */
+#define AT91_PA29_MCDA0		(1 << 29)	/* A: MMC Multimedia Card A Data 0 */
+#define AT91_PA29_TCLK5		(1 << 29)	/* B: TC External Clock Input 5 */
+#define AT91_PA30_DRXD		(1 << 30)	/* A: DBGU Receive Data */
+#define AT91_PA30_CTS2		(1 << 30)	/* B: USART Clear To Send 2 */
+#define AT91_PA31_DTXD		(1 << 31)	/* A: DBGU Transmit Data */
+#define AT91_PA31_RTS2		(1 << 31)	/* B: USART Ready To Send 2 */
+
+#define AT91_PB0_TF0		(1 <<  0)	/* A: SSC Transmit Frame Sync 0 */
+#define AT91_PB0_RTS3		(1 <<  0)	/* B: USART Ready To Send 3 */
+#define AT91_PB1_TK0		(1 <<  1)	/* A: SSC Transmit Clock 0 */
+#define AT91_PB1_CTS3		(1 <<  1)	/* B: USART Clear To Send 3 */
+#define AT91_PB2_TD0		(1 <<  2)	/* A: SSC Transmit Data 0 */
+#define AT91_PB2_SCK3		(1 <<  2)	/* B: USART Serial Clock 3 */
+#define AT91_PB3_RD0		(1 <<  3)	/* A: SSC Receive Data 0 */
+#define AT91_PB3_MCDA1		(1 <<  3)	/* B: MMC Multimedia Card A Data 1 */
+#define AT91_PB4_RK0		(1 <<  4)	/* A: SSC Receive Clock 0 */
+#define AT91_PB4_MCDA2		(1 <<  4)	/* B: MMC Multimedia Card A Data 2 */
+#define AT91_PB5_RF0		(1 <<  5)	/* A: SSC Receive Frame Sync 0 */
+#define AT91_PB5_MCDA3		(1 <<  5)	/* B: MMC Multimedia Card A Data 3 */
+#define AT91_PB6_TF1		(1 <<  6)	/* A: SSC Transmit Frame Sync 1 */
+#define AT91_PB6_TIOA3		(1 <<  6)	/* B: TC I/O Line A 3 */
+#define AT91_PB7_TK1		(1 <<  7)	/* A: SSC Transmit Clock 1 */
+#define AT91_PB7_TIOB3		(1 <<  7)	/* B: TC I/O Line B 3 */
+#define AT91_PB8_TD1		(1 <<  8)	/* A: SSC Transmit Data 1 */
+#define AT91_PB8_TIOA4		(1 <<  8)	/* B: TC I/O Line A 4 */
+#define AT91_PB9_RD1		(1 <<  9)	/* A: SSC Receive Data 1 */
+#define AT91_PB9_TIOB4		(1 <<  9)	/* B: TC I/O Line B 4 */
+#define AT91_PB10_RK1		(1 << 10)	/* A: SSC Receive Clock 1 */
+#define AT91_PB10_TIOA5		(1 << 10)	/* B: TC I/O Line A 5 */
+#define AT91_PB11_RF1		(1 << 11)	/* A: SSC Receive Frame Sync 1 */
+#define AT91_PB11_TIOB5		(1 << 11)	/* B: TC I/O Line B 5 */
+#define AT91_PB12_TF2		(1 << 12)	/* A: SSC Transmit Frame Sync 2 */
+#define AT91_PB12_ETX2		(1 << 12)	/* B: Ethernet Transmit Data 2 */
+#define AT91_PB13_TK2		(1 << 13)	/* A: SSC Transmit Clock 3 */
+#define AT91_PB13_ETX3		(1 << 13)	/* B: Ethernet Transmit Data 3 */
+#define AT91_PB14_TD2		(1 << 14)	/* A: SSC Transmit Data 2 */
+#define AT91_PB14_ETXER		(1 << 14)	/* B: Ethernet Transmit Coding Error */
+#define AT91_PB15_RD2		(1 << 15)	/* A: SSC Receive Data 2 */
+#define AT91_PB15_ERX2		(1 << 15)	/* B: Ethernet Receive Data 2 */
+#define AT91_PB16_RK2		(1 << 16)	/* A: SSC Receive Clock 2 */
+#define AT91_PB16_ERX3		(1 << 16)	/* B: Ethernet Receive Data 3 */
+#define AT91_PB17_RF2		(1 << 17)	/* A: SSC Receive Frame Sync 2 */
+#define AT91_PB17_ERXDV		(1 << 17)	/* B: Ethernet Receive Data Valid */
+#define AT91_PB18_RI1		(1 << 18)	/* A: USART Ring Indicator 1 */
+#define AT91_PB18_ECOL		(1 << 18)	/* B: Ethernet Collision Detected */
+#define AT91_PB19_DTR1		(1 << 19)	/* A: USART Data Terminal Ready 1 */
+#define AT91_PB19_ERXCK		(1 << 19)	/* B: Ethernet Receive Clock */
+#define AT91_PB20_TXD1		(1 << 20)	/* A: USART Transmit Data 1 */
+#define AT91_PB21_RXD1		(1 << 21)	/* A: USART Receive Data 1 */
+#define AT91_PB22_SCK1		(1 << 22)	/* A: USART Serial Clock 1 */
+#define AT91_PB23_DCD1		(1 << 23)	/* A: USART Data Carrier Detect 1 */
+#define AT91_PB24_CTS1		(1 << 24)	/* A: USART Clear To Send 1 */
+#define AT91_PB25_DSR1		(1 << 25)	/* A: USART Data Set Ready 1 */
+#define AT91_PB25_EF100		(1 << 25)	/* B: Ethernet Force 100 Mbit */
+#define AT91_PB26_RTS1		(1 << 26)	/* A: USART Ready To Send 1 */
+#define AT91_PB27_PCK0		(1 << 27)	/* B: PMC Programmable Clock Output 0 */
+#define AT91_PB28_FIQ		(1 << 28)	/* A: Fast Interrupt */
+#define AT91_PB29_IRQ0		(1 << 29)	/* A: External Interrupt 0 */
+
+#define AT91_PC0_BFCK		(1 <<  0)	/* A: Burst Flash Clock */
+#define AT91_PC1_BFRDY_SMOE	(1 <<  1)	/* A: Burst Flash Ready / SmartMedia Output Enable */
+#define AT91_PC2_BFAVD		(1 <<  2)	/* A: Burst Flash Address Valid */
+#define AT91_PC3_BFBAA_SMWE	(1 <<  3)	/* A: Burst Flash Address Advance / SmartMedia Write Enable */
+#define AT91_PC4_BFOE		(1 <<  4)	/* A: Burst Flash Output Enable */
+#define AT91_PC5_BFWE		(1 <<  5)	/* A: Burst Flash Write Enable */
+#define AT91_PC6_NWAIT		(1 <<  6)	/* A: SMC Wait Signal */
+#define AT91_PC7_A23		(1 <<  7)	/* A: Address Bus 23 */
+#define AT91_PC8_A24		(1 <<  8)	/* A: Address Bus 24 */
+#define AT91_PC9_A25_CFRNW	(1 <<  9)	/* A: Address Bus 25 / Compact Flash Read Not Write */
+#define AT91_PC10_NCS4_CFCS	(1 << 10)	/* A: SMC Chip Select 4 / Compact Flash Chip Select */
+#define AT91_PC11_NCS5_CFCE1	(1 << 11)	/* A: SMC Chip Select 5 / Compact Flash Chip Enable 1 */
+#define AT91_PC12_NCS6_CFCE2	(1 << 12)	/* A: SMC Chip Select 6 / Compact Flash Chip Enable 2 */
+#define AT91_PC13_NCS7		(1 << 13)	/* A: Chip Select 7 */
+
+#define AT91_PD0_ETX0		(1 <<  0)	/* A: Ethernet Transmit Data 0 */
+#define AT91_PD1_ETX1		(1 <<  1)	/* A: Ethernet Transmit Data 1 */
+#define AT91_PD2_ETX2		(1 <<  2)	/* A: Ethernet Transmit Data 2 */
+#define AT91_PD3_ETX3		(1 <<  3)	/* A: Ethernet Transmit Data 3 */
+#define AT91_PD4_ETXEN		(1 <<  4)	/* A: Ethernet Transmit Enable */
+#define AT91_PD5_ETXER		(1 <<  5)	/* A: Ethernet Transmit Coding Error */
+#define AT91_PD6_DTXD		(1 <<  6)	/* A: DBGU Transmit Data */
+#define AT91_PD7_PCK0		(1 <<  7)	/* A: PMC Programmable Clock Output 0 */
+#define AT91_PD7_TSYNC		(1 <<  7)	/* B: ETM Trace Synchronization Signal */
+#define AT91_PD8_PCK1		(1 <<  8)	/* A: PMC Programmable Clock Output 1 */
+#define AT91_PD8_TCLK		(1 <<  8)	/* B: ETM Trace Clock */
+#define AT91_PD9_PCK2		(1 <<  9)	/* A: PMC Programmable Clock Output 2 */
+#define AT91_PD9_TPS0		(1 <<  9)	/* B: ETM Trace ARM Pipeline Status 0 */
+#define AT91_PD10_PCK3		(1 << 10)	/* A: PMC Programmable Clock Output 3 */
+#define AT91_PD10_TPS1		(1 << 10)	/* B: ETM Trace ARM Pipeline Status 1 */
+#define AT91_PD11_TPS2		(1 << 11)	/* B: ETM Trace ARM Pipeline Status 2 */
+#define AT91_PD12_TPK0		(1 << 12)	/* B: ETM Trace Packet Port 0 */
+#define AT91_PD13_TPK1		(1 << 13)	/* B: ETM Trace Packet Port 1 */
+#define AT91_PD14_TPK2		(1 << 14)	/* B: ETM Trace Packet Port 2 */
+#define AT91_PD15_TD0		(1 << 15)	/* A: SSC Transmit Data 0 */
+#define AT91_PD15_TPK3		(1 << 15)	/* B: ETM Trace Packet Port 3 */
+#define AT91_PD16_TD1		(1 << 16)	/* A: SSC Transmit Data 1 */
+#define AT91_PD16_TPK4		(1 << 16)	/* B: ETM Trace Packet Port 4 */
+#define AT91_PD17_TD2		(1 << 17)	/* A: SSC Transmit Data 2 */
+#define AT91_PD17_TPK5		(1 << 17)	/* B: ETM Trace Packet Port 5 */
+#define AT91_PD18_NPCS1		(1 << 18)	/* A: SPI Peripheral Chip Select 1 */
+#define AT91_PD18_TPK6		(1 << 18)	/* B: ETM Trace Packet Port 6 */
+#define AT91_PD19_NPCS2		(1 << 19)	/* A: SPI Peripheral Chip Select 2 */
+#define AT91_PD19_TPK7		(1 << 19)	/* B: ETM Trace Packet Port 7 */
+#define AT91_PD20_NPCS3		(1 << 20)	/* A: SPI Peripheral Chip Select 3 */
+#define AT91_PD20_TPK8		(1 << 20)	/* B: ETM Trace Packet Port 8 */
+#define AT91_PD21_RTS0		(1 << 21)  	/* A: USART Ready To Send 0 */
+#define AT91_PD21_TPK9		(1 << 21)	/* B: ETM Trace Packet Port 9 */
+#define AT91_PD22_RTS1		(1 << 22)	/* A: USART Ready To Send 1 */
+#define AT91_PD22_TPK10		(1 << 22)	/* B: ETM Trace Packet Port 10 */
+#define AT91_PD23_RTS2		(1 << 23)	/* A: USART Ready To Send 2 */
+#define AT91_PD23_TPK11		(1 << 23)	/* B: ETM Trace Packet Port 11 */
+#define AT91_PD24_RTS3		(1 << 24)	/* A: USART Ready To Send 3 */
+#define AT91_PD24_TPK12		(1 << 24)	/* B: ETM Trace Packet Port 12 */
+#define AT91_PD25_DTR1		(1 << 25)	/* A: USART Data Terminal Ready 1 */
+#define AT91_PD25_TPK13		(1 << 25)	/* B: ETM Trace Packet Port 13 */
+#define AT91_PD26_TPK14		(1 << 26)	/* B: ETM Trace Packet Port 14 */
+#define AT91_PD27_TPK15		(1 << 27)	/* B: ETM Trace Packet Port 15 */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_emac.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_emac.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_emac.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_emac.h	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,138 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_emac.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Ethernet MAC registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_EMAC_H
+#define AT91RM9200_EMAC_H
+
+#define	AT91_EMAC_CTL		0x00	/* Control Register */
+#define		AT91_EMAC_LB		(1 <<  0)	/* Loopback */
+#define		AT91_EMAC_LBL		(1 <<  1)	/* Loopback Local */
+#define		AT91_EMAC_RE		(1 <<  2)	/* Receive Enable */
+#define		AT91_EMAC_TE		(1 <<  3)	/* Transmit Enable */
+#define		AT91_EMAC_MPE		(1 <<  4)	/* Management Port Enable */
+#define		AT91_EMAC_CSR		(1 <<  5)	/* Clear Statistics Registers */
+#define		AT91_EMAC_INCSTAT	(1 <<  6)	/* Increment Statistics Registers */
+#define		AT91_EMAC_WES		(1 <<  7)	/* Write Enable for Statistics Registers */
+#define		AT91_EMAC_BP		(1 <<  8)	/* Back Pressure */
+
+#define	AT91_EMAC_CFG		0x04	/* Configuration Register */
+#define		AT91_EMAC_SPD		(1 <<  0)	/* Speed */
+#define		AT91_EMAC_FD		(1 <<  1)	/* Full Duplex */
+#define		AT91_EMAC_BR		(1 <<  2)	/* Bit Rate */
+#define		AT91_EMAC_CAF		(1 <<  4)	/* Copy All Frames */
+#define		AT91_EMAC_NBC		(1 <<  5)	/* No Broadcast */
+#define		AT91_EMAC_MTI		(1 <<  6)	/* Multicast Hash Enable */
+#define		AT91_EMAC_UNI		(1 <<  7)	/* Unicast Hash Enable */
+#define		AT91_EMAC_BIG		(1 <<  8)	/* Receive 1522 Bytes */
+#define		AT91_EMAC_EAE		(1 <<  9)	/* External Address Match Enable */
+#define		AT91_EMAC_CLK		(3 << 10)	/* MDC Clock Divisor */	
+#define		AT91_EMAC_CLK_DIV8		(0 << 10)
+#define		AT91_EMAC_CLK_DIV16		(1 << 10)
+#define		AT91_EMAC_CLK_DIV32		(2 << 10)
+#define		AT91_EMAC_CLK_DIV64		(3 << 10)
+#define		AT91_EMAC_RTY		(1 << 12)	/* Retry Test */
+#define		AT91_EMAC_RMII		(1 << 13)	/* Reduce MII (RMII) */
+
+#define	AT91_EMAC_SR		0x08	/* Status Register */
+#define		AT91_EMAC_SR_LINK	(1 <<  0)	/* Link */
+#define		AT91_EMAC_SR_MDIO	(1 <<  1)	/* MDIO pin */
+#define		AT91_EMAC_SR_IDLE	(1 <<  2)	/* PHY idle */
+
+#define	AT91_EMAC_TAR		0x0c	/* Transmit Address Register */
+
+#define	AT91_EMAC_TCR		0x10	/* Transmit Control Register */
+#define		AT91_EMAC_LEN		(0x7ff << 0)	/* Transmit Frame Length */
+#define		AT91_EMAC_NCRC		(1     << 15)	/* No CRC */
+
+#define	AT91_EMAC_TSR		0x14	/* Transmit Status Register */
+#define		AT91_EMAC_TSR_OVR	(1 <<  0)	/* Transmit Buffer Overrun */
+#define		AT91_EMAC_TSR_COL	(1 <<  1)	/* Collision Occurred */
+#define		AT91_EMAC_TSR_RLE	(1 <<  2)	/* Retry Limit Exceeded */
+#define		AT91_EMAC_TSR_IDLE	(1 <<  3)	/* Transmitter Idle */
+#define		AT91_EMAC_TSR_BNQ	(1 <<  4)	/* Transmit Buffer not Queued */
+#define		AT91_EMAC_TSR_COMP	(1 <<  5)	/* Transmit Complete */
+#define		AT91_EMAC_TSR_UND	(1 <<  6)	/* Transmit Underrun */
+
+#define	AT91_EMAC_RBQP		0x18	/* Receive Buffer Queue Pointer */
+
+#define	AT91_EMAC_RSR		0x20	/* Receive Status Register */
+#define		AT91_EMAC_RSR_BNA	(1 <<  0)	/* Buffer Not Available */
+#define		AT91_EMAC_RSR_REC	(1 <<  1)	/* Frame Received */
+#define		AT91_EMAC_RSR_OVR	(1 <<  2)	/* RX Overrun */
+
+#define	AT91_EMAC_ISR		0x24	/* Interrupt Status Register */
+#define		AT91_EMAC_DONE		(1 <<  0)	/* Management Done */
+#define		AT91_EMAC_RCOM		(1 <<  1)	/* Receive Complete */
+#define		AT91_EMAC_RBNA		(1 <<  2)	/* Receive Buffer Not Available */
+#define		AT91_EMAC_TOVR		(1 <<  3)	/* Transmit Buffer Overrun */
+#define		AT91_EMAC_TUND		(1 <<  4)	/* Transmit Buffer Underrun */
+#define		AT91_EMAC_RTRY		(1 <<  5)	/* Retry Limit */
+#define		AT91_EMAC_TBRE		(1 <<  6)	/* Transmit Buffer Register Empty */
+#define		AT91_EMAC_TCOM		(1 <<  7)	/* Transmit Complete */
+#define		AT91_EMAC_TIDLE		(1 <<  8)	/* Transmit Idle */
+#define		AT91_EMAC_LINK		(1 <<  9)	/* Link */
+#define		AT91_EMAC_ROVR		(1 << 10)	/* RX Overrun */
+#define		AT91_EMAC_ABT		(1 << 11)	/* Abort */
+
+#define	AT91_EMAC_IER		0x28	/* Interrupt Enable Register */
+#define	AT91_EMAC_IDR		0x2c	/* Interrupt Disable Register */
+#define	AT91_EMAC_IMR		0x30	/* Interrupt Mask Register */
+
+#define	AT91_EMAC_MAN		0x34	/* PHY Maintenance Register */
+#define		AT91_EMAC_DATA		(0xffff << 0)	/* MDIO Data */
+#define		AT91_EMAC_REGA		(0x1f	<< 18)	/* MDIO Register */
+#define		AT91_EMAC_PHYA		(0x1f	<< 23)	/* MDIO PHY Address */
+#define		AT91_EMAC_RW		(3	<< 28)	/* Read/Write operation */
+#define			AT91_EMAC_RW_W		(1 << 28)
+#define			AT91_EMAC_RW_R		(2 << 28)
+#define		AT91_EMAC_MAN_802_3	0x40020000	/* IEEE 802.3 value */
+
+/*
+ * Statistics Registers.
+ */
+#define AT91_EMAC_FRA		0x40	/* Frames Transmitted OK */
+#define AT91_EMAC_SCOL		0x44	/* Single Collision Frame */
+#define AT91_EMAC_MCOL		0x48	/* Multiple Collision Frame */
+#define AT91_EMAC_OK		0x4c	/* Frames Received OK */
+#define AT91_EMAC_SEQE		0x50	/* Frame Check Sequence Error */
+#define AT91_EMAC_ALE		0x54	/* Alignmemt Error */
+#define AT91_EMAC_DTE		0x58	/* Deffered Transmission Frame */
+#define AT91_EMAC_LCOL		0x5c	/* Late Collision */
+#define AT91_EMAC_ECOL		0x60	/* Excessive Collision */
+#define AT91_EMAC_TUE		0x64	/* Transmit Underrun Error */
+#define AT91_EMAC_CSE		0x68	/* Carrier Sense Error */
+#define AT91_EMAC_DRFC		0x6c	/* Discard RX Frame */
+#define AT91_EMAC_ROV		0x70	/* Receive Overrun */
+#define AT91_EMAC_CDE		0x74	/* Code Error */
+#define AT91_EMAC_ELR		0x78	/* Excessive Length Error */
+#define AT91_EMAC_RJB		0x7c	/* Receive Jabber */
+#define AT91_EMAC_USF		0x80	/* Undersize Frame */
+#define AT91_EMAC_SQEE		0x84	/* SQE Test Error */
+
+/*
+ * Address Registers.
+ */
+#define AT91_EMAC_HSL		0x90	/* Hash Address Low [31:0] */
+#define AT91_EMAC_HSH		0x94	/* Hash Address High [63:32] */
+#define AT91_EMAC_SA1L		0x98	/* Specific Address 1 Low, bytes 0-3 */
+#define AT91_EMAC_SA1H		0x9c	/* Specific Address 1 High, bytes 4-5 */
+#define AT91_EMAC_SA2L		0xa0	/* Specific Address 2 Low, bytes 0-3 */
+#define AT91_EMAC_SA2H		0xa4	/* Specific Address 2 High, bytes 4-5 */
+#define AT91_EMAC_SA3L		0xa8	/* Specific Address 3 Low, bytes 0-3 */
+#define AT91_EMAC_SA3H		0xac	/* Specific Address 3 High, bytes 4-5 */
+#define AT91_EMAC_SA4L		0xb0	/* Specific Address 4 Low, bytes 0-3 */
+#define AT91_EMAC_SA4H		0xb4	/* Specific Address 4 High, bytes 4-5 */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_mci.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_mci.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_mci.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_mci.h	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,104 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_mci.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * MultiMedia Card Interface (MCI) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_MCI_H
+#define AT91RM9200_MCI_H
+
+#define AT91_MCI_CR		0x00		/* Control Register */
+#define		AT91_MCI_MCIEN		(1 <<  0)	/* Multi-Media Interface Enable */
+#define		AT91_MCI_MCIDIS		(1 <<  1)	/* Multi-Media Interface Disable */
+#define		AT91_MCI_PWSEN		(1 <<  2)	/* Power Save Mode Enable */
+#define		AT91_MCI_PWSDIS		(1 <<  3)	/* Power Save Mode Disable */
+#define		AT91_MCI_SWRST		(1 <<  7)	/* Software Reset */
+
+#define AT91_MCI_MR		0x04		/* Mode Register */
+#define		AT91_MCI_CLKDIV		(0xff  <<  0)	/* Clock Divider */
+#define		AT91_MCI_PWSDIV		(3     <<  8)	/* Power Saving Divider */
+#define		AT91_MCI_PDCPADV	(1     << 14)	/* PDC Padding Value */
+#define		AT91_MCI_PDCMODE	(1     << 15)	/* PDC-orientated Mode */
+#define		AT91_MCI_BLKLEN 	(0xfff << 18)	/* Data Block Length */
+
+#define AT91_MCI_DTOR		0x08		/* Data Timeout Register */
+#define		AT91_MCI_DTOCYC		(0xf << 0)	/* Data Timeout Cycle Number */
+#define		AT91_MCI_DTOMUL		(7   << 4)	/* Data Timeout Multiplier */
+#define		AT91_MCI_DTOMUL_1		(0 <<  4)
+#define		AT91_MCI_DTOMUL_16		(1 <<  4)
+#define		AT91_MCI_DTOMUL_128		(2 <<  4)
+#define		AT91_MCI_DTOMUL_256		(3 <<  4)
+#define		AT91_MCI_DTOMUL_1K		(4 <<  4)
+#define		AT91_MCI_DTOMUL_4K		(5 <<  4)
+#define		AT91_MCI_DTOMUL_64K		(6 <<  4)
+#define		AT91_MCI_DTOMUL_1M		(7 <<  4)
+
+#define AT91_MCI_SDCR		0x0c		/* SD Card Register */
+#define		AT91_MCI_SDCSEL		(0xf << 0)	/* SD Card Selector */
+#define		AT91_MCI_SDCBUS		(1   << 7)	/* 1-bit or 4-bit bus */
+
+#define AT91_MCI_ARGR		0x10		/* Argument Register */
+
+#define AT91_MCI_CMDR		0x14		/* Command Register */
+#define		AT91_MCI_CMDNB		(0x3f << 0)	/* Command Number */
+#define		AT91_MCI_RSPTYP		(3    << 6)	/* Response Type */
+#define			AT91_MCI_RSPTYP_NONE	(0 <<  6)
+#define			AT91_MCI_RSPTYP_48	(1 <<  6)
+#define			AT91_MCI_RSPTYP_136	(2 <<  6)
+#define		AT91_MCI_SPCMD		(7    << 8)	/* Special Command */
+#define			AT91_MCI_SPCMD_NONE	(0 <<  8)
+#define			AT91_MCI_SPCMD_INIT	(1 <<  8)
+#define			AT91_MCI_SPCMD_SYNC	(2 <<  8)
+#define			AT91_MCI_SPCMD_ICMD	(4 <<  8)
+#define			AT91_MCI_SPCMD_IRESP	(5 <<  8)
+#define		AT91_MCI_OPDCMD		(1 << 11)	/* Open Drain Command */
+#define		AT91_MCI_MAXLAT		(1 << 12)	/* Max Latency for Command to Response */
+#define		AT91_MCI_TRCMD		(3 << 16)	/* Transfer Command */
+#define			AT91_MCI_TRCMD_NONE	(0 << 16)
+#define			AT91_MCI_TRCMD_START	(1 << 16)
+#define			AT91_MCI_TRCMD_STOP	(2 << 16)
+#define		AT91_MCI_TRDIR		(1 << 18)	/* Transfer Direction */
+#define		AT91_MCI_TRTYP		(3 << 19)	/* Transfer Type */
+#define			AT91_MCI_TRTYP_BLOCK	(0 << 19)
+#define			AT91_MCI_TRTYP_MULTIPLE	(1 << 19)
+#define			AT91_MCI_TRTYP_STREAM	(2 << 19)
+
+#define AT91_MCI_RSPR(n)	(0x20 + ((n) * 4))	/* Response Registers 0-3 */
+#define AT91_MCR_RDR		0x30		/* Receive Data Register */
+#define AT91_MCR_TDR		0x34		/* Transmit Data Register */
+
+#define AT91_MCI_SR		0x40		/* Status Register */
+#define		AT91_MCI_CMDRDY		(1 <<  0)	/* Command Ready */
+#define		AT91_MCI_RXRDY		(1 <<  1) 	/* Receiver Ready */
+#define		AT91_MCI_TXRDY		(1 <<  2)	/* Transmit Ready */
+#define		AT91_MCI_BLKE		(1 <<  3)	/* Data Block Ended */
+#define		AT91_MCI_DTIP		(1 <<  4)	/* Data Transfer in Progress */
+#define		AT91_MCI_NOTBUSY	(1 <<  5)	/* Data Not Busy */
+#define		AT91_MCI_ENDRX		(1 <<  6)	/* End of RX Buffer */
+#define		AT91_MCI_ENDTX		(1 <<  7)	/* End fo TX Buffer */
+#define		AT91_MCI_RXBUFF		(1 << 14)	/* RX Buffer Full */
+#define		AT91_MCI_TXBUFE		(1 << 15)	/* TX Buffer Empty */
+#define		AT91_MCI_RINDE		(1 << 16)  	/* Response Index Error */
+#define		AT91_MCI_RDIRE		(1 << 17)	/* Response Direction Error */
+#define		AT91_MCI_RCRCE		(1 << 18)   	/* Response CRC Error */
+#define		AT91_MCI_RENDE		(1 << 19)	/* Response End Bit Error */
+#define		AT91_MCI_RTOE		(1 << 20)	/* Reponse Time-out Error */
+#define		AT91_MCI_DCRCE		(1 << 21)	/* Data CRC Error */
+#define		AT91_MCI_DTOE		(1 << 22)	/* Data Time-out Error */
+#define		AT91_MCI_OVRE		(1 << 30)	/* Overrun */
+#define		AT91_MCI_UNRE		(1 << 31)	/* Underrun */
+
+#define AT91_MCI_IER		0x44		/* Interrupt Enable Register */
+#define AT91_MCI_IDR		0x48		/* Interrupt Disable Register */
+#define AT91_MCI_IMR		0x4c		/* Interrupt Mask Register */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_pdc.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_pdc.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_pdc.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_pdc.h	Wed Jan 11 09:39:25 2006
@@ -0,0 +1,36 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_pdc.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Peripheral Data Controller (PDC) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_PDC_H
+#define AT91RM9200_PDC_H
+
+#define AT91_PDC_RPR		0x100	/* Receive Pointer Register */
+#define AT91_PDC_RCR		0x104	/* Receive Counter Register */
+#define AT91_PDC_TPR		0x108	/* Transmit Pointer Register */
+#define AT91_PDC_TCR		0x10c	/* Transmit Counter Register */
+#define AT91_PDC_RNPR		0x110	/* Receive Next Pointer Register */
+#define AT91_PDC_RNCR		0x114	/* Receive Next Counter Register */
+#define AT91_PDC_TNPR		0x118	/* Transmit Next Pointer Register */
+#define AT91_PDC_TNCR		0x11c	/* Transmit Next Counter Register */
+
+#define AT91_PDC_PTCR		0x120	/* Transfer Control Register */
+#define		AT91_PDC_RXTEN		(1 << 0)	/* Receiver Transfer Enable */
+#define		AT91_PDC_RXTDIS		(1 << 1)	/* Receiver Transfer Disable */
+#define		AT91_PDC_TXTEN		(1 << 8)	/* Transmitter Transfer Enable */
+#define		AT91_PDC_TXTDIS		(1 << 9)	/* Transmitter Transfer Disable */
+
+#define AT91_PDC_PTSR		0x124	/* Transfer Status Register */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_spi.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_spi.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_spi.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_spi.h	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,76 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_spi.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Serial Peripheral Interface (SPI) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_SPI_H
+#define AT91RM9200_SPI_H
+
+#define AT91_SPI_CR			0x00		/* Control Register */
+#define		AT91_SPI_SPIEN		(1 <<  0) 		/* SPI Enable */
+#define		AT91_SPI_SPIDIS		(1 <<  1)		/* SPI Disable */
+#define		AT91_SPI_SWRST		(1 <<  7)		/* SPI Software Reset */
+
+#define AT91_SPI_MR			0x04		/* Mode Register */
+#define		AT91_SPI_MSTR		(1    <<  0)		/* Master/Slave Mode */
+#define		AT91_SPI_PS		(1    <<  1)		/* Peripheral Select */
+#define			AT91_SPI_PS_FIXED	(0 << 1)
+#define			AT91_SPI_PS_VARIABLE	(1 << 1)
+#define		AT91_SPI_PCSDEC		(1    <<  2)		/* Chip Select Decode */
+#define		AT91_SPI_DIV32		(1    <<  3)		/* Clock Selection */
+#define		AT91_SPI_MODFDIS	(1    <<  4)		/* Mode Fault Detection */
+#define		AT91_SPI_LLB		(1    <<  7)		/* Local Loopback Enable */
+#define		AT91_SPI_PCS		(0xf  << 16)		/* Peripheral Chip Select */
+#define		AT91_SPI_DLYBCS		(0xff << 24)		/* Delay Between Chip Selects */
+
+#define AT91_SPI_RDR		0x08			/* Receive Data Register */
+#define		AT91_SPI_RD		(0xffff <<  0)		/* Receive Data */
+#define		AT91_SPI_PCS		(0xf	<< 16)		/* Peripheral Chip Select */
+
+#define AT91_SPI_TDR		0x0c			/* Transmit Data Register */
+#define		AT91_SPI_TD		(0xffff <<  0)		/* Transmit Data */
+#define		AT91_SPI_PCS		(0xf	<< 16)		/* Peripheral Chip Select */
+
+#define AT91_SPI_SR		0x10			/* Status Register */
+#define		AT91_SPI_RDRF		(1 <<  0) 		/* Receive Data Register Full */
+#define		AT91_SPI_TDRE		(1 <<  1)		/* Transmit Data Register Full */
+#define		AT91_SPI_MODF		(1 <<  2)		/* Mode Fault Error */
+#define		AT91_SPI_OVRES		(1 <<  3)		/* Overrun Error Status */
+#define		AT91_SPI_ENDRX		(1 <<  4)		/* End of RX buffer */
+#define		AT91_SPI_ENDTX		(1 <<  5)		/* End of TX buffer */
+#define		AT91_SPI_RXBUFF		(1 <<  6)		/* RX Buffer Full */
+#define		AT91_SPI_TXBUFE		(1 <<  7)		/* TX Buffer Empty */
+#define		AT91_SPI_SPIENS		(1 << 16)		/* SPI Enable Status */
+
+#define AT91_SPI_IER		0x14			/* Interrupt Enable Register */
+#define AT91_SPI_IDR		0x18			/* Interrupt Disable Register */
+#define AT91_SPI_IMR		0x1c			/* Interrupt Mask Register */
+
+#define AT91_SPI_CSR(n)		(0x30 + ((n) * 4))	/* Chip Select Registers 0-3 */
+#define		AT91_SPI_CPOL		(1    <<  0)		/* Clock Polarity */
+#define		AT91_SPI_NCPHA		(1    <<  1)		/* Clock Phase */
+#define		AT91_SPI_BITS		(0xf  <<  4)		/* Bits Per Transfer */
+#define			AT91_SPI_BITS_8		(0 << 4)
+#define 		AT91_SPI_BITS_9		(1 << 4)
+#define 		AT91_SPI_BITS_10	(2 << 4)
+#define 		AT91_SPI_BITS_11	(3 << 4)
+#define 		AT91_SPI_BITS_12	(4 << 4)
+#define 		AT91_SPI_BITS_13	(5 << 4)
+#define 		AT91_SPI_BITS_14	(6 << 4)
+#define 		AT91_SPI_BITS_15	(7 << 4)
+#define 		AT91_SPI_BITS_16	(8 << 4)
+#define		AT91_SPI_SCBR		(0xff <<  8)		/* Serial Clock Baud Rate */
+#define		AT91_SPI_DLYBS		(0xff << 16)		/* Delay before SPCK */
+#define		AT91_SPI_DLYBCT		(0xff << 24)		/* Delay between Consecutive Transfers */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_ssc.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_ssc.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_ssc.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_ssc.h	Wed Jan 11 15:17:56 2006
@@ -0,0 +1,96 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_ssc.h
+ *
+ * Copyright (C) SAN People
+ *
+ * Serial Synchronous Controller (SSC) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_SSC_H
+#define AT91RM9200_SSC_H
+
+#define AT91_SSC_CR		0x00	/* Control Register */
+#define		AT91_SSC_RXEN		(1 <<  0)	/* Receive Enable */
+#define		AT91_SSC_RXDIS		(1 <<  1)	/* Receive Disable */
+#define		AT91_SSC_TXEN		(1 <<  8)	/* Transmit Enable */
+#define		AT91_SSC_TXDIS		(1 <<  9)	/* Transmit Disable */
+#define		AT91_SSC_SWRST		(1 << 15)	/* Software Reset */
+
+#define AT91_SSC_CMR		0x04	/* Clock Mode Register */
+#define		AT91_SSC_CMR_DIV	(0xfff << 0)	/* Clock Divider */
+
+#define AT91_SSC_RCMR		0x10	/* Receive Clock Mode Register */
+#define		AT91_SSC_CKS		(3    <<  0)	/* Clock Selection */
+#define			AT91_SSC_CKS_DIV		(0 << 0)
+#define			AT91_SSC_CKS_CLOCK		(1 << 0)
+#define			AT91_SSC_CKS_PIN		(2 << 0)
+#define		AT91_SSC_CKO		(7    <<  2)	/* Clock Output Mode Selection */
+#define			AT91_SSC_CKO_NONE		(0 << 2)
+#define			AT91_SSC_CKO_CONTINUOUS		(1 << 2)
+#define		AT91_SSC_CKI		(1    <<  5)	/* Clock Inversion */
+#define			AT91_SSC_CKI_FALLING		(0 << 5)
+#define			AT91_SSC_CK_RISING		(1 << 5)
+#define		AT91_SSC_START		(0xf  <<  8)	/* Start Selection */
+#define			AT91_SSC_START_CONTINUOUS	(0 << 8)
+#define			AT91_SSC_START_TX_RX		(1 << 8)
+#define			AT91_SSC_START_LOW_RF		(2 << 8)
+#define			AT91_SSC_START_HIGH_RF		(3 << 8)
+#define			AT91_SSC_START_FALLING_RF	(4 << 8)
+#define			AT91_SSC_START_RISING_RF	(5 << 8)
+#define			AT91_SSC_START_LEVEL_RF		(6 << 8)
+#define			AT91_SSC_START_EDGE_RF		(7 << 8)
+#define		AT91_SSC_STTDLY		(0xff << 16)	/* Start Delay */
+#define		AT91_SSC_PERIOD		(0xff << 24)	/* Period Divider Selection */
+
+#define AT91_SSC_RFMR		0x14	/* Receive Frame Mode Register */
+#define		AT91_SSC_DATALEN	(0x1f <<  0)	/* Data Length */
+#define		AT91_SSC_LOOP		(1    <<  5)	/* Loop Mode */
+#define		AT91_SSC_MSBF		(1    <<  7)	/* Most Significant Bit First */
+#define		AT91_SSC_DATNB		(0xf  <<  8)	/* Data Number per Frame */
+#define		AT91_SSC_FSLEN		(0xf  << 16)	/* Frame Sync Length */
+#define		AT91_SSC_FSOS		(7    << 20)	/* Frame Sync Output Selection */
+#define			AT91_SSC_FSOS_NONE		(0 << 20)
+#define			AT91_SSC_FSOS_NEGATIVE		(1 << 20)
+#define			AT91_SSC_FSOS_POSITIVE		(2 << 20)
+#define			AT91_SSC_FSOS_LOW		(3 << 20)
+#define			AT91_SSC_FSOS_HIGH		(4 << 20)
+#define			AT91_SSC_FSOS_TOGGLE		(5 << 20)
+#define		AT91_SSC_FSEDGE		(1    << 24)	/* Frame Sync Edge Detection */
+#define			AT91_SSC_FSEDGE_POSITIVE	(0 << 24)
+#define			AT91_SSC_FSEDGE_NEGATIVE	(1 << 24)
+
+#define AT91_SSC_TCMR		0x18	/* Transmit Clock Mode Register */
+#define AT91_SSC_TFMR		0x1c	/* Transmit Fram Mode Register */
+#define		AT91_SSC_DATDEF		(1 <<  5)	/* Data Default Value */
+#define		AT91_SSC_FSDEN		(1 << 23)	/* Frame Sync Data Enable */
+
+#define AT91_SSC_RHR		0x20	/* Receive Holding Register */
+#define AT91_SSC_THR		0x24	/* Transmit Holding Register */
+#define AT91_SSC_RSHR		0x30	/* Receive Sync Holding Register */
+#define AT91_SSC_TSHR		0x34	/* Transmit Sync Holding Register */
+
+#define AT91_SSC_SR		0x40	/* Status Register */
+#define		AT91_SSC_TXRDY		(1 <<  0)	/* Transmit Ready */
+#define		AT91_SSC_TXEMPTY	(1 <<  1)	/* Transmit Empty */
+#define		AT91_SSC_ENDTX		(1 <<  2)	/* End of Transmission */
+#define		AT91_SSC_TXBUFE		(1 <<  3)	/* Transmit Buffer Empty */
+#define		AT91_SSC_RXRDY		(1 <<  4)	/* Receive Ready */
+#define		AT91_SSC_OVRUN		(1 <<  5)	/* Receive Overrun */
+#define		AT91_SSC_ENDRX		(1 <<  6)	/* End of Reception */
+#define		AT91_SSC_RXBUFF		(1 <<  7)	/* Receive Buffer Full */
+#define		AT91_SSC_TXSYN		(1 << 10)	/* Transmit Sync */
+#define		AT91_SSC_RXSYN		(1 << 11)	/* Receive Sync */
+#define		AT91_SSC_TXEN		(1 << 16)	/* Transmit Enable */
+#define		AT91_SSC_RXEN		(1 << 17)	/* Receive Enable */
+
+#define AT91_SSC_IER		0x44	/* Interrupt Enable Register */
+#define AT91_SSC_IDR		0x48	/* Interrupt Disable Register */
+#define AT91_SSC_IMR		0x4c	/* Interrupt Mask Register */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_sys.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_sys.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_sys.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_sys.h	Wed Jan 11 16:29:07 2006
@@ -0,0 +1,425 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_sys.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_SYS_H
+#define AT91RM9200_SYS_H
+
+/*
+ * Advanced Interrupt Controller.
+ */
+#define AT91_AIC	0x000
+
+#define AT91_AIC_SMR(n)		(AT91_AIC + ((n) * 4))	/* Source Mode Registers 0-31 */
+#define		AT91_AIC_PRIOR		(7 << 0)		/* Priority Level */
+#define		AT91_AIC_SRCTYPE	(3 << 5)		/* Interrupt Source Type */
+#define			AT91_AIC_SRCTYPE_LOW		(0 << 5)
+#define			AT91_AIC_SRCTYPE_FALLING	(1 << 5)
+#define			AT91_AIC_SRCTYPE_HIGH		(2 << 5)
+#define			AT91_AIC_SRCTYPE_RISING		(3 << 5)
+
+#define AT91_AIC_SVR(n)		(AT91_AIC + 0x80 + ((n) * 4))	/* Source Vector Registers 0-31 */
+#define AT91_AIC_IVR		(AT91_AIC + 0x100)	/* Interrupt Vector Register */
+#define AT91_AIC_FVR		(AT91_AIC + 0x104)	/* Fast Interrupt Vector Register */
+#define AT91_AIC_ISR		(AT91_AIC + 0x108)	/* Interrupt Status Register */
+#define		AT91_AIC_IRQID		(0x1f << 0)		/* Current Interrupt Identifier */
+
+#define AT91_AIC_IPR		(AT91_AIC + 0x10c)	/* Interrupt Pending Register */
+#define AT91_AIC_IMR		(AT91_AIC + 0x110)	/* Interrupt Mask Register */
+#define AT91_AIC_CISR		(AT91_AIC + 0x114)	/* Core Interrupt Status Register */
+#define		AT91_AIC_NFIQ		(1 << 0)		/* nFIQ Status */
+#define		AT91_AIC_NIRQ		(1 << 1)		/* nIRQ Status */
+
+#define AT91_AIC_IECR		(AT91_AIC + 0x120)	/* Interrupt Enable Command Register */
+#define AT91_AIC_IDCR		(AT91_AIC + 0x124)	/* Interrupt Disable Command Register */
+#define AT91_AIC_ICCR		(AT91_AIC + 0x128)	/* Interrupt Clear Command Register */
+#define AT91_AIC_ISCR		(AT91_AIC + 0x12c)	/* Interrupt Set Command Register */
+#define AT91_AIC_EOICR		(AT91_AIC + 0x130)	/* End of Interrupt Command Register */
+#define AT91_AIC_SPU		(AT91_AIC + 0x134)	/* Spurious Interrupt Vector Register */
+#define AT91_AIC_DCR		(AT91_AIC + 0x138)	/* Debug Control Register */
+#define		AT91_AIC_DCR_PROT	(1 << 0)		/* Protection Mode */
+#define		AT91_AIC_DCR_GMSK	(1 << 1)		/* General Mask */
+
+
+/*
+ * Debug Unit.
+ */
+#define AT91_DBGU	0x200
+
+#define AT91_DBGU_CR		(AT91_DBGU + 0x00)	/* Control Register */
+#define AT91_DBGU_MR		(AT91_DBGU + 0x04)	/* Mode Register */
+#define AT91_DBGU_IER		(AT91_DBGU + 0x08)	/* Interrupt Enable Register */
+#define		AT91_DBGU_TXRDY		(1 << 1)		/* Transmitter Ready */
+#define		AT91_DBGU_TXEMPTY	(1 << 9)		/* Transmitter Empty */
+#define AT91_DBGU_IDR		(AT91_DBGU + 0x0c)	/* Interrupt Disable Register */
+#define AT91_DBGU_IMR		(AT91_DBGU + 0x10)	/* Interrupt Mask Register */
+#define AT91_DBGU_SR		(AT91_DBGU + 0x14)	/* Status Register */
+#define AT91_DBGU_RHR		(AT91_DBGU + 0x18)	/* Receiver Holding Register */
+#define AT91_DBGU_THR		(AT91_DBGU + 0x1c)	/* Transmitter Holding Register */
+#define AT91_DBGU_BRGR		(AT91_DBGU + 0x20)	/* Baud Rate Generator Register */
+#define AT91_DBGU_CIDR		(AT91_DBGU + 0x40)	/* Chip ID Register */
+#define AT91_DBGU_EXID		(AT91_DBGU + 0x44)	/* Chip ID Extension Register */
+
+
+/*
+ * PIO Controllers.
+ */
+#define AT91_PIOA	0x400
+#define AT91_PIOB	0x600
+#define AT91_PIOC	0x800
+#define AT91_PIOD	0xa00
+
+#define PIO_PER		0x00	/* Enable Register */
+#define PIO_PDR		0x04	/* Disable Register */
+#define PIO_PSR		0x08	/* Status Register */
+#define PIO_OER		0x10	/* Output Enable Register */
+#define PIO_ODR		0x14	/* Output Disable Register */
+#define PIO_OSR		0x18	/* Output Status Register */
+#define PIO_IFER	0x20	/* Glitch Input Filter Enable */
+#define PIO_IFDR	0x24	/* Glitch Input Filter Disable */
+#define PIO_IFSR	0x28	/* Glitch Input Filter Status */
+#define PIO_SODR	0x30	/* Set Output Data Register */
+#define PIO_CODR	0x34	/* Clear Output Data Register */
+#define PIO_ODSR	0x38	/* Output Data Status Register */
+#define PIO_PDSR	0x3c	/* Pin Data Status Register */
+#define PIO_IER		0x40	/* Interrupt Enable Register */
+#define PIO_IDR		0x44	/* Interrupt Disable Register */
+#define PIO_IMR		0x48	/* Interrupt Mask Register */
+#define PIO_ISR		0x4c	/* Interrupt Status Register */
+#define PIO_MDER	0x50	/* Multi-driver Enable Register */
+#define PIO_MDDR	0x54	/* Multi-driver Disable Register */
+#define PIO_MDSR	0x58	/* Multi-driver Status Register */
+#define PIO_PUDR	0x60	/* Pull-up Disable Register */
+#define PIO_PUER	0x64	/* Pull-up Enable Register */
+#define PIO_PUSR	0x68	/* Pull-up Status Register */
+#define PIO_ASR		0x70	/* Peripheral A Select Register */
+#define PIO_BSR		0x74	/* Peripheral B Select Register */
+#define PIO_ABSR	0x78	/* AB Status Register */
+#define PIO_OWER	0xa0	/* Output Write Enable Register */
+#define PIO_OWDR	0xa4	/* Output Write Disable Register */
+#define PIO_OWSR	0xa8	/* Output Write Status Register */
+
+#define AT91_PIO_P(n)	(1 << (n))
+
+
+/*
+ * Power Management Controller.
+ */
+#define	AT91_PMC	0xc00
+
+#define	AT91_PMC_SCER		(AT91_PMC + 0x00)	/* System Clock Enable Register */
+#define	AT91_PMC_SCDR		(AT91_PMC + 0x04)	/* System Clock Disable Register */
+
+#define	AT91_PMC_SCSR		(AT91_PMC + 0x08)	/* System Clock Status Register */
+#define		AT91_PMC_PCK		(1 <<  0)		/* Processor Clock */
+#define		AT91_PMC_UDP		(1 <<  1)		/* USB Devcice Port Clock */
+#define		AT91_PMC_MCKUDP		(1 <<  2)		/* USB Device Port Master Clock Automatic Disable on Suspend */
+#define		AT91_PMC_UHP		(1 <<  4)		/* USB Host Port Clock */
+#define		AT91_PMC_PCK0		(1 <<  8)		/* Programmable Clock 0 */
+#define		AT91_PMC_PCK1		(1 <<  9)		/* Programmable Clock 1 */
+#define		AT91_PMC_PCK2		(1 << 10)		/* Programmable Clock 2 */
+#define		AT91_PMC_PCK3		(1 << 11)		/* Programmable Clock 3 */
+
+#define	AT91_PMC_PCER		(AT91_PMC + 0x10)	/* Peripheral Clock Enable Register */
+#define	AT91_PMC_PCDR		(AT91_PMC + 0x14)	/* Peripheral Clock Disable Register */
+#define	AT91_PMC_PCSR		(AT91_PMC + 0x18)	/* Peripheral Clock Status Register */
+
+#define	AT91_CKGR_MOR		(AT91_PMC + 0x20)	/* Main Oscillator Register */
+#define		AT91_PMC_MOSCEN		(1    << 0)		/* Main Oscillator Enable */
+#define		AT91_PMC_OSCOUNT	(0xff << 8)		/* Main Oscillator Start-up Time */
+
+#define	AT91_CKGR_MCFR		(AT91_PMC + 0x24)	/* Main Clock Frequency Register */
+#define		AT91_PMC_MAINF		(0xffff <<  0)		/* Main Clock Frequency */
+#define		AT91_PMC_MAINRDY	(1	<< 16)		/* Main Clock Ready */
+
+#define	AT91_CKGR_PLLAR		(AT91_PMC + 0x28)	/* PLL A Register */
+#define	AT91_CKGR_PLLBR		(AT91_PMC + 0x2c)	/* PLL B Register */
+#define		AT91_PMC_DIV		(0xff  <<  0)		/* Divider */
+#define		AT91_PMC_PLLCOUNT	(0x3f  <<  8)		/* PLL Counter */
+#define		AT91_PMC_OUT		(3     << 14)		/* PLL Clock Frequency Range */
+#define		AT91_PMC_MUL		(0x7ff << 16)		/* PLL Multiplier */
+#define		AT91_PMC_USB96M		(1     << 28)		/* Divider by 2 Enable (PLLB only) */
+
+#define	AT91_PMC_MCKR		(AT91_PMC + 0x30)	/* Master Clock Register */
+#define		AT91_PMC_CSS		(3 <<  0)		/* Master Clock Selection */
+#define			AT91_PMC_CSS_SLOW		(0 << 0)
+#define			AT91_PMC_CSS_MAIN		(1 << 0)
+#define			AT91_PMC_CSS_PLLA		(2 << 0)
+#define			AT91_PMC_CSS_PLLB		(3 << 0)
+#define		AT91_PMC_PRES		(7 <<  2)		/* Master Clock Prescaler */
+#define 		AT91_PMC_PRES_1			(0 << 2)
+#define			AT91_PMC_PRES_2			(1 << 2)
+#define			AT91_PMC_PRES_4			(2 << 2)
+#define			AT91_PMC_PRES_8			(3 << 2)
+#define			AT91_PMC_PRES_16		(4 << 2)
+#define			AT91_PMC_PRES_32		(5 << 2)
+#define			AT91_PMC_PRES_64		(6 << 2)
+#define		AT91_PMC_MDIV		(3 <<  8)		/* Master Clock Division */
+#define			AT91_PMC_MDIV_1			(0 << 8)
+#define			AT91_PMC_MDIV_2			(1 << 8)
+#define			AT91_PMC_MDIV_3			(2 << 8)
+#define			AT91_PMC_MDIV_4			(3 << 8)
+
+#define	AT91_PMC_PCKR(n)	(AT91_PMC + 0x40 + ((n) * 4))	/* Programmable Clock 0-3 Registers */
+#define	AT91_PMC_IER		(AT91_PMC + 0x60)	/* Interrupt Enable Register */
+#define	AT91_PMC_IDR		(AT91_PMC + 0x64)	/* Interrupt Disable Register */
+#define	AT91_PMC_SR		(AT91_PMC + 0x68)	/* Status Register */
+#define		AT91_PMC_MOSCS		(1 <<  0)		/* MOSCS Flag */
+#define		AT91_PMC_LOCKA		(1 <<  1)		/* PLLA Lock */
+#define		AT91_PMC_LOCKB		(1 <<  2)		/* PLLB Lock */
+#define		AT91_PMC_MCKRDY		(1 <<  3)		/* Master Clock */
+#define		AT91_PMC_PCK0RDY	(1 <<  8)		/* Programmable Clock 0 */
+#define		AT91_PMC_PCK1RDY	(1 <<  9)		/* Programmable Clock 1 */
+#define		AT91_PMC_PCK2RDY	(1 << 10)		/* Programmable Clock 2 */
+#define		AT91_PMC_PCK3RDY	(1 << 11)		/* Programmable Clock 3 */
+#define	AT91_PMC_IMR		(AT91_PMC + 0x6c)	/* Interrupt Mask Register */
+
+
+/*
+ * System Timer.
+ */
+#define	AT91_ST		0xd00
+
+#define	AT91_ST_CR		(AT91_ST + 0x00)	/* Control Register */
+#define 	AT91_ST_WDRST		(1 << 0)		/* Watchdog Timer Restart */
+#define	AT91_ST_PIMR		(AT91_ST + 0x04)	/* Period Interval Mode Register */
+#define		AT91_ST_PIV		(0xffff <<  0)		/* Period Interval Value */
+#define	AT91_ST_WDMR		(AT91_ST + 0x08)	/* Watchdog Mode Register */
+#define		AT91_ST_WDV		(0xffff <<  0)		/* Watchdog Counter Value */
+#define		AT91_ST_RSTEN		(1	<< 16)		/* Reset Enable */
+#define		AT91_ST_EXTEN		(1	<< 17)		/* External Signal Assertion Enable */
+#define	AT91_ST_RTMR		(AT91_ST + 0x0c)	/* Real-time Mode Register */
+#define		AT91_ST_RTPRES		(0xffff <<  0)		/* Real-time Prescalar Value */
+#define	AT91_ST_SR		(AT91_ST + 0x10)	/* Status Register */
+#define		AT91_ST_PITS		(1 << 0)		/* Period Interval Timer Status */
+#define		AT91_ST_WDOVF		(1 << 1) 		/* Watchdog Overflow */
+#define		AT91_ST_RTTINC		(1 << 2) 		/* Real-time Timer Increment */
+#define		AT91_ST_ALMS		(1 << 3) 		/* Alarm Status */
+#define	AT91_ST_IER		(AT91_ST + 0x14)	/* Interrupt Enable Register */
+#define	AT91_ST_IDR		(AT91_ST + 0x18)	/* Interrupt Disable Register */
+#define	AT91_ST_IMR		(AT91_ST + 0x1c)	/* Interrupt Mask Register */
+#define	AT91_ST_RTAR		(AT91_ST + 0x20)	/* Real-time Alarm Register */
+#define		AT91_ST_ALMV		(0xfffff << 0)		/* Alarm Value */
+#define	AT91_ST_CRTR		(AT91_ST + 0x24)	/* Current Real-time Register */
+#define		AT91_ST_CRTV		(0xfffff << 0)		/* Current Real-Time Value */
+
+
+/*
+ * Real-time Clock.
+ */
+#define	AT91_RTC	0xe00
+
+#define	AT91_RTC_CR		(AT91_RTC + 0x00)	/* Control Register */
+#define		AT91_RTC_UPDTIM		(1 <<  0)		/* Update Request Time Register */
+#define		AT91_RTC_UPDCAL		(1 <<  1)		/* Update Request Calendar Register */
+#define		AT91_RTC_TIMEVSEL	(3 <<  8)		/* Time Event Selection */
+#define			AT91_RTC_TIMEVSEL_MINUTE	(0 << 8)
+#define 		AT91_RTC_TIMEVSEL_HOUR		(1 << 8)
+#define 		AT91_RTC_TIMEVSEL_DAY24		(2 << 8)
+#define 		AT91_RTC_TIMEVSEL_DAY12		(3 << 8)
+#define		AT91_RTC_CALEVSEL	(3 << 16)		/* Calendar Event Selection */
+#define 		AT91_RTC_CALEVSEL_WEEK		(0 << 16)
+#define 		AT91_RTC_CALEVSEL_MONTH		(1 << 16)
+#define 		AT91_RTC_CALEVSEL_YEAR		(2 << 16)
+
+#define	AT91_RTC_MR		(AT91_RTC + 0x04)	/* Mode Register */
+#define 	AT91_RTC_HRMOD		(1 <<  0)		/* 12/24 Hour Mode */
+
+#define	AT91_RTC_TIMR		(AT91_RTC + 0x08)	/* Time Register */
+#define		AT91_RTC_SEC		(0x7f <<  0)		/* Current Second */
+#define		AT91_RTC_MIN		(0x7f <<  8)		/* Current Minute */
+#define		AT91_RTC_HOUR 		(0x3f << 16)		/* Current Hour */
+#define		AT91_RTC_AMPM		(1    << 22)		/* Ante Meridiem Post Meridiem Indicator */
+
+#define	AT91_RTC_CALR		(AT91_RTC + 0x0c)	/* Calendar Register */
+#define		AT91_RTC_CENT		(0x7f <<  0)		/* Current Century */
+#define		AT91_RTC_YEAR		(0xff <<  8)		/* Current Year */
+#define		AT91_RTC_MONTH		(0x1f << 16)		/* Current Month */
+#define		AT91_RTC_DAY		(7    << 21)		/* Current Day */
+#define		AT91_RTC_DATE		(0x3f << 24)		/* Current Date */
+
+#define	AT91_RTC_TIMALR		(AT91_RTC + 0x10)	/* Time Alarm Register */
+#define		AT91_RTC_SECEN		(1 <<  7)		/* Second Alarm Enable */
+#define		AT91_RTC_MINEN		(1 << 15)		/* Minute Alarm Enable */
+#define		AT91_RTC_HOUREN		(1 << 23)		/* Hour Alarm Enable */
+
+#define	AT91_RTC_CALALR		(AT91_RTC + 0x14)	/* Calendar Alarm Register */
+#define		AT91_RTC_MTHEN		(1 << 23)		/* Month Alarm Enable */
+#define		AT91_RTC_DATEEN		(1 << 31)		/* Date Alarm Enable */
+
+#define	AT91_RTC_SR		(AT91_RTC + 0x18)	/* Status Register */
+#define		AT91_RTC_ACKUPD		(1 <<  0)		/* Acknowledge for Update */
+#define		AT91_RTC_ALARM		(1 <<  1)		/* Alarm Flag */
+#define		AT91_RTC_SECEV		(1 <<  2)		/* Second Event */
+#define		AT91_RTC_TIMEV		(1 <<  3)		/* Time Event */
+#define		AT91_RTC_CALEV		(1 <<  4)		/* Calendar Event */
+
+#define	AT91_RTC_SCCR		(AT91_RTC + 0x1c)	/* Status Clear Command Register */
+#define	AT91_RTC_IER		(AT91_RTC + 0x20)	/* Interrupt Enable Register */
+#define	AT91_RTC_IDR		(AT91_RTC + 0x24)	/* Interrupt Disable Register */
+#define	AT91_RTC_IMR		(AT91_RTC + 0x28)	/* Interrupt Mask Register */
+
+#define	AT91_RTC_VER		(AT91_RTC + 0x2c)	/* Valid Entry Register */
+#define		AT91_RTC_NVTIM		(1 <<  0)		/* Non valid Time */
+#define		AT91_RTC_NVCAL		(1 <<  1)		/* Non valid Calendar */
+#define		AT91_RTC_NVTIMALR	(1 <<  2)		/* Non valid Time Alarm */
+#define		AT91_RTC_NVCALALR	(1 <<  3)		/* Non valid Calendar Alarm */
+
+
+/*
+ * Memory Controller.
+ */
+#define AT91_MC		0xf00
+
+#define AT91_MC_RCR		(AT91_MC + 0x00)	/* MC Remap Control Register */
+#define		AT91_MC_RCB		(1 <<  0)		/* Remap Command Bit */
+
+#define AT91_MC_ASR		(AT91_MC + 0x04)	/* MC Abort Status Register */
+#define		AT91_MC_UNADD		(1 <<  0)		/* Undefined Address Abort Status */
+#define		AT91_MC_MISADD		(1 <<  1)		/* Misaligned Address Abort Status */
+#define		AT91_MC_ABTSZ		(3 <<  8)		/* Abort Size Status */
+#define			AT91_MC_ABTSZ_BYTE		(0 << 8)
+#define			AT91_MC_ABTSZ_HALFWORD		(1 << 8)
+#define			AT91_MC_ABTSZ_WORD		(2 << 8)
+#define		AT91_MC_ABTTYP		(3 << 10)		/* Abort Type Status */
+#define			AT91_MC_ABTTYP_DATAREAD		(0 << 10)
+#define			AT91_MC_ABTTYP_DATAWRITE	(1 << 10)
+#define			AT91_MC_ABTTYP_FETCH		(2 << 10) 
+#define		AT91_MC_MST0		(1 << 16)		/* ARM920T Abort Source */
+#define		AT91_MC_MST1		(1 << 17)		/* PDC Abort Source */
+#define		AT91_MC_MST2		(1 << 18)		/* UHP Abort Source */
+#define		AT91_MC_MST3		(1 << 19)		/* EMAC Abort Source */
+#define		AT91_MC_SVMST0		(1 << 24)		/* Saved ARM920T Abort Source */
+#define		AT91_MC_SVMST1		(1 << 25)		/* Saved PDC Abort Source */
+#define		AT91_MC_SVMST2		(1 << 26)		/* Saved UHP Abort Source */
+#define		AT91_MC_SVMST3		(1 << 27)		/* Saved EMAC Abort Source */
+
+#define AT91_MC_AASR		(AT91_MC + 0x08)	/* MC Abort Address Status Register */
+
+#define AT91_MC_MPR		(AT91_MC + 0x0c)	/* MC Master Priority Register */
+#define		AT91_MPR_MSTP0		(7 <<  0)		/* ARM920T Priority */
+#define		AT91_MPR_MSTP1		(7 <<  4)		/* PDC Priority */
+#define		AT91_MPR_MSTP2		(7 <<  8)		/* UHP Priority */
+#define		AT91_MPR_MSTP3		(7 << 12)		/* EMAC Priority */
+
+/* External Bus Interface (EBI) registers */
+#define AT91_EBI_CSA		(AT91_MC + 0x60)	/* Chip Select Assignment Register */
+#define		AT91_EBI_CS0A		(1 << 0)		/* Chip Select 0 Assignment */
+#define			AT91_EBI_CS0A_SMC		(0 << 0)
+#define			AT91_EBI_CS0A_BFC		(1 << 0)
+#define		AT91_EBI_CS1A		(1 << 1)		/* Chip Select 1 Assignment */
+#define			AT91_EBI_CS1A_SMC		(0 << 1)
+#define			AT91_EBI_CS1A_SDRAMC		(1 << 1)
+#define		AT91_EBI_CS3A		(1 << 3)		/* Chip Select 2 Assignment */
+#define			AT91_EBI_CS3A_SMC		(0 << 3)
+#define			AT91_EBI_CS3A_SMC_SMARTMEDIA	(1 << 3)
+#define		AT91_EBI_CS4A		(1 << 4)		/* Chip Select 3 Assignment */
+#define			AT91_EBI_CS4A_SMC		(0 << 4)
+#define			AT91_EBI_CS4A_SMC_COMPACTFLASH	(1 << 4)
+#define AT91_EBI_CFGR		(AT91_MC + 0x64)	/* Configuration Register */
+#define		AT91_EBI_DBPUC		(1 << 0)		/* Data Bus Pull-Up Configuration */
+
+/* Static Memory Controller (SMC) registers */
+#define	AT91_SMC_CSR(n)		(AT91_MC + 0x70 + ((n) * 4))/* SMC Chip Select Register */
+#define		AT91_SMC_NWS		(0x7f <<  0)		/* Number of Wait States */
+#define			AT91_SMC_NWS_(x)	((x) << 0)
+#define		AT91_SMC_WSEN		(1    <<  7)		/* Wait State Enable */
+#define		AT91_SMC_TDF		(0xf  <<  8)		/* Data Float Time */
+#define			AT91_SMC_TDF_(x)	((x) << 8)
+#define		AT91_SMC_BAT		(1    << 12)		/* Byte Access Type */
+#define		AT91_SMC_DBW		(3    << 13)		/* Data Bus Width */
+#define			AT91_SMC_DBW_16		(1 << 13)
+#define			AT91_SMC_DBW_8		(2 << 13)
+#define		AT91_SMC_DPR		(1 << 15)		/* Data Read Protocol */
+#define		AT91_SMC_ACSS		(3 << 16)		/* Address to Chip Select Setup */
+#define			AT91_SMC_ACSS_STD	(0 << 16)
+#define			AT91_SMC_ACSS_1		(1 << 16)
+#define			AT91_SMC_ACSS_2		(2 << 16)
+#define			AT91_SMC_ACSS_3		(3 << 16)
+#define		AT91_SMC_RWSETUP	(7 << 24)		/* Read & Write Signal Time Setup */
+#define			AT91_SMC_RWSETUP_(x)	((x) << 24)
+#define		AT91_SMC_RWHOLD		(7 << 28)		/* Read & Write Signal Hold Time */
+#define			AT91_SMC_RWHOLD_(x)	((x) << 28)
+
+/* SDRAM Controller registers */
+#define AT91_SDRAMC_MR		(AT91_MC + 0x90)	/* Mode Register */
+#define		AT91_SDRAMC_MODE	(0xf << 0)		/* Command Mode */
+#define			AT91_SDRAMC_MODE_NORMAL		(0 << 0)
+#define			AT91_SDRAMC_MODE_NOP		(1 << 0)
+#define			AT91_SDRAMC_MODE_PRECHARGE	(2 << 0)
+#define			AT91_SDRAMC_MODE_LMR		(3 << 0)
+#define			AT91_SDRAMC_MODE_REFRESH	(4 << 0)
+#define		AT91_SDRAMC_DBW		(1   << 4)		/* Data Bus Width */
+#define			AT91_SDRAMC_DBW_32	(0 << 4)
+#define			AT91_SDRAMC_DBW_16	(1 << 4)
+
+#define AT91_SDRAMC_TR		(AT91_MC + 0x94)	/* Refresh Timer Register */
+#define		AT91_SDRAMC_COUNT	(0xfff << 0)		/* Refresh Timer Count */
+
+#define AT91_SDRAMC_CR		(AT91_MC + 0x98)	/* Configuration Register */
+#define		AT91_SDRAMC_NC		(3   <<  0)		/* Number of Column Bits */
+#define			AT91_SDRAMC_NC_8	(0 << 0)
+#define			AT91_SDRAMC_NC_9	(1 << 0)
+#define			AT91_SDRAMC_NC_10	(2 << 0)
+#define			AT91_SDRAMC_NC_11	(3 << 0)
+#define		AT91_SDRAMC_NR		(3   <<  2)		/* Number of Row Bits */
+#define			AT91_SDRAMC_NR_11	(0 << 2)
+#define			AT91_SDRAMC_NR_12	(1 << 2)
+#define			AT91_SDRAMC_NR_13	(2 << 2)
+#define		AT91_SDRAMC_NB		(1   <<  4)		/* Number of Banks */
+#define			AT91_SDRAMC_NB_2	(0 << 4)
+#define			AT91_SDRAMC_NB_4	(1 << 4)
+#define		AT91_SDRAMC_CAS		(3   <<  5)		/* CAS Latency */
+#define			AT91_SDRAMC_CAS_2	(2 << 5)
+#define		AT91_SDRAMC_TWR		(0xf <<  7)		/* Write Recovery Delay */
+#define		AT91_SDRAMC_TRC		(0xf << 11)		/* Row Cycle Delay */
+#define		AT91_SDRAMC_TRP		(0xf << 15)		/* Row Precharge Delay */
+#define		AT91_SDRAMC_TRCD	(0xf << 19)		/* Row to Column Delay */
+#define		AT91_SDRAMC_TRAS	(0xf << 23)		/* Active to Precharge Delay */
+#define		AT91_SDRAMC_TXSR	(0xf << 27)		/* Exit Self Refresh to Active Delay */
+
+#define AT91_SDRAMC_SRR		(AT91_MC + 0x9c)	/* Self Refresh Register */
+#define AT91_SDRAMC_LPR		(AT91_MC + 0xa0)	/* Low Power Register */
+#define AT91_SDRAMC_IER		(AT91_MC + 0xa4)	/* Interrupt Enable Register */
+#define AT91_SDRAMC_IDR		(AT91_MC + 0xa8)	/* Interrupt Disable Register */
+#define AT91_SDRAMC_IMR		(AT91_MC + 0xac)	/* Interrupt Mask Register */
+#define AT91_SDRAMC_ISR		(AT91_MC + 0xb0)	/* Interrupt Status Register */
+
+/* Burst Flash Controller register */
+#define AT91_BFC_MR		(AT91_MC + 0xc0)	/* Mode Register */
+#define		AT91_BFC_BFCOM		(3   <<  0)		/* Burst Flash Controller Operating Mode */
+#define			AT91_BFC_BFCOM_DISABLED	(0 << 0)
+#define			AT91_BFC_BFCOM_ASYNC	(1 << 0)
+#define			AT91_BFC_BFCOM_BURST	(2 << 0)
+#define		AT91_BFC_BFCC		(3   <<  2)		/* Burst Flash Controller Clock */
+#define			AT91_BFC_BFCC_MCK	(1 << 2)
+#define			AT91_BFC_BFCC_DIV2	(2 << 2)
+#define			AT91_BFC_BFCC_DIV4	(3 << 2)
+#define		AT91_BFC_AVL		(0xf <<  4)		/* Address Valid Latency */ 
+#define		AT91_BFC_PAGES		(7   <<  8)		/* Page Size */
+#define			AT91_BFC_PAGES_NO_PAGE	(0 << 8)
+#define			AT91_BFC_PAGES_16	(1 << 8)
+#define			AT91_BFC_PAGES_32	(2 << 8)
+#define			AT91_BFC_PAGES_64	(3 << 8)
+#define			AT91_BFC_PAGES_128	(4 << 8)
+#define			AT91_BFC_PAGES_256	(5 << 8)
+#define			AT91_BFC_PAGES_512	(6 << 8)
+#define			AT91_BFC_PAGES_1024	(7 << 8)
+#define		AT91_BFC_OEL		(3   << 12)		/* Output Enable Latency */
+#define		AT91_BFC_BAAEN		(1   << 16)		/* Burst Address Advance Enable */
+#define		AT91_BFC_BFOEH		(1   << 17)		/* Burst Flash Output Enable Handling */
+#define		AT91_BFC_MUXEN		(1   << 18)		/* Multiplexed Bus Enable */
+#define		AT91_BFC_RDYEN		(1   << 19)		/* Ready Enable Mode */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_tc.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_tc.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_tc.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_tc.h	Wed Jan 11 16:25:29 2006
@@ -0,0 +1,146 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_pdc.h
+ *
+ * Copyright (C) SAN People
+ *
+ * Timer/Counter Unit (TC) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_TC_H
+#define AT91RM9200_TC_H
+
+#define AT91_TC_BCR		0xc0		/* TC Block Control Register */
+#define		AT91_TC_SYNC		(1 << 0)	/* Synchro Command */
+
+#define AT91_TC_BMR		0xc4		/* TC Block Mode Register */
+#define		AT91_TC_TC0XC0S		(3 << 0)	/* External Clock Signal 0 Selection */
+#define			AT91_TC_TC0XC0S_TCLK0		(0 << 0)
+#define			AT91_TC_TC0XC0S_NONE		(1 << 0)
+#define			AT91_TC_TC0XC0S_TIOA1		(2 << 0)
+#define			AT91_TC_TC0XC0S_TIOA2		(3 << 0)
+#define		AT91_TC_TC1XC1S		(3 << 2)	/* External Clock Signal 1 Selection */
+#define			AT91_TC_TC1XC1S_TCLK1		(0 << 2)
+#define			AT91_TC_TC1XC1S_NONE		(1 << 2)
+#define			AT91_TC_TC1XC1S_TIOA0		(2 << 2)
+#define			AT91_TC_TC1XC1S_TIOA2		(3 << 2)
+#define		AT91_TC_TC2XC2S		(3 << 4)	/* External Clock Signal 2 Selection */
+#define			AT91_TC_TC2XC2S_TCLK2		(0 << 4)
+#define			AT91_TC_TC2XC2S_NONE		(1 << 4)
+#define			AT91_TC_TC2XC2S_TIOA0		(2 << 4)
+#define			AT91_TC_TC2XC2S_TIOA1		(3 << 4)
+
+
+#define AT91_TC_CCR		0x00		/* Channel Control Register */
+#define		AT91_TC_CLKEN		(1 << 0)	/* Counter Clock Enable Command */
+#define		AT91_TC_CLKDIS		(1 << 1)	/* Counter CLock Disable Command */
+#define		AT91_TC_SWTRG		(1 << 2)	/* Software Trigger Command */
+
+#define AT91_TC_CMR		0x04		/* Channel Mode Register */
+#define		AT91_TC_TCCLKS		(7 << 0)	/* Capture/Waveform Mode: Clock Selection */
+#define			AT91_TC_TIMER_CLOCK1		(0 << 0)
+#define			AT91_TC_TIMER_CLOCK2		(1 << 0)
+#define			AT91_TC_TIMER_CLOCK3		(2 << 0)
+#define			AT91_TC_TIMER_CLOCK4		(3 << 0)
+#define			AT91_TC_TIMER_CLOCK5		(4 << 0)
+#define			AT91_TC_XC0			(5 << 0)
+#define			AT91_TC_XC1			(6 << 0)
+#define			AT91_TC_XC2			(7 << 0)
+#define		AT91_TC_CLKI		(1 << 3)	/* Capture/Waveform Mode: Clock Invert */
+#define		AT91_TC_BURST		(3 << 4)	/* Capture/Waveform Mode: Burst Signal Selection */
+#define		AT91_TC_LDBSTOP		(1 << 6)	/* Capture Mode: Counter Clock Stopped with TB Loading */
+#define		AT91_TC_LDBDIS		(1 << 7)	/* Capture Mode: Counter Clock Disable with RB Loading */
+#define		AT91_TC_ETRGEDG		(3 << 8)	/* Capture Mode: External Trigger Edge Selection */
+#define		AT91_TC_ABETRG		(1 << 10)	/* Capture Mode: TIOA or TIOB External Trigger Selection */
+#define		AT91_TC_CPCTRG		(1 << 14)	/* Capture Mode: RC Compare Trigger Enable */
+#define		AT91_TC_WAVE		(1 << 15)	/* Capture/Waveform mode */
+#define		AT91_TC_LDRA		(3 << 16)	/* Capture Mode: RA Loading Selection */
+#define		AT91_TC_LDRB		(3 << 18)	/* Capture Mode: RB Loading Selection */
+
+#define		AT91_TC_CPCSTOP		(1 <<  6)	/* Waveform Mode: Counter Clock Stopped with RC Compare */
+#define		AT91_TC_CPCDIS		(1 <<  7)	/* Waveform Mode: Counter Clock Disable with RC Compare */
+#define		AT91_TC_EEVTEDG		(3 <<  8)	/* Waveform Mode: External Event Edge Selection */
+#define			AT91_TC_EEVTEDG_NONE		(0 << 8)
+#define			AT91_TC_EEVTEDG_RISING		(1 << 8)
+#define			AT91_TC_EEVTEDG_FALLING		(2 << 8)
+#define			AT91_TC_EEVTEDG_BOTH		(3 << 8)
+#define		AT91_TC_EEVT		(3 << 10)	/* Waveform Mode: External Event Selection */
+#define			AT91_TC_EEVT_TIOB		(0 << 10)
+#define			AT91_TC_EEVT_XC0		(1 << 10)
+#define			AT91_TC_EEVT_XC1		(2 << 10)
+#define			AT91_TC_EEVT_XC2		(3 << 10)
+#define		AT91_TC_ENETRG		(1 << 12)	/* Waveform Mode: External Event Trigger Enable */
+#define		AT91_TC_WAVESEL		(3 << 13)	/* Waveform Mode: Waveform Selection */
+#define			AT91_TC_WAVESEL_UP		(0 << 13)
+#define			AT91_TC_WAVESEL_UP_AUTO		(1 << 13)
+#define			AT91_TC_WAVESEL_UPDOWN		(2 << 13)
+#define			AT91_TC_WAVESEL_UPDOWN_AUTO	(3 << 13)
+#define		AT91_TC_ACPA		(3 << 16)	/* Waveform Mode: RA Compare Effect on TIOA */
+#define			AT91_TC_ACPA_NONE		(0 << 16)
+#define			AT91_TC_ACPA_SET		(1 << 16)
+#define			AT91_TC_ACPA_CLEAR		(2 << 16)
+#define			AT91_TC_ACPA_TOGGLE		(3 << 16)
+#define		AT91_TC_ACPC		(3 << 18)	/* Waveform Mode: RC Compre Effect on TIOA */
+#define			AT91_TC_ACPC_NONE		(0 << 18)
+#define			AT91_TC_ACPC_SET		(1 << 18)
+#define			AT91_TC_ACPC_CLEAR		(2 << 18)
+#define			AT91_TC_ACPC_TOGGLE		(3 << 18)
+#define		AT91_TC_AEEVT		(3 << 20)	/* Waveform Mode: External Event Effect on TIOA */
+#define			AT91_TC_AEEVT_NONE		(0 << 20)
+#define			AT91_TC_AEEVT_SET		(1 << 20)
+#define			AT91_TC_AEEVT_CLEAR		(2 << 20)
+#define			AT91_TC_AEEVT_TOGGLE		(3 << 20)
+#define		AT91_TC_ASWTRG		(3 << 22)	/* Waveform Mode: Software Trigger Effect on TIOA */
+#define			AT91_TC_ASWTRG_NONE		(0 << 22)
+#define			AT91_TC_ASWTRG_SET		(1 << 22)
+#define			AT91_TC_ASWTRG_CLEAR		(2 << 22)
+#define			AT91_TC_ASWTRG_TOGGLE		(3 << 22)
+#define		AT91_TC_BCPB		(3 << 24)	/* Waveform Mode: RB Compare Effect on TIOB */
+#define			AT91_TC_BCPB_NONE		(0 << 24)
+#define			AT91_TC_BCPB_SET		(1 << 24)
+#define			AT91_TC_BCPB_CLEAR		(2 << 24)
+#define			AT91_TC_BCPB_TOGGLE		(3 << 24)
+#define		AT91_TC_BCPC		(3 << 26)	/* Waveform Mode: RC Compare Effect on TIOB */
+#define			AT91_TC_BCPC_NONE		(0 << 26)
+#define			AT91_TC_BCPC_SET		(1 << 26)
+#define			AT91_TC_BCPC_CLEAR		(2 << 26)
+#define			AT91_TC_BCPC_TOGGLE		(3 << 26)
+#define		AT91_TC_BEEVT		(3 << 28)	/* Waveform Mode: External Event Effect on TIOB */
+#define			AT91_TC_BEEVT_NONE		(0 << 28)
+#define			AT91_TC_BEEVT_SET		(1 << 28)
+#define			AT91_TC_BEEVT_CLEAR		(2 << 28)
+#define			AT91_TC_BEEVT_TOGGLE		(3 << 28)
+#define		AT91_TC_BSWTRG		(3 << 30)	/* Waveform Mode: Software Trigger Effect on TIOB */
+#define			AT91_TC_BSWTRG_NONE		(0 << 30)
+#define			AT91_TC_BSWTRG_SET		(1 << 30)
+#define			AT91_TC_BSWTRG_CLEAR		(2 << 30)
+#define			AT91_TC_BSWTRG_TOGGLE		(3 << 30)
+
+#define AT91_TC_CV		0x10		/* Counter Value */
+#define AT91_TC_RA		0x14		/* Register A */
+#define AT91_TC_RB		0x18		/* Register B */
+#define AT91_TC_RC		0x1c		/* Register C */
+
+#define AT91_TC_SR		0x20		/* Status Register */
+#define		AT91_TC_COVFS		(1 <<  0)	/* Counter Overflow Status */ 
+#define		AT91_TC_LOVRS		(1 <<  1)	/* Load Overrun Status */
+#define		AT91_TC_CPAS		(1 <<  2)	/* RA Compare Status */
+#define		AT91_TC_CPBS		(1 <<  3)	/* RB Compare Status */
+#define		AT91_TC_CPCS		(1 <<  4)	/* RC Compare Status */
+#define		AT91_TC_LDRAS		(1 <<  5)	/* RA Loading Status */
+#define		AT91_TC_LDRBS		(1 <<  6)	/* RB Loading Status */
+#define		AT91_TC_ETRGS		(1 <<  7)	/* External Trigger Status */
+#define		AT91_TC_CLKSTA		(1 << 16)	/* Clock Enabling Status */
+#define		AT91_TC_MTIOA		(1 << 17)	/* TIOA Mirror */
+#define		AT91_TC_MTIOB		(1 << 18)	/* TIOB Mirror */
+
+#define AT91_TC_IER		0x24		/* Interrupt Enable Register */
+#define AT91_TC_IDR		0x28		/* Interrupt Disable Register */
+#define AT91_TC_IMR		0x2c		/* Interrupt Mask Register */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_twi.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_twi.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_twi.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_twi.h	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,57 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_twi.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Two-wire Interface (TWI) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_TWI_H
+#define AT91RM9200_TWI_H
+
+#define	AT91_TWI_CR		0x00		/* Control Register */
+#define		AT91_TWI_START		(1 <<  0)	/* Send a Start Condition */
+#define		AT91_TWI_STOP		(1 <<  1)	/* Send a Stop Condition */
+#define		AT91_TWI_MSEN		(1 <<  2)	/* Master Transfer Enable */
+#define		AT91_TWI_MSDIS		(1 <<  3)	/* Master Transfer Disable */
+#define		AT91_TWI_SWRST		(1 <<  7)	/* Software Reset */
+
+#define	AT91_TWI_MMR		0x04		/* Master Mode Register */
+#define		AT91_TWI_IADRSZ		(3    <<  8)	/* Internal Device Address Size */
+#define			AT91_TWI_IADRSZ_NO		(0 << 8)
+#define			AT91_TWI_IADRSZ_1		(1 << 8)
+#define			AT91_TWI_IADRSZ_2		(2 << 8)
+#define			AT91_TWI_IADRSZ_3		(3 << 8)
+#define		AT91_TWI_MREAD		(1    << 12)	/* Master Read Direction */
+#define		AT91_TWI_DADR		(0x7f << 16)	/* Device Address */
+
+#define	AT91_TWI_IADR		0x0c		/* Internal Address Register */
+
+#define	AT91_TWI_CWGR		0x10		/* Clock Waveform Generator Register */
+#define		AT91_TWI_CLDIV		(0xff <<  0)	/* Clock Low Divisor */
+#define		AT91_TWI_CHDIV		(0xff <<  8)	/* Clock High Divisor */
+#define		AT91_TWI_CKDIV		(7    << 16)	/* Clock Divider */
+
+#define	AT91_TWI_SR		0x20		/* Status Register */
+#define		AT91_TWI_TXCOMP		(1 <<  0)	/* Transmission Complete */
+#define		AT91_TWI_RXRDY		(1 <<  1)	/* Receive Holding Register Ready */
+#define		AT91_TWI_TXRDY		(1 <<  2)	/* Transmit Holding Register Ready */
+#define		AT91_TWI_OVRE		(1 <<  6)	/* Overrun Error */
+#define		AT91_TWI_UNRE		(1 <<  7)	/* Underrun Error */
+#define		AT91_TWI_NACK		(1 <<  8)	/* Not Acknowledged */
+
+#define	AT91_TWI_IER		0x24		/* Interrupt Enable Register */
+#define	AT91_TWI_IDR		0x28		/* Interrupt Disable Register */
+#define	AT91_TWI_IMR		0x2c		/* Interrupt Mask Register */
+#define	AT91_TWI_RHR		0x30		/* Receive Holding Register */
+#define	AT91_TWI_THR		0x34		/* Transmit Holding Register */
+
+#endif
+
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_udp.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_udp.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_udp.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_udp.h	Wed Jan 11 10:04:00 2006
@@ -0,0 +1,77 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_udp.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * USB Device Port (UDP) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_UDP_H
+#define AT91RM9200_UDP_H
+
+#define AT91_UDP_FRM_NUM	0x00		/* Frame Number Register */
+#define		AT91_UDP_NUM		(0x7ff <<  0)		/* Frame Number */
+#define		AT91_UDP_FRM_ERR	(1     << 16)		/* Frame Error */
+#define		AT91_UDP_FRM_OK		(1     << 17)		/* Frame OK */
+
+#define AT91_UDP_GLB_STAT	0x04		/* Global State Register */
+#define		AT91_UDP_FADDEN		(1 <<  0)		/* Function Address Enable */
+#define		AT91_UDP_CONFG		(1 <<  1)		/* Configured */
+#define		AT91_UDP_ESR		(1 <<  2)		/* Enable Send Resume */
+#define		AT91_UDP_RSMINPR	(1 <<  3)		/* Resume has been sent */
+#define		AT91_UDP_RMWUPE		(1 <<  4)		/* Remote Wake Up Enable */
+
+#define AT91_UDP_FADDR		0x08		/* Function Address Register */
+#define		AT91_UDP_FADD		(0x7f << 0)		/* Function Address Value */
+#define		AT91_UDP_FEN		(1    << 8)		/* Function Enable */
+
+#define AT91_UDP_IER		0x10		/* Interrupt Enable Register */
+#define AT91_UDP_IDR		0x14		/* Interrupt Disable Register */
+#define AT91_UDP_IMR		0x18		/* Interrupt Mask Register */
+
+#define AT91_UDP_ISR		0x1c		/* Interrupt Status Register */
+#define		AT91_UDP_EP(n)		(1 << (n))		/* Endpoint Interrupt Status */
+#define		AT91_UDP_RXSUSP		(1 <<  8) 		/* USB Suspend Interrupt Status */
+#define		AT91_UDP_RXRSM		(1 <<  9)		/* USB Resume Interrupt Status */
+#define		AT91_UDP_EXTRSM		(1 << 10)		/* External Resume Interrupt Status */
+#define		AT91_UDP_SOFINT		(1 << 11)		/* Start of Frame Interrupt Status */
+#define		AT91_UDP_ENDBUSRES	(1 << 12)		/* End of Bus Reset Interrpt Status */
+#define		AT91_UDP_WAKEUP		(1 << 13)		/* USB Wakeup Interrupt Status */
+
+#define AT91_UDP_ICR		0x20		/* Interrupt Clear Register */
+#define AT91_UDP_RST_EP		0x28		/* Reset Endpoint Register */
+
+#define AT91_UDP_CSR(n)		(0x30 + ((n) * 4))	/* Endpoint Control/Status Registers 0-7 */
+#define		AT91_UDP_TXCOMP		(1 <<  0)		/* Generates IN packet with data previously written in DPR */
+#define		AT91_UDP_RX_DATA_BK0	(1 <<  1)		/* Receive Data Bank 0 */
+#define		AT91_UDP_RXSETUP	(1 <<  2)		/* Send STALL to the host */
+#define		AT91_UDP_STALLSENT	(1 <<  3)		/* Stall Sent / Isochronous error (Isochronous endpoints) */
+#define		AT91_UDP_TXPKTRDY	(1 <<  4)		/* Transmit Packet Ready */
+#define		AT91_UDP_FORCESTALL	(1 <<  5)		/* Force Stall */
+#define		AT91_UDP_RX_DATA_BK1	(1 <<  6)		/* Receive Data Bank 1 */
+#define		AT91_UDP_DIR		(1 <<  7)		/* Transfer Direction */
+#define		AT91_UDP_EPTYPE		(7 <<  8)		/* Endpoint Type */
+#define			AT91_UDP_EPTYPE_CTRL		(0 <<  8)
+#define			AT91_UDP_EPTYPE_ISO_OUT		(1 <<  8)
+#define			AT91_UDP_EPTYPE_BULK_OUT	(2 <<  8)
+#define			AT91_UDP_EPTYPE_INT_OUT		(3 <<  8)
+#define			AT91_UDP_EPTYPE_ISO_IN		(5 <<  8)
+#define			AT91_UDP_EPTYPE_BULK_IN		(6 <<  8)
+#define			AT91_UDP_EPTYPE_INT_IN		(7 <<  8)
+#define		AT91_UDP_DTGLE		(1 << 11)		/* Data Toggle */
+#define		AT91_UDP_EPEDS		(1 << 15)		/* Endpoint Enable/Disable */
+#define		AT91_UDP_RXBYTECNT	(0x7ff << 16)		/* Number of bytes in FIFO */
+
+#define AT91_UDP_FDR(n)		(0x50 + ((n) * 4))	/* Endpoint FIFO Data Registers 0-7 */
+
+#define AT91_UDP_TXVC		0x74		/* Transceiver Control Register */
+#define		AT91_UDP_TXVC_TXVDIS	(1 << 8)		/* Transceiver Disable */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_usart.h linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_usart.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/at91rm9200_usart.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/at91rm9200_usart.h	Wed Jan 11 09:41:51 2006
@@ -0,0 +1,123 @@
+/*
+ * include/asm-arm/arch-at91rm9200/at91rm9200_usart.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * USART registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_USART_H
+#define AT91RM9200_USART_H
+
+#define AT91_US_CR		0x00			/* Control Register */
+#define		AT91_US_RSTRX		(1 <<  2)		/* Reset Receiver */
+#define		AT91_US_RSTTX		(1 <<  3)		/* Reset Transmitter */
+#define		AT91_US_RXEN		(1 <<  4)		/* Receiver Enable */
+#define		AT91_US_RXDIS		(1 <<  5)		/* Receiver Disable */
+#define		AT91_US_TXEN		(1 <<  6)		/* Transmitter Enable */
+#define		AT91_US_TXDIS		(1 <<  7)		/* Transmitter Disable */
+#define		AT91_US_RSTSTA		(1 <<  8)		/* Reset Status Bits */
+#define		AT91_US_STTBRK		(1 <<  9)		/* Start Break */
+#define		AT91_US_STPBRK		(1 << 10)		/* Stop Break */
+#define		AT91_US_STTTO		(1 << 11)		/* Start Time-out */
+#define		AT91_US_SENDA		(1 << 12)		/* Send Address */
+#define		AT91_US_RSTIT		(1 << 13)		/* Reset Iterations */
+#define		AT91_US_RSTNACK		(1 << 14)		/* Reset Non Acknowledge */
+#define		AT91_US_RETTO		(1 << 15)		/* Rearm Time-out */
+#define		AT91_US_DTREN		(1 << 16)		/* Data Terminal Ready Enable */
+#define		AT91_US_DTRDIS		(1 << 17)		/* Data Terminal Ready Disable */
+#define		AT91_US_RTSEN		(1 << 18)		/* Request To Send Enable */
+#define		AT91_US_RTSDIS		(1 << 19)		/* Request To Send Disable */
+
+#define AT91_US_MR		0x04			/* Mode Register */
+#define		AT91_US_USMODE		(0xf <<  0)		/* Mode of the USART */
+#define			AT91_US_USMODE_NORMAL		0
+#define			AT91_US_USMODE_RS485		1
+#define			AT91_US_USMODE_HWHS		2
+#define			AT91_US_USMODE_MODEM		3
+#define			AT91_US_USMODE_ISO7816_T0	4
+#define			AT91_US_USMODE_ISO7816_T1	6
+#define			AT91_US_USMODE_IRDA		8
+#define		AT91_US_USCLKS		(3   <<  4)		/* Clock Selection */
+#define		AT91_US_CHRL		(3   <<  6)		/* Character Length */
+#define			AT91_US_CHRL_5			(0 <<  6)
+#define			AT91_US_CHRL_6			(1 <<  6)
+#define			AT91_US_CHRL_7			(2 <<  6)
+#define			AT91_US_CHRL_8			(3 <<  6)
+#define		AT91_US_SYNC		(1 <<  8)		/* Synchronous Mode Select */
+#define		AT91_US_PAR		(7 <<  9)		/* Parity Type */
+#define			AT91_US_PAR_EVEN		(0 <<  9)
+#define			AT91_US_PAR_ODD			(1 <<  9)
+#define			AT91_US_PAR_SPACE		(2 <<  9)
+#define			AT91_US_PAR_MARK		(3 <<  9)
+#define			AT91_US_PAR_NONE		(4 <<  9)
+#define			AT91_US_PAR_MULTI_DROP		(6 <<  9)
+#define		AT91_US_NBSTOP		(3 << 12)		/* Number of Stop Bits */
+#define			AT91_US_NBSTOP_1		(0 << 12)
+#define			AT91_US_NBSTOP_1_5		(1 << 12)
+#define			AT91_US_NBSTOP_2		(2 << 12)
+#define		AT91_US_CHMODE		(3 << 14)		/* Channel Mode */
+#define			AT91_US_CHMODE_NORMAL		(0 << 14)
+#define			AT91_US_CHMODE_ECHO		(1 << 14)
+#define			AT91_US_CHMODE_LOC_LOOP		(2 << 14)
+#define			AT91_US_CHMODE_REM_LOOP		(3 << 14)
+#define		AT91_US_MSBF		(1 << 16)		/* Bit Order */
+#define		AT91_US_MODE9		(1 << 17)		/* 9-bit Character Length */
+#define		AT91_US_CLKO		(1 << 18)		/* Clock Output Select */
+#define		AT91_US_OVER		(1 << 19)		/* Oversampling Mode */
+#define		AT91_US_INACK		(1 << 20)		/* Inhibit Non Acknowledge */
+#define		AT91_US_DSNACK		(1 << 21)		/* Disable Successive NACK */
+#define		AT91_US_MAX_ITER	(7 << 24)		/* Max Iterations */
+#define		AT91_US_FILTER		(1 << 28)		/* Infrared Receive Line Filter */
+
+#define AT91_US_IER		0x08			/* Interrupt Enable Register */
+#define		AT91_US_RXRDY		(1 <<  0)		/* Receiver Ready */
+#define		AT91_US_TXRDY		(1 <<  1)		/* Transmitter Ready */
+#define		AT91_US_RXBRK		(1 <<  2)		/* Break Received / End of Break */
+#define		AT91_US_ENDRX		(1 <<  3)		/* End of Receiver Transfer */
+#define		AT91_US_ENDTX		(1 <<  4)		/* End of Transmitter Transfer */
+#define		AT91_US_OVRE		(1 <<  5)		/* Overrun Error */
+#define		AT91_US_FRAME		(1 <<  6)		/* Framing Error */
+#define		AT91_US_PARE		(1 <<  7)		/* Parity Error */
+#define		AT91_US_TIMEOUT		(1 <<  8)		/* Receiver Time-out */
+#define		AT91_US_TXEMPTY		(1 <<  9)		/* Transmitter Empty */
+#define		AT91_US_ITERATION	(1 << 10)		/* Max number of Repetitions Reached */
+#define		AT91_US_TXBUFE		(1 << 11)		/* Transmission Buffer Empty */
+#define		AT91_US_RXBUFF		(1 << 12)		/* Reception Buffer Full */
+#define		AT91_US_NACK		(1 << 13)		/* Non Acknowledge */
+#define		AT91_US_RIIC		(1 << 16)		/* Ring Indicator Input Change */
+#define		AT91_US_DSRIC		(1 << 17)		/* Data Set Ready Input Change */
+#define		AT91_US_DCDIC		(1 << 18)		/* Data Carrier Detect Input Change */
+#define		AT91_US_CTSIC		(1 << 19)		/* Clear to Send Input Change */
+#define		AT91_US_RI		(1 << 20)		/* RI */
+#define		AT91_US_DSR		(1 << 21)		/* DSR */
+#define		AT91_US_DCD		(1 << 22)		/* DCD */
+#define		AT91_US_CTS		(1 << 23)		/* CTS */
+
+#define AT91_US_IDR		0x0c			/* Interrupt Disable Register */
+#define AT91_US_IMR		0x10			/* Interrupt Mask Register */
+#define AT91_US_CSR		0x14			/* Channel Status Register */
+#define AT91_US_RHR		0x18			/* Receiver Holding Register */
+#define AT91_US_THR		0x1c			/* Transmitter Holding Register */
+
+#define AT91_US_BRGR		0x20			/* Baud Rate Generator Register */
+#define		AT91_US_CD		(0xffff << 0)		/* Clock Divider */
+
+#define AT91_US_RTOR		0x24			/* Receiver Time-out Register */
+#define		AT91_US_TO		(0xffff << 0)		/* Time-out Value */
+
+#define AT91_US_TTGR		0x28			/* Transmitter Timeguard Register */
+#define		AT91_US_TG		(0xff << 0)		/* Timeguard Value */
+
+#define AT91_US_FIDI		0x40			/* FI DI Ratio Register */
+#define AT91_US_NER		0x44			/* Number of Errors Register */
+#define AT91_US_IF		0x4c			/* IrDA Filter Register */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/board.h linux-2.6.15/include/asm-arm/arch-at91rm9200/board.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/board.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/board.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,80 @@
+/*
+ * include/asm-arm/arch-at91rm9200/board.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * These are data structures found in platform_device.dev.platform_data,
+ * and describing board-specfic data needed by drivers.  For example,
+ * which pin is used for a given GPIO role.
+ *
+ * In 2.6, drivers should strongly avoid board-specific knowledge so
+ * that supporting new boards normally won't require driver patches.
+ * Most board-specific knowledge should be in arch/.../board-*.c files.
+ */
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+ /* Clocks */
+extern unsigned long at91_master_clock;
+
+ /* Serial Port */
+extern int at91_serial_map[AT91_NR_UART];
+extern int at91_console_port;
+
+ /* USB Device */
+struct at91_udc_data {
+	u8	vbus_pin;		/* high == host powering us */
+	u8	pullup_pin;		/* high == D+ pulled up */
+};
+extern void __init at91_add_device_udc(struct at91_udc_data *data);
+
+ /* Compact Flash */
+struct at91_cf_data {
+	u8	irq_pin;		/* I/O IRQ */
+	u8	det_pin;		/* Card detect */
+	u8	vcc_pin;		/* power switching */
+	u8	rst_pin;		/* card reset */
+};
+extern void __init at91_add_device_cf(struct at91_cf_data *data);
+
+ /* MMC / SD */
+struct at91_mmc_data {
+	u8		det_pin;	/* card detect IRQ */
+	unsigned	is_b:1;		/* uses B side (vs A) */
+	unsigned	wire4:1;	/* (SD) supports DAT0..DAT3 */
+	u8		wp_pin;		/* (SD) writeprotect detect */
+	u8		vcc_pin;	/* power switching (high == on) */
+};
+extern void __init at91_add_device_mmc(struct at91_mmc_data *data);
+
+ /* Ethernet */
+struct at91_eth_data {
+	u8		phy_irq_pin;	/* PHY IRQ */
+	u8		is_rmii;	/* using RMII interface? */
+};
+extern void __init at91_add_device_eth(struct at91_eth_data *data);
+
+ /* USB Host */
+struct at91_usbh_data {
+	u8		ports;		/* number of ports on root hub */
+};
+extern void __init at91_add_device_usbh(struct at91_usbh_data *data);
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/debug-macro.S linux-2.6.15/include/asm-arm/arch-at91rm9200/debug-macro.S
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/debug-macro.S	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/debug-macro.S	Wed Jan 11 09:42:28 2006
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-at91rm9200/debug-macro.S
+ *
+ *  Copyright (C) 2003-2005 SAN People
+ *
+ * Debugging macro include header
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <asm/hardware.h>
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1				@ MMU enabled?
+	ldreq	\rx, =AT91_BASE_SYS		@ System peripherals (phys address)
+	ldrne	\rx, =AT91_VA_BASE_SYS		@ System peripherals (virt address)
+	.endm
+
+	.macro	senduart,rd,rx
+	strb	\rd, [\rx, #AT91_DBGU_THR]	@ Write to Transmitter Holding Register
+	.endm
+
+	.macro	waituart,rd,rx
+1001:	ldr	\rd, [\rx, #AT91_DBGU_SR]	@ Read Status Register
+	tst	\rd, #AT91_DBGU_TXRDY		@ DBGU_TXRDY = 1 when ready to transmit
+	beq	1001b
+	.endm
+
+	.macro	busyuart,rd,rx
+1001:	ldr	\rd, [\rx, #AT91_DBGU_SR]	@ Read Status Register
+	tst	\rd, #AT91_DBGU_TXEMPTY		@ DBGU_TXEMPTY = 1 when transmission complete
+	beq	1001b
+	.endm
+
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/dma.h linux-2.6.15/include/asm-arm/arch-at91rm9200/dma.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/dma.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/dma.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,27 @@
+/*
+ * include/asm-arm/arch-at91rm9200/dma.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/entry-macro.S linux-2.6.15/include/asm-arm/arch-at91rm9200/entry-macro.S
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/entry-macro.S	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/entry-macro.S	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,25 @@
+/*
+ * include/asm-arm/arch-at91rm9200/entry-macro.S
+ *
+ *  Copyright (C) 2003-2005 SAN People
+ *
+ * Low-level IRQ helper macros for AT91RM9200 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/hardware.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(AT91_VA_BASE_SYS)		@ base virtual address of SYS peripherals
+	ldr	\irqnr, [\base, #AT91_AIC_IVR]		@ read IRQ vector register: de-asserts nIRQ to processor (and clears interrupt)
+	ldr	\irqstat, [\base, #AT91_AIC_ISR]	@ read interrupt source number
+	teq	\irqstat, #0				@ ISR is 0 when no current interrupt, or spurious interrupt
+	streq	\tmp, [\base, #AT91_AIC_EOICR]		@ not going to be handled further, then ACK it now.
+	.endm
+
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/gpio.h linux-2.6.15/include/asm-arm/arch-at91rm9200/gpio.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/gpio.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/gpio.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,193 @@
+/*
+ * include/asm-arm/arch-at91rm9200/gpio.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91RM9200_GPIO_H
+#define __ASM_ARCH_AT91RM9200_GPIO_H
+
+#define PIN_BASE		NR_AIC_IRQS
+
+#define PQFP_GPIO_BANKS		3	/* PQFP package has 3 banks */
+#define BGA_GPIO_BANKS		4	/* BGA package has 4 banks */
+
+/* these pin numbers double as IRQ numbers, like AT91_ID_* values */
+
+#define	AT91_PIN_PA0	(PIN_BASE + 0x00 + 0)
+#define	AT91_PIN_PA1	(PIN_BASE + 0x00 + 1)
+#define	AT91_PIN_PA2	(PIN_BASE + 0x00 + 2)
+#define	AT91_PIN_PA3	(PIN_BASE + 0x00 + 3)
+#define	AT91_PIN_PA4	(PIN_BASE + 0x00 + 4)
+
+#define	AT91_PIN_PA5	(PIN_BASE + 0x00 + 5)
+#define	AT91_PIN_PA6	(PIN_BASE + 0x00 + 6)
+#define	AT91_PIN_PA7	(PIN_BASE + 0x00 + 7)
+#define	AT91_PIN_PA8	(PIN_BASE + 0x00 + 8)
+#define	AT91_PIN_PA9	(PIN_BASE + 0x00 + 9)
+
+#define	AT91_PIN_PA10	(PIN_BASE + 0x00 + 10)
+#define	AT91_PIN_PA11	(PIN_BASE + 0x00 + 11)
+#define	AT91_PIN_PA12	(PIN_BASE + 0x00 + 12)
+#define	AT91_PIN_PA13	(PIN_BASE + 0x00 + 13)
+#define	AT91_PIN_PA14	(PIN_BASE + 0x00 + 14)
+
+#define	AT91_PIN_PA15	(PIN_BASE + 0x00 + 15)
+#define	AT91_PIN_PA16	(PIN_BASE + 0x00 + 16)
+#define	AT91_PIN_PA17	(PIN_BASE + 0x00 + 17)
+#define	AT91_PIN_PA18	(PIN_BASE + 0x00 + 18)
+#define	AT91_PIN_PA19	(PIN_BASE + 0x00 + 19)
+
+#define	AT91_PIN_PA20	(PIN_BASE + 0x00 + 20)
+#define	AT91_PIN_PA21	(PIN_BASE + 0x00 + 21)
+#define	AT91_PIN_PA22	(PIN_BASE + 0x00 + 22)
+#define	AT91_PIN_PA23	(PIN_BASE + 0x00 + 23)
+#define	AT91_PIN_PA24	(PIN_BASE + 0x00 + 24)
+
+#define	AT91_PIN_PA25	(PIN_BASE + 0x00 + 25)
+#define	AT91_PIN_PA26	(PIN_BASE + 0x00 + 26)
+#define	AT91_PIN_PA27	(PIN_BASE + 0x00 + 27)
+#define	AT91_PIN_PA28	(PIN_BASE + 0x00 + 28)
+#define	AT91_PIN_PA29	(PIN_BASE + 0x00 + 29)
+
+#define	AT91_PIN_PA30	(PIN_BASE + 0x00 + 30)
+#define	AT91_PIN_PA31	(PIN_BASE + 0x00 + 31)
+
+#define	AT91_PIN_PB0	(PIN_BASE + 0x20 + 0)
+#define	AT91_PIN_PB1	(PIN_BASE + 0x20 + 1)
+#define	AT91_PIN_PB2	(PIN_BASE + 0x20 + 2)
+#define	AT91_PIN_PB3	(PIN_BASE + 0x20 + 3)
+#define	AT91_PIN_PB4	(PIN_BASE + 0x20 + 4)
+
+#define	AT91_PIN_PB5	(PIN_BASE + 0x20 + 5)
+#define	AT91_PIN_PB6	(PIN_BASE + 0x20 + 6)
+#define	AT91_PIN_PB7	(PIN_BASE + 0x20 + 7)
+#define	AT91_PIN_PB8	(PIN_BASE + 0x20 + 8)
+#define	AT91_PIN_PB9	(PIN_BASE + 0x20 + 9)
+
+#define	AT91_PIN_PB10	(PIN_BASE + 0x20 + 10)
+#define	AT91_PIN_PB11	(PIN_BASE + 0x20 + 11)
+#define	AT91_PIN_PB12	(PIN_BASE + 0x20 + 12)
+#define	AT91_PIN_PB13	(PIN_BASE + 0x20 + 13)
+#define	AT91_PIN_PB14	(PIN_BASE + 0x20 + 14)
+
+#define	AT91_PIN_PB15	(PIN_BASE + 0x20 + 15)
+#define	AT91_PIN_PB16	(PIN_BASE + 0x20 + 16)
+#define	AT91_PIN_PB17	(PIN_BASE + 0x20 + 17)
+#define	AT91_PIN_PB18	(PIN_BASE + 0x20 + 18)
+#define	AT91_PIN_PB19	(PIN_BASE + 0x20 + 19)
+
+#define	AT91_PIN_PB20	(PIN_BASE + 0x20 + 20)
+#define	AT91_PIN_PB21	(PIN_BASE + 0x20 + 21)
+#define	AT91_PIN_PB22	(PIN_BASE + 0x20 + 22)
+#define	AT91_PIN_PB23	(PIN_BASE + 0x20 + 23)
+#define	AT91_PIN_PB24	(PIN_BASE + 0x20 + 24)
+
+#define	AT91_PIN_PB25	(PIN_BASE + 0x20 + 25)
+#define	AT91_PIN_PB26	(PIN_BASE + 0x20 + 26)
+#define	AT91_PIN_PB27	(PIN_BASE + 0x20 + 27)
+#define	AT91_PIN_PB28	(PIN_BASE + 0x20 + 28)
+#define	AT91_PIN_PB29	(PIN_BASE + 0x20 + 29)
+
+#define	AT91_PIN_PB30	(PIN_BASE + 0x20 + 30)
+#define	AT91_PIN_PB31	(PIN_BASE + 0x20 + 31)
+
+#define	AT91_PIN_PC0	(PIN_BASE + 0x40 + 0)
+#define	AT91_PIN_PC1	(PIN_BASE + 0x40 + 1)
+#define	AT91_PIN_PC2	(PIN_BASE + 0x40 + 2)
+#define	AT91_PIN_PC3	(PIN_BASE + 0x40 + 3)
+#define	AT91_PIN_PC4	(PIN_BASE + 0x40 + 4)
+
+#define	AT91_PIN_PC5	(PIN_BASE + 0x40 + 5)
+#define	AT91_PIN_PC6	(PIN_BASE + 0x40 + 6)
+#define	AT91_PIN_PC7	(PIN_BASE + 0x40 + 7)
+#define	AT91_PIN_PC8	(PIN_BASE + 0x40 + 8)
+#define	AT91_PIN_PC9	(PIN_BASE + 0x40 + 9)
+
+#define	AT91_PIN_PC10	(PIN_BASE + 0x40 + 10)
+#define	AT91_PIN_PC11	(PIN_BASE + 0x40 + 11)
+#define	AT91_PIN_PC12	(PIN_BASE + 0x40 + 12)
+#define	AT91_PIN_PC13	(PIN_BASE + 0x40 + 13)
+#define	AT91_PIN_PC14	(PIN_BASE + 0x40 + 14)
+
+#define	AT91_PIN_PC15	(PIN_BASE + 0x40 + 15)
+#define	AT91_PIN_PC16	(PIN_BASE + 0x40 + 16)
+#define	AT91_PIN_PC17	(PIN_BASE + 0x40 + 17)
+#define	AT91_PIN_PC18	(PIN_BASE + 0x40 + 18)
+#define	AT91_PIN_PC19	(PIN_BASE + 0x40 + 19)
+
+#define	AT91_PIN_PC20	(PIN_BASE + 0x40 + 20)
+#define	AT91_PIN_PC21	(PIN_BASE + 0x40 + 21)
+#define	AT91_PIN_PC22	(PIN_BASE + 0x40 + 22)
+#define	AT91_PIN_PC23	(PIN_BASE + 0x40 + 23)
+#define	AT91_PIN_PC24	(PIN_BASE + 0x40 + 24)
+
+#define	AT91_PIN_PC25	(PIN_BASE + 0x40 + 25)
+#define	AT91_PIN_PC26	(PIN_BASE + 0x40 + 26)
+#define	AT91_PIN_PC27	(PIN_BASE + 0x40 + 27)
+#define	AT91_PIN_PC28	(PIN_BASE + 0x40 + 28)
+#define	AT91_PIN_PC29	(PIN_BASE + 0x40 + 29)
+
+#define	AT91_PIN_PC30	(PIN_BASE + 0x40 + 30)
+#define	AT91_PIN_PC31	(PIN_BASE + 0x40 + 31)
+
+#define	AT91_PIN_PD0	(PIN_BASE + 0x60 + 0)
+#define	AT91_PIN_PD1	(PIN_BASE + 0x60 + 1)
+#define	AT91_PIN_PD2	(PIN_BASE + 0x60 + 2)
+#define	AT91_PIN_PD3	(PIN_BASE + 0x60 + 3)
+#define	AT91_PIN_PD4	(PIN_BASE + 0x60 + 4)
+
+#define	AT91_PIN_PD5	(PIN_BASE + 0x60 + 5)
+#define	AT91_PIN_PD6	(PIN_BASE + 0x60 + 6)
+#define	AT91_PIN_PD7	(PIN_BASE + 0x60 + 7)
+#define	AT91_PIN_PD8	(PIN_BASE + 0x60 + 8)
+#define	AT91_PIN_PD9	(PIN_BASE + 0x60 + 9)
+
+#define	AT91_PIN_PD10	(PIN_BASE + 0x60 + 10)
+#define	AT91_PIN_PD11	(PIN_BASE + 0x60 + 11)
+#define	AT91_PIN_PD12	(PIN_BASE + 0x60 + 12)
+#define	AT91_PIN_PD13	(PIN_BASE + 0x60 + 13)
+#define	AT91_PIN_PD14	(PIN_BASE + 0x60 + 14)
+
+#define	AT91_PIN_PD15	(PIN_BASE + 0x60 + 15)
+#define	AT91_PIN_PD16	(PIN_BASE + 0x60 + 16)
+#define	AT91_PIN_PD17	(PIN_BASE + 0x60 + 17)
+#define	AT91_PIN_PD18	(PIN_BASE + 0x60 + 18)
+#define	AT91_PIN_PD19	(PIN_BASE + 0x60 + 19)
+
+#define	AT91_PIN_PD20	(PIN_BASE + 0x60 + 20)
+#define	AT91_PIN_PD21	(PIN_BASE + 0x60 + 21)
+#define	AT91_PIN_PD22	(PIN_BASE + 0x60 + 22)
+#define	AT91_PIN_PD23	(PIN_BASE + 0x60 + 23)
+#define	AT91_PIN_PD24	(PIN_BASE + 0x60 + 24)
+
+#define	AT91_PIN_PD25	(PIN_BASE + 0x60 + 25)
+#define	AT91_PIN_PD26	(PIN_BASE + 0x60 + 26)
+#define	AT91_PIN_PD27	(PIN_BASE + 0x60 + 27)
+#define	AT91_PIN_PD28	(PIN_BASE + 0x60 + 28)
+#define	AT91_PIN_PD29	(PIN_BASE + 0x60 + 29)
+
+#define	AT91_PIN_PD30	(PIN_BASE + 0x60 + 30)
+#define	AT91_PIN_PD31	(PIN_BASE + 0x60 + 31)
+
+#ifndef __ASSEMBLY__
+/* setup setup routines, called from board init or driver probe() */
+extern int at91_set_A_periph(unsigned pin, int use_pullup);
+extern int at91_set_B_periph(unsigned pin, int use_pullup);
+extern int at91_set_gpio_input(unsigned pin, int use_pullup);
+extern int at91_set_gpio_output(unsigned pin, int value);
+extern int at91_set_deglitch(unsigned pin, int is_on);
+
+/* callable at any time */
+extern int at91_set_gpio_value(unsigned pin, int value);
+extern int at91_get_gpio_value(unsigned pin);
+#endif
+
+#endif
+
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/hardware.h linux-2.6.15/include/asm-arm/arch-at91rm9200/hardware.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/hardware.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/hardware.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,92 @@
+/*
+ * include/asm-arm/arch-at91rm9200/hardware.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *  Copyright (C) 2003 ATMEL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#include <asm/arch/at91rm9200.h>
+#include <asm/arch/at91rm9200_sys.h>
+
+/*
+ * Remap the peripherals from address 0xFFFA0000 .. 0xFFFFFFFF
+ * to 0xFEFA0000 .. 0xFF000000.  (384Kb)
+ */
+#define AT91_IO_PHYS_BASE	0xFFFA0000
+#define AT91_IO_SIZE		(0xFFFFFFFF - AT91_IO_PHYS_BASE + 1)
+#define AT91_IO_VIRT_BASE	(0xFF000000 - AT91_IO_SIZE)
+
+ /* Convert a physical IO address to virtual IO address */
+#define AT91_IO_P2V(x)	((x) - AT91_IO_PHYS_BASE + AT91_IO_VIRT_BASE)
+
+/*
+ * Virtual to Physical Address mapping for IO devices.
+ */
+#define AT91_VA_BASE_SYS	AT91_IO_P2V(AT91_BASE_SYS)
+#define AT91_VA_BASE_SPI	AT91_IO_P2V(AT91_BASE_SPI)
+#define AT91_VA_BASE_SSC2	AT91_IO_P2V(AT91_BASE_SSC2)
+#define AT91_VA_BASE_SSC1	AT91_IO_P2V(AT91_BASE_SSC1)
+#define AT91_VA_BASE_SSC0	AT91_IO_P2V(AT91_BASE_SSC0)
+#define AT91_VA_BASE_US3	AT91_IO_P2V(AT91_BASE_US3)
+#define AT91_VA_BASE_US2	AT91_IO_P2V(AT91_BASE_US2)
+#define AT91_VA_BASE_US1	AT91_IO_P2V(AT91_BASE_US1)
+#define AT91_VA_BASE_US0	AT91_IO_P2V(AT91_BASE_US0)
+#define AT91_VA_BASE_EMAC	AT91_IO_P2V(AT91_BASE_EMAC)
+#define AT91_VA_BASE_TWI	AT91_IO_P2V(AT91_BASE_TWI)
+#define AT91_VA_BASE_MCI	AT91_IO_P2V(AT91_BASE_MCI)
+#define AT91_VA_BASE_UDP	AT91_IO_P2V(AT91_BASE_UDP)
+#define AT91_VA_BASE_TCB1	AT91_IO_P2V(AT91_BASE_TCB1)
+#define AT91_VA_BASE_TCB0	AT91_IO_P2V(AT91_BASE_TCB0)
+
+/* Internal SRAM */
+#define AT91_BASE_SRAM		0x00200000	/* Internal SRAM base address */
+#define AT91_SRAM_SIZE		0x00004000	/* Internal SRAM SIZE (16Kb) */
+
+/* Serial ports */
+#define AT91_NR_UART		5		/* 4 USART3's and one DBGU port */
+
+/* FLASH */
+#define AT91_FLASH_BASE		0x10000000	/* NCS0: Flash physical base address */
+
+/* SDRAM */
+#define AT91_SDRAM_BASE		0x20000000	/* NCS1: SDRAM physical base address */
+
+/* SmartMedia */
+#define AT91_SMARTMEDIA_BASE	0x40000000	/* NCS3: Smartmedia physical base address */
+
+/* Multi-Master Memory controller */
+#define AT91_UHP_BASE		0x00300000	/* USB Host controller */
+
+/* Clocks */
+#define AT91_SLOW_CLOCK		32768		/* slow clock */
+
+#ifndef __ASSEMBLY__
+#include <asm/io.h>
+
+static inline unsigned int at91_sys_read(unsigned int reg_offset)
+{
+	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
+
+	return readl(addr + reg_offset);
+}
+
+static inline void at91_sys_write(unsigned int reg_offset, unsigned long value)
+{
+	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
+
+	writel(value, addr + reg_offset);
+}
+#endif
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/ics1523.h linux-2.6.15/include/asm-arm/arch-at91rm9200/ics1523.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/ics1523.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/ics1523.h	Wed Jan 11 11:18:37 2006
@@ -0,0 +1,162 @@
+//*----------------------------------------------------------------------------
+//*         ATMEL Microcontroller Software Support  -  ROUSSET  -
+//*----------------------------------------------------------------------------
+//* The software is delivered "AS IS" without warranty or condition of any
+//* kind, either express, implied or statutory. This includes without
+//* limitation any warranty or condition with respect to merchantability or
+//* fitness for any particular purpose, or against the infringements of
+//* intellectual property rights of others.
+//*----------------------------------------------------------------------------
+//* File Name           : ics1523.h
+//* Object              : Clock Generator Prototyping File.
+//*
+//* 1.0 08/28/02 ED     : Creation
+//* 1.2 13/01/03 FB		: Update on lib V3
+//*----------------------------------------------------------------------------
+
+#ifndef ics1523_h
+#define ics1523_h
+
+/* Standard configurations definitions */
+#define		Clock_Conf		0x0
+
+/*-------------------------------------------*/
+/* ICS1523 TWI Serial Clock Definition       */
+/*-------------------------------------------*/
+
+#define		ICS_MIN_CLOCK		100		/* Min Frequency Access Clock KHz */
+#define		ICS_MAX_CLOCK		400		/* Max Frequency Access Clock KHz */
+#define		ICS_TRANSFER_RATE	ICS_MAX_CLOCK	/* Transfer speed to apply */
+
+#define		ICS_WRITE_CLK_PNB	30		/* TWCK Clock Periods required to write */
+#define		ICS_READ_CLK_PNB	40		/* TWCK Clock Periods required to read */
+
+/*-------------------------------------------*/
+/* ICS1523 Write Operation Definition        */
+/*-------------------------------------------*/
+
+#define		ICS1523_ACCESS_OK	0		/* OK */
+#define		ICS1523_ACCESS_ERROR	-1		/* NOK */
+
+/*-------------------------------------------*/
+/* ICS1523 Device Addresses Definition       */
+/*-------------------------------------------*/
+
+#define		ICS_ADD			0x26		/* Device Address */
+
+/*--------------------------------------------------*/
+/* ICS1523 Registers Internal Addresses Definition  */
+/*--------------------------------------------------*/
+
+#define		ICS_ICR			0x0		/* Input Control Register */
+#define		ICS_LCR			0x1		/* Loop Control Register */
+#define		ICS_FD0			0x2		/* PLL FeedBack Divider LSBs */
+#define		ICS_FD1			0x3		/* PLL FeedBack Divider MSBs */
+#define		ICS_DPAO		0x4		/* Dynamic Phase Aligner Offset */
+#define		ICS_DPAC		0x5		/* Dynamic Phase Aligner Resolution */
+#define		ICS_OE			0x6		/* Output Enables Register */
+#define		ICS_OD			0x7		/* Osc Divider Register */
+#define		ICS_SWRST		0x8		/* DPA & PLL Reset Register */
+#define		ICS_VID			0x10		/* Chip Version Register */
+#define		ICS_RID			0x11		/* Chip Revision Register */
+#define		ICS_SR			0x12		/* Status Register */
+
+/*------------------------------------------------------*/
+/* ICS1523 Input Control Register Bits Definition       */
+/*------------------------------------------------------*/
+
+#define		ICS_PDEN		0x1		/* Phase Detector Enable */
+#define		ICS_PDPOL		0x2		/* Phase Detector Enable Polarity */
+#define		ICS_REFPOL		0x4		/* External Reference Polarity */
+#define		ICS_FBKPOL		0x8		/* External Feedback Polarity */
+#define		ICS_FBKSEL		0x10		/* External Feedback Select */
+#define		ICS_FUNCSEL		0x20		/* Function Out Select */
+#define		ICS_ENPLS		0x40		/* Enable PLL Lock/Ref Status Output */
+#define		ICS_ENDLS		0x80		/* Enable DPA Lock/Ref Status Output */
+
+/*-----------------------------------------------------*/
+/* ICS1523 Loop Control Register Bits Definition       */
+/*-----------------------------------------------------*/
+
+#define		ICS_PFD			0x7		/* Phase Detector Gain */
+#define		ICS_PSD			0x30		/* Post-Scaler Divider */
+
+/*----------------------------------------------------*/
+/* ICS1523 PLL FeedBack Divider LSBs Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_FBDL		0xFF		/* PLL FeedBack Divider LSBs */
+
+/*----------------------------------------------------*/
+/* ICS1523 PLL FeedBack Divider MSBs Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_FBDM		0xF		/* PLL FeedBack Divider MSBs */
+
+/*------------------------------------------------------------*/
+/* ICS1523 Dynamic Phase Aligner Offset Bits Definition       */
+/*------------------------------------------------------------*/
+
+#define		ICS_DPAOS		0x2F		/* Dynamic Phase Aligner Offset */
+#define		ICS_FILSEL		0x80		/* Loop Filter Select */
+
+/*----------------------------------------------------------------*/
+/* ICS1523 Dynamic Phase Aligner Resolution Bits Definition       */
+/*----------------------------------------------------------------*/
+
+#define		ICS_DPARES		0x3		/* Dynamic Phase Aligner Resolution */
+#define		ICS_MMREV		0xFC		/* Metal Mask Revision Number */
+
+/*-------------------------------------------------------*/
+/* ICS1523 Output Enables Register Bits Definition       */
+/*-------------------------------------------------------*/
+
+#define		ICS_OEPCK		0x1		/* Output Enable for PECL PCLK Outputs */
+#define		ICS_OETCK		0x2		/* Output Enable for STTL CLK Output */
+#define		ICS_OEP2		0x4		/* Output Enable for PECL CLK/2 Outputs */
+#define		ICS_OET2		0x8		/* Output Enable for STTL CLK/2 Output */
+#define		ICS_OEF			0x10		/* Output Enable for STTL FUNC Output */
+#define		ICS_CLK2INV		0x20		/* CLK/2 Invert */
+#define		ICS_OSCL		0xC0		/* SSTL Clock Scaler */
+
+/*----------------------------------------------------*/
+/* ICS1523 Osc Divider Register Bits Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_OSCDIV		0x7F		/* Oscillator Divider Modulus */
+#define		ICS_INSEL		0x80		/* Input Select */
+
+/*---------------------------------------------------*/
+/* ICS1523 DPA & PLL Reset Register Definition       */
+/*---------------------------------------------------*/
+
+#define		ICS_DPAR		0x0A		/* DPA Reset Command */
+#define		ICS_PLLR		0x50		/* PLL Reset Command */
+
+/*------------------------------------------------*/
+/* ICS1523 Chip Version Register Definition       */
+/*------------------------------------------------*/
+
+#define		ICS_CHIPV		0xFF		/* Chip Version */
+
+/*-------------------------------------------------*/
+/* ICS1523 Chip Revision Register Definition       */
+/*-------------------------------------------------*/
+
+#define		ICS_CHIPR		0xFF		/* Chip Revision */
+
+/*------------------------------------------*/
+/* ICS1523 Status Register Definition       */
+/*------------------------------------------*/
+
+#define		ICS_DPALOCK		0x1		/* DPA Lock Status */
+#define		ICS_PLLLOCK		0x2		/* PLL Lock Status */
+
+/* Time constants definition */
+#define		TIMEOUT_OF_300us	3	// (10*100)us
+#define		TIMEOUT_OF_1000us	10	// (10*100)us
+
+/* Function Prototyping ics1523.c */
+int AT91F_ICS1523_clockinit(void);
+
+#endif /* ics1523_h */
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/io.h linux-2.6.15/include/asm-arm/arch-at91rm9200/io.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/io.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/io.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-at91rm9200/io.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include <asm/arch/at91rm9200.h>
+#include <asm/io.h>
+
+#define IO_SPACE_LIMIT		0xFFFFFFFF
+
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/irqs.h linux-2.6.15/include/asm-arm/arch-at91rm9200/irqs.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/irqs.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/irqs.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,52 @@
+/*
+ * include/asm-arm/arch-at91rm9200/irqs.h
+ *
+ *  Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define NR_AIC_IRQS 32
+
+
+/*
+ * Acknowledge interrupt with AIC after interrupt has been handled.
+ *   (by kernel/irq.c)
+ */
+#define irq_finish(irq) do { at91_sys_write(AT91_AIC_EOICR, 0); } while (0)
+
+
+/*
+ * IRQ interrupt symbols are the AT91_ID_* symbols in at91rm9200.h
+ * for IRQs handled directly through the AIC, or else the AT91_PIN_*
+ * symbols in gpio.h for ones handled indirectly as GPIOs.
+ * We make provision for 4 banks of GPIO.
+ */
+#include <asm/arch/gpio.h>
+
+#define	NR_IRQS		(NR_AIC_IRQS + (4 * 32))
+
+
+#ifndef __ASSEMBLY__
+/*
+ * Initialize the IRQ controller.
+ */
+extern void at91rm9200_init_irq(unsigned int priority[]);
+#endif
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/memory.h linux-2.6.15/include/asm-arm/arch-at91rm9200/memory.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/memory.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/memory.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,41 @@
+/*
+ * include/asm-arm/arch-at91rm9200/memory.h
+ *
+ *  Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/arch/hardware.h>
+
+#define PHYS_OFFSET	(AT91_SDRAM_BASE)
+
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/param.h linux-2.6.15/include/asm-arm/arch-at91rm9200/param.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/param.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/param.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,28 @@
+/*
+ * include/asm-arm/arch-at91rm9200/param.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_PARAM_H
+#define __ASM_ARCH_PARAM_H
+
+/*
+ * We use default params
+ */
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/pio.h linux-2.6.15/include/asm-arm/arch-at91rm9200/pio.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/pio.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/pio.h	Wed Jan 11 11:58:13 2006
@@ -0,0 +1,106 @@
+/*
+ * include/asm-arm/arch-at91rm9200/pio.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_PIO_H
+#define __ASM_ARCH_PIO_H
+
+#include <asm/arch/hardware.h>
+
+static inline void AT91_CfgPIO_USART0(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA17_TXD0 | AT91_PA18_RXD0 | AT91_PA20_CTS0);
+
+	/*
+	 * Errata #39 - RTS0 is not internally connected to PA21.  We need to drive
+	 *  the pin manually.  Default is off (RTS is active low).
+	 */
+	at91_sys_write(AT91_PIOA + PIO_PER, AT91_PA21_RTS0);
+	at91_sys_write(AT91_PIOA + PIO_OER, AT91_PA21_RTS0);
+	at91_sys_write(AT91_PIOA + PIO_SODR, AT91_PA21_RTS0);
+}
+
+static inline void AT91_CfgPIO_USART1(void) {
+	at91_sys_write(AT91_PIOB + PIO_PDR, AT91_PB18_RI1 | AT91_PB19_DTR1
+			| AT91_PB20_TXD1 | AT91_PB21_RXD1 | AT91_PB23_DCD1
+			| AT91_PB24_CTS1 | AT91_PB25_DSR1 | AT91_PB26_RTS1);
+}
+
+static inline void AT91_CfgPIO_USART2(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA22_RXD2 | AT91_PA23_TXD2);
+}
+
+static inline void AT91_CfgPIO_USART3(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA5_TXD3 | AT91_PA6_RXD3);
+	at91_sys_write(AT91_PIOA + PIO_BSR, AT91_PA5_TXD3 | AT91_PA6_RXD3);
+}
+
+static inline void AT91_CfgPIO_DBGU(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA31_DTXD | AT91_PA30_DRXD);
+}
+
+/*
+ * Enable the Two-Wire interface.
+ */
+static inline void AT91_CfgPIO_TWI(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA25_TWD | AT91_PA26_TWCK);
+	at91_sys_write(AT91_PIOA + PIO_ASR, AT91_PA25_TWD | AT91_PA26_TWCK);
+	at91_sys_write(AT91_PIOA + PIO_MDER, AT91_PA25_TWD | AT91_PA26_TWCK);		/* open drain */
+}
+
+/*
+ * Enable the Serial Peripheral Interface.
+ */
+static inline void AT91_CfgPIO_SPI(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA0_MISO | AT91_PA1_MOSI | AT91_PA2_SPCK);
+}
+
+static inline void AT91_CfgPIO_SPI_CS0(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA3_NPCS0);
+}
+
+static inline void AT91_CfgPIO_SPI_CS1(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA4_NPCS1);
+}
+
+static inline void AT91_CfgPIO_SPI_CS2(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA5_NPCS2);
+}
+
+static inline void AT91_CfgPIO_SPI_CS3(void) {
+	at91_sys_write(AT91_PIOA + PIO_PDR, AT91_PA6_NPCS3);
+}
+
+/*
+ * Enable NAND Flash (SmartMedia) interface.
+ */
+static inline void AT91_CfgPIO_SmartMedia(void) {
+	/* enable PC0=SMCE, PC1=SMOE, PC3=SMWE, A21=CLE, A22=ALE */
+	at91_sys_write(AT91_PIOC + PIO_ASR, AT91_PC0_BFCK | AT91_PC1_BFRDY_SMOE | AT91_PC3_BFBAA_SMWE);
+	at91_sys_write(AT91_PIOC + PIO_PDR, AT91_PC0_BFCK | AT91_PC1_BFRDY_SMOE | AT91_PC3_BFBAA_SMWE);
+
+	/* Configure PC2 as input (signal READY of the SmartMedia) */
+	at91_sys_write(AT91_PIOC + PIO_PER, AT91_PC2_BFAVD);	/* enable direct output enable */
+	at91_sys_write(AT91_PIOC + PIO_ODR, AT91_PC2_BFAVD);	/* disable output */
+
+	/* Configure PB1 as input (signal Card Detect of the SmartMedia) */
+	at91_sys_write(AT91_PIOB + PIO_PER, AT91_PIO_P(1));	/* enable direct output enable */
+	at91_sys_write(AT91_PIOB + PIO_ODR, AT91_PIO_P(1));	/* disable output */
+}
+
+static inline int AT91_PIO_SmartMedia_RDY(void) {
+	return (at91_sys_read(AT91_PIOC + PIO_PDSR) & AT91_PIO_P(2)) ? 1 : 0;
+}
+
+static inline int AT91_PIO_SmartMedia_CardDetect(void) {
+	return (at91_sys_read(AT91_PIOB + PIO_PDSR) & AT91_PIO_P(1)) ? 1 : 0;
+}
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/system.h linux-2.6.15/include/asm-arm/arch-at91rm9200/system.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/system.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/system.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,51 @@
+/*
+ * include/asm-arm/arch-at91rm9200/system.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/hardware.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * Disable the processor clock.  The processor will be automatically
+	 * re-enabled by an interrupt or by a reset.
+	 */
+//	at91_sys_write(AT91_PMC_SCDR, AT91_PMC_PCK);
+
+	/*
+	 * Set the processor (CP15) into 'Wait for Interrupt' mode.
+	 * Unlike disabling the processor clock via the PMC (above)
+	 *  this allows the processor to be woken via JTAG.
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	/*
+	 * Perform a hardware reset with the use of the Watchdog timer.
+	 */
+	at91_sys_write(AT91_ST_WDMR, AT91_ST_RSTEN | AT91_ST_EXTEN | 1);
+	at91_sys_write(AT91_ST_CR, AT91_ST_WDRST);
+}
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/timex.h linux-2.6.15/include/asm-arm/arch-at91rm9200/timex.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/timex.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/timex.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,28 @@
+/*
+ * include/asm-arm/arch-at91rm9200/timex.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <asm/arch/hardware.h>
+
+#define CLOCK_TICK_RATE		(AT91_SLOW_CLOCK)
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/uncompress.h linux-2.6.15/include/asm-arm/arch-at91rm9200/uncompress.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/uncompress.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/uncompress.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,55 @@
+/*
+ * include/asm-arm/arch-at91rm9200/uncompress.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <asm/arch/hardware.h>
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	void __iomem *sys = (void __iomem *) AT91_BASE_SYS;	/* physical address */
+
+	while (*s) {
+		while (!(__raw_readl(sys + AT91_DBGU_SR) & AT91_DBGU_TXRDY)) { barrier(); }
+		__raw_writel(*s, sys + AT91_DBGU_THR);
+		if (*s == '\n')	{
+			while (!(__raw_readl(sys + AT91_DBGU_SR) & AT91_DBGU_TXRDY)) { barrier(); }
+			__raw_writel('\r', sys + AT91_DBGU_THR);
+		}
+		s++;
+	}
+	/* wait for transmission to complete */
+	while (!(__raw_readl(sys + AT91_DBGU_SR) & AT91_DBGU_TXEMPTY)) { barrier(); }
+}
+
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/vmalloc.h linux-2.6.15/include/asm-arm/arch-at91rm9200/vmalloc.h
--- linux-2.6.15.orig/include/asm-arm/arch-at91rm9200/vmalloc.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/arch-at91rm9200/vmalloc.h	Wed Jan 11 09:23:12 2006
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-at91rm9200/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END		(AT91_IO_VIRT_BASE & PGDIR_MASK)
+
+#endif
diff -urN linux-2.6.15.orig/include/asm-arm/mach/serial_at91rm9200.h linux-2.6.15/include/asm-arm/mach/serial_at91rm9200.h
--- linux-2.6.15.orig/include/asm-arm/mach/serial_at91rm9200.h	Thu Jan  1 02:00:00 1970
+++ linux-2.6.15/include/asm-arm/mach/serial_at91rm9200.h	Wed Jan 11 09:24:58 2006
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/mach/serial_at91rm9200.h
+ *
+ *  Based on serial_sa1100.h  by Nicolas Pitre
+ *
+ *  Copyright (C) 2002 ATMEL Rousset
+ *
+ *  Low level machine dependent UART functions.
+ */
+#include <linux/config.h>
+
+struct uart_port;
+
+/*
+ * This is a temporary structure for registering these
+ * functions; it is intended to be discarded after boot.
+ */
+struct at91rm9200_port_fns {
+	void	(*set_mctrl)(struct uart_port *, u_int);
+	u_int	(*get_mctrl)(struct uart_port *);
+	void	(*enable_ms)(struct uart_port *);
+	void	(*pm)(struct uart_port *, u_int, u_int);
+	int	(*set_wake)(struct uart_port *, u_int);
+	int	(*open)(struct uart_port *);
+	void	(*close)(struct uart_port *);
+};
+
+#if defined(CONFIG_SERIAL_AT91)
+void at91_register_uart_fns(struct at91rm9200_port_fns *fns);
+void at91_register_uart(int idx, int port);
+#else
+#define at91_register_uart_fns(fns) do { } while (0)
+#define at91_register_uart(idx,port) do { } while (0)
+#endif
+
+
diff -urN linux-2.6.15.orig/include/linux/serial_core.h linux-2.6.15/include/linux/serial_core.h
--- linux-2.6.15.orig/include/linux/serial_core.h	Wed Jan 11 09:19:37 2006
+++ linux-2.6.15/include/linux/serial_core.h	Wed Jan 11 09:24:58 2006
@@ -67,6 +67,9 @@
 /* Parisc type numbers. */
 #define PORT_MUX	48
 
+/* Atmel AT91RM9200 SoC */
+#define PORT_AT91RM9200 49
+
 /* Macintosh Zilog type numbers */
 #define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
 #define PORT_PMAC_ZILOG	51

