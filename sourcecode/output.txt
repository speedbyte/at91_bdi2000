printf is broken dont use it !!!!!!!!!!!!!!!
======================================
AT91RM9200 MCI Device Test
======================================

Init MCI Interface

Test MCI Device
1:Test MMC
2: Test SDCard

Enter Test SDCard

SDCard Initialisation Successful: Enter Test

Tests Completed: !!!

This sentence is written in your device... Congratulations

Tests MCI SDCard Successful !!!

Test MCI Device
1:Test MMC
2: Test SDCard


debug - mmc_read
 src 0 dst 2000aa90 end 200 pstart 0 pend 0
 astart 0 aend 200




-----------------------------------------

int
mmc_block_read(uchar *dst, ulong src, ulong len) - pxa
int
mmc_block_write(ulong dst, uchar *src, int len)  - pxa
int
mmc_read(ulong src, uchar *dst, int size)   - (mmc_block_read((uchar *)(dst), src, mmc_block_size)
int
mmc_write(uchar *src, ulong dst, int size)  - mmc_block_write(dst, (uchar *)src, mmc_block_size))


AT91S_MCIDeviceStatus AT91F_MCI_WriteBlock(
	AT91PS_MciDevice pMCI_Device,
	int dest,
	unsigned int *dataBuffer,
	int sizeToWrite )

AT91F_MCI_WriteBlock(&MCI_Device,512,(unsigned int*) mmc_buf,len);


AT91S_MCIDeviceStatus AT91F_MCI_ReadBlock(
	AT91PS_MciDevice pMCI_Device,
	int src,
	unsigned int *dataBuffer,
	int sizeToRead )

AT91F_MCI_ReadBlock(&MCI_Device, 512, (unsigned int*)mmc_buf,len);



mmc_read(cgf_mmc_base, mmc_buf, CFG_MMC_BLOCKSIZE);

from mmc_read - src -= CFG_MMC_BASE; dst = mmc_buf,  mmc_block_size = CFG_MMC_BLOCKSIZE;
mmc_block_read((uchar *)(dst), src, mmc_block_size))


mmc_write(mmc_buf, cfg_mmc_base , CFG_MMC_BLOCKSIZE);

from mmc_read - dst -= CFG_MMC_BASE; src = mmc_buf,  mmc_block_size = CFG_MMC_BLOCKSIZE;
mmc_block_write((uchar *)(src), dst, mmc_block_size))


 
Write in MCI : 
    AT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);
    AT91C_BASE_PDC_MCI->PDC_TPR = (unsigned int) dataBuffer;
    AT91C_BASE_PDC_MCI->PDC_TCR = sizeToWrite;


Transfers can be enabled and/or disabled
by setting TXTEN/TXTDIS and RXTEN/RXTDIS in PDC Transfer Control Register. These
control bits enable reading the pointer and counter registers safely without any risk of their
changing between both reads.


Data Transfers
The peripheral triggers PDC transfers using transmit (TXRDY) and receive (RXRDY) signals.
When the peripheral receives an external character, it sends a Receive Ready signal to the PDC
which then requests access to the system bus. When access is granted, the PDC starts a read
of the peripheral Receive Holding Register (RHR) and then triggers a write in the memory.
After each transfer, the relevant PDC memory pointer is incremented and the number of transfers
left is decremented. When the memory block size is reached, a signal is sent to the
peripheral and the transfer stops.
The same procedure is followed, in reverse, for transmit transfers.


Next character to be transmitted after the current character if TXRDY is not set. When number of data bits is less than 8 bits, the bits are right-aligned.

The peripheral end flag is automatically cleared when one of the counter-registers (Counter or
Next Counter Register) is written. Before that it is set to 1.
Note: When the Next Counter Register is loaded into the Counter Register, it is set to zero.


When TXTDY signal is sent to the PDC from the peripheral, the PDC starts to reuest access of the bus, When the access is given then it it starts to transfer the data ( after reading the pointer and counter registers ) to the THR of the preipheral. It transfers till the counter is 0 and there is no nextpointer.


AT91F_PDC_IsRxEmpty() checks for RCR ( if the counter register has ran )

find the use of TIOB

PIO

An input change interrupt enabling level change on any I/O line.
Synchronous Output, Provides Set and Clear of Several I/O lines in a Single Write
When
an I/O line is general-purpose only, i.e. not multiplexed with any peripheral I/O, programming of
the PIO Controller regarding the assignment to a peripheral has no effect and only the PIO Controller
can control how the pin is driven by the product.

Power Management : AT91F_PMC_EnablePeriphClock(pmc, id)
Reading a 1 in
PIO_PUSR means the pull-up is disabled and reading a 0 means the pull-up is enabled. PIO_PUSR resets at the value 0x0. ( all pulled up - 3.3 V except few SDRAM related ). Program PIO_PUDR to pull the pin low.

When a pin is multiplexed with one or two peripheral functions, the selection is controlled with
the registers PIO_PER (PIO Enable Register) and PIO_PDR (PIO Disable Register). - Scenarios where multiplexing of a single pin ( if one needs both peripheral on that pin )
PIO or Peripheral :
Use PDR to disable peripheral fn ( rem it is automatically disabled at reset ) . Use PUDR to pull the pin low or high. .A value of 0 indicates that the pin is controlled by the corresponding on-chip peripheral selected in the
PIO_ABSR (AB Select Status Register). A value of 1 indicates the pin is controlled by the PIO
controller.
If a pin is used as a general purpose I/O line (not multiplexed with an on-chip peripheral),
PIO_PER and PIO_PDR have no effect and PIO_PSR returns 1 for the corresponding bit. So PIO_PER is only valid in the case of multiplexing and when the line corresponding pin has to be run by the peripheral
PIO_PSR shows which functionlaity ( Per or PIO )
PIO_ABSE shows which peripheral ( A or B ) enabled - A =0
When driven by PIO controller :
When the I/O line is controlled by the PIO controller, the pin can be configured to be driven. This
is done by writing PIO_OER (Output Enable Register) and PIO_PDR (Output Disable Register).The results of these write operations are detected in PIO_OSR (Output Status Register). When a bit in this register is at 0, the corresponding I/O line is used as an input only. When the bit is at 1, the corresponding I/O line is driven by the PIO controller.




		for ( i = 0; i < 512; i ++ )
200015e4:	e3a03000 	mov	r3, #0	; 0x0
200015e8:	e50b3010 	str	r3, [fp, #-16]
200015ec:	ea000008 	b	20001614 <AT91F_MCI_Device_Handler+0xac>
		Buffer2[i] = Buffer1[i];
200015f0:	e51b1010 	ldr	r1, [fp, #-16]
200015f4:	e51b2010 	ldr	r2, [fp, #-16]
200015f8:	e59f3080 	ldr	r3, [pc, #128]	; 20001680 <.text+0x1680>
200015fc:	e7d33002 	ldrb	r3, [r3, r2]
20001600:	e59f207c 	ldr	r2, [pc, #124]	; 20001684 <.text+0x1684>
20001604:	e7c23001 	strb	r3, [r2, r1]
20001608:	e51b3010 	ldr	r3, [fp, #-16]
2000160c:	e2833001 	add	r3, r3, #1	; 0x1
20001610:	e50b3010 	str	r3, [fp, #-16]
20001614:	e51b2010 	ldr	r2, [fp, #-16]
20001618:	e59f3068 	ldr	r3, [pc, #104]	; 20001688 <.text+0x1688>
2000161c:	e1520003 	cmp	r2, r3
20001620:	dafffff2 	ble	200015f0 <AT91F_MCI_Device_Handler+0x88>




		for ( i = 0; i < 512; i ++ )
200015e4:	e3a03000 	mov	r3, #0	; 0x0
200015e8:	e50b3010 	str	r3, [fp, #-16]
200015ec:	ea000008 	b	20001614 <AT91F_MCI_Device_Handler+0xac>
		Buffer2[i] = (unsigned int)Buffer1[i];
200015f0:	e51b1010 	ldr	r1, [fp, #-16]
200015f4:	e51b2010 	ldr	r2, [fp, #-16]
200015f8:	e59f3080 	ldr	r3, [pc, #128]	; 20001680 <.text+0x1680>
200015fc:	e7d33002 	ldrb	r3, [r3, r2]
20001600:	e59f207c 	ldr	r2, [pc, #124]	; 20001684 <.text+0x1684>
20001604:	e7c23001 	strb	r3, [r2, r1]
20001608:	e51b3010 	ldr	r3, [fp, #-16]
2000160c:	e2833001 	add	r3, r3, #1	; 0x1
20001610:	e50b3010 	str	r3, [fp, #-16]
20001614:	e51b2010 	ldr	r2, [fp, #-16]
20001618:	e59f3068 	ldr	r3, [pc, #104]	; 20001688 <.text+0x1688>
2000161c:	e1520003 	cmp	r2, r3
20001620:	dafffff2 	ble	200015f0 <AT91F_MCI_Device_Handler+0x88>